<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://facebook.github.io/react/">react-dom (v15.5.3)</a>
</h1>
<h4>React package for working with the DOM.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom">module react-dom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue">
            function <span class="apidocSignatureSpan">react-dom.</span>CallbackQueue
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree">
            function <span class="apidocSignatureSpan">react-dom.</span>DOMLazyTree
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState">
            function <span class="apidocSignatureSpan">react-dom.</span>FallbackCompositionState
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMEmptyComponent
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextComponent
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(useCreateElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactServerRenderingTransaction
            <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactServerUpdateQueue
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactShallowRenderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactSimpleEmptyComponent
            <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactTestReconcileTransaction
            <span class="apidocSignatureSpan">(testOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>ResponderSyntheticEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticAnimationEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticClipboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticCompositionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticDragEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticEvent
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticFocusEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticInputEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticKeyboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticMouseEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTouchEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTransitionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticUIEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticWheelEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.findDOMNode">
            function <span class="apidocSignatureSpan">react-dom.</span>findDOMNode
            <span class="apidocSignatureSpan">(componentOrElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.render">
            function <span class="apidocSignatureSpan">react-dom.</span>render
            <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.unmountComponentAtNode">
            function <span class="apidocSignatureSpan">react-dom.</span>unmountComponentAtNode
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.unstable_batchedUpdates">
            function <span class="apidocSignatureSpan">react-dom.</span>unstable_batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.unstable_renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-dom.</span>unstable_renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.validateDOMNesting">
            function <span class="apidocSignatureSpan">react-dom.</span>validateDOMNesting
            <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>AutoFocusUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>BeforeInputEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>CSSPropertyOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>CallbackQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ChangeEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>DOMChildrenOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>DOMProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>DOMPropertyOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>Danger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>EnterLeaveEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>EventPluginHub</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>EventPluginRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>EventPluginUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>EventPropagators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>FallbackCompositionState.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>HTMLDOMPropertyConfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>KeyEscapeUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>LinkedValueUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>PooledClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactBrowserEventEmitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactChildFiber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactChildReconciler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactComponentBrowserEnvironment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactComponentEnvironment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactComponentTreeTestUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactCompositeComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactCoroutine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponentTree</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMEmptyComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMIDOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMInput</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMInvalidARIAHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMNullInputValuePropHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMOption</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMSelect</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMSelection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextarea</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTreeTraversal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDOMUnknownPropertyHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDebugTool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDefaultBatchingStrategy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactDefaultInjection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactEmptyComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactErrorUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactEventEmitterMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactEventListener</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactFiber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactFiberRoot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactFiberUpdateQueue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactHostComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactHostOperationHistoryHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactInputSelection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactInstanceMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactInvalidSetStateWarningHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactMarkupChecksum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactMount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactNodeTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactOwner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactPerf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactReconcileTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactReconciler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactRef</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactReifiedYield</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactServerBatchingStrategy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactServerRendering</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactServerRenderingTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactServerUpdateQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactShallowRenderer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactSimpleEmptyComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactTestReconcileTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactTestUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactUpdateQueue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ReactUpdates</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ResponderEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ResponderSyntheticEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ResponderTouchHistoryStore</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SelectEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SimpleEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticAnimationEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticClipboardEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticCompositionEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticDragEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticFocusEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticInputEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticKeyboardEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticMouseEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticTouchEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticTransitionEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticUIEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>SyntheticWheelEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>TapEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>TouchHistoryMath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>Transaction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>ViewportMetrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.</span>__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.AutoFocusUtils">module react-dom.AutoFocusUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.AutoFocusUtils.focusDOMComponent">
            function <span class="apidocSignatureSpan">react-dom.AutoFocusUtils.</span>focusDOMComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.BeforeInputEventPlugin">module react-dom.BeforeInputEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.BeforeInputEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.BeforeInputEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.BeforeInputEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.CSSPropertyOperations">module react-dom.CSSPropertyOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CSSPropertyOperations.createMarkupForStyles">
            function <span class="apidocSignatureSpan">react-dom.CSSPropertyOperations.</span>createMarkupForStyles
            <span class="apidocSignatureSpan">(styles, component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CSSPropertyOperations.setValueForStyles">
            function <span class="apidocSignatureSpan">react-dom.CSSPropertyOperations.</span>setValueForStyles
            <span class="apidocSignatureSpan">(node, styles, component)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.CallbackQueue">module react-dom.CallbackQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.CallbackQueue">
            function <span class="apidocSignatureSpan">react-dom.</span>CallbackQueue
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.getPooled">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.release">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.CallbackQueue.prototype">module react-dom.CallbackQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.enqueue">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.notifyAll">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>notifyAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.reset">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.CallbackQueue.prototype.rollback">
            function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>rollback
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ChangeEventPlugin">module react-dom.ChangeEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ChangeEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.ChangeEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ChangeEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.DOMChildrenOperations">module react-dom.DOMChildrenOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>dangerouslyReplaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMChildrenOperations.processUpdates">
            function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>processUpdates
            <span class="apidocSignatureSpan">(parentNode, updates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMChildrenOperations.replaceDelimitedText">
            function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>replaceDelimitedText
            <span class="apidocSignatureSpan">(openingComment, closingComment, stringText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.DOMLazyTree">module react-dom.DOMLazyTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.DOMLazyTree">
            function <span class="apidocSignatureSpan">react-dom.</span>DOMLazyTree
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.insertTreeBefore">
            function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>insertTreeBefore
            <span class="apidocSignatureSpan">(parentNode, tree, referenceNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.queueChild">
            function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueChild
            <span class="apidocSignatureSpan">(parentTree, childTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.queueHTML">
            function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueHTML
            <span class="apidocSignatureSpan">(tree, html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.queueText">
            function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueText
            <span class="apidocSignatureSpan">(tree, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMLazyTree.replaceChildWithTree">
            function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>replaceChildWithTree
            <span class="apidocSignatureSpan">(oldNode, newTree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.DOMProperty">module react-dom.DOMProperty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMProperty.isCustomAttribute">
            function <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>isCustomAttribute
            <span class="apidocSignatureSpan">(attributeName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>_isCustomAttributeFunctions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>getPossibleStandardName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>injection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>ATTRIBUTE_NAME_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>ATTRIBUTE_NAME_START_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>ID_ATTRIBUTE_NAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>ROOT_ATTRIBUTE_NAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.DOMPropertyOperations">module react-dom.DOMPropertyOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForCustomAttribute">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForCustomAttribute
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForID">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForProperty">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForProperty
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForRoot">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.deleteValueForAttribute">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>deleteValueForAttribute
            <span class="apidocSignatureSpan">(node, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.deleteValueForProperty">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>deleteValueForProperty
            <span class="apidocSignatureSpan">(node, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.setAttributeForID">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setAttributeForID
            <span class="apidocSignatureSpan">(node, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.setAttributeForRoot">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setAttributeForRoot
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.setValueForAttribute">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setValueForAttribute
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.DOMPropertyOperations.setValueForProperty">
            function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setValueForProperty
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.Danger">module react-dom.Danger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Danger.dangerouslyReplaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-dom.Danger.</span>dangerouslyReplaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.EnterLeaveEventPlugin">module react-dom.EnterLeaveEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EnterLeaveEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.EnterLeaveEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EnterLeaveEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.EventPluginHub">module react-dom.EventPluginHub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.__getListenerBank">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>__getListenerBank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.__purge">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>__purge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.deleteAllListeners">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>deleteAllListeners
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.deleteListener">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>deleteListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.enqueueEvents">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>enqueueEvents
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.getListener">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>getListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.processEventQueue">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>processEventQueue
            <span class="apidocSignatureSpan">(simulated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginHub.putListener">
            function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>putListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.EventPluginRegistry">module react-dom.EventPluginRegistry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginRegistry._resetEventPlugins">
            function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>_resetEventPlugins
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginRegistry.getPluginModuleForEvent">
            function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>getPluginModuleForEvent
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginRegistry.injectEventPluginOrder">
            function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>injectEventPluginOrder
            <span class="apidocSignatureSpan">(injectedEventPluginOrder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginRegistry.injectEventPluginsByName">
            function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>injectEventPluginsByName
            <span class="apidocSignatureSpan">(injectedNamesToPlugins)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>eventNameDispatchConfigs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>possibleRegistrationNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>registrationNameDependencies</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>registrationNameModules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.EventPluginUtils">module react-dom.EventPluginUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.executeDirectDispatch">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDirectDispatch
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrder">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDispatchesInOrder
            <span class="apidocSignatureSpan">(event, simulated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrderStopAtTrue">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDispatchesInOrderStopAtTrue
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.getInstanceFromNode">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.getLowestCommonAncestor">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getLowestCommonAncestor
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.getNodeFromInstance">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getNodeFromInstance
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.getParentInstance">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getParentInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.hasDispatches">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>hasDispatches
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.isAncestor">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isAncestor
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.isEndish">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isEndish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.isMoveish">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isMoveish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.isStartish">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isStartish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.traverseEnterLeave">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>traverseEnterLeave
            <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPluginUtils.traverseTwoPhase">
            function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>traverseTwoPhase
            <span class="apidocSignatureSpan">(target, fn, arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.EventPropagators">module react-dom.EventPropagators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPropagators.accumulateDirectDispatches">
            function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateDirectDispatches
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPropagators.accumulateEnterLeaveDispatches">
            function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateEnterLeaveDispatches
            <span class="apidocSignatureSpan">(leave, enter, from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatches">
            function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateTwoPhaseDispatches
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget">
            function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateTwoPhaseDispatchesSkipTarget
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.FallbackCompositionState">module react-dom.FallbackCompositionState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.FallbackCompositionState">
            function <span class="apidocSignatureSpan">react-dom.</span>FallbackCompositionState
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.getPooled">
            function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.release">
            function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.FallbackCompositionState.prototype">module react-dom.FallbackCompositionState.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.prototype.getData">
            function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>getData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.FallbackCompositionState.prototype.getText">
            function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.HTMLDOMPropertyConfig">module react-dom.HTMLDOMPropertyConfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.HTMLDOMPropertyConfig.isCustomAttribute">
            function <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>isCustomAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>DOMAttributeNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>DOMMutationMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>DOMPropertyNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>Properties</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.KeyEscapeUtils">module react-dom.KeyEscapeUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.KeyEscapeUtils.escape">
            function <span class="apidocSignatureSpan">react-dom.KeyEscapeUtils.</span>escape
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.KeyEscapeUtils.unescape">
            function <span class="apidocSignatureSpan">react-dom.KeyEscapeUtils.</span>unescape
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.LinkedValueUtils">module react-dom.LinkedValueUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.LinkedValueUtils.checkPropTypes">
            function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>checkPropTypes
            <span class="apidocSignatureSpan">(tagName, props, owner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.LinkedValueUtils.executeOnChange">
            function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>executeOnChange
            <span class="apidocSignatureSpan">(inputProps, event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.LinkedValueUtils.getChecked">
            function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>getChecked
            <span class="apidocSignatureSpan">(inputProps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.LinkedValueUtils.getValue">
            function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>getValue
            <span class="apidocSignatureSpan">(inputProps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.PooledClass">module react-dom.PooledClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.PooledClass.addPoolingTo">
            function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>addPoolingTo
            <span class="apidocSignatureSpan">(CopyConstructor, pooler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.PooledClass.fourArgumentPooler">
            function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>fourArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.PooledClass.oneArgumentPooler">
            function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>oneArgumentPooler
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.PooledClass.threeArgumentPooler">
            function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>threeArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2, a3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.PooledClass.twoArgumentPooler">
            function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>twoArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactBrowserEventEmitter">module react-dom.ReactBrowserEventEmitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.ensureScrollValueMonitoring">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>ensureScrollValueMonitoring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.handleTopLevel">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.isEnabled">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>isEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.listenTo">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>listenTo
            <span class="apidocSignatureSpan">(registrationName, contentDocumentHandle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.setEnabled">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>setEnabled
            <span class="apidocSignatureSpan">(enabled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.supportsEventPageXY">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>supportsEventPageXY
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.trapBubbledEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>trapBubbledEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactBrowserEventEmitter.trapCapturedEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>trapCapturedEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>ReactEventListener</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactChildFiber">module react-dom.ReactChildFiber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildFiber.cloneChildFibers">
            function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>cloneChildFibers
            <span class="apidocSignatureSpan">(current, workInProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildFiber.reconcileChildFibers">
            function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>reconcileChildFibers
            <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildFiber.reconcileChildFibersInPlace">
            function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>reconcileChildFibersInPlace
            <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactChildReconciler">module react-dom.ReactChildReconciler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildReconciler.instantiateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>instantiateChildren
            <span class="apidocSignatureSpan">(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildReconciler.unmountChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>unmountChildren
            <span class="apidocSignatureSpan">(renderedChildren, safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactChildReconciler.updateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>updateChildren
            <span class="apidocSignatureSpan">(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactComponentBrowserEnvironment">module react-dom.ReactComponentBrowserEnvironment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentBrowserEnvironment.processChildrenUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentBrowserEnvironment.</span>processChildrenUpdates
            <span class="apidocSignatureSpan">(parentInst, updates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentBrowserEnvironment.replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentBrowserEnvironment.</span>replaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactComponentEnvironment">module react-dom.ReactComponentEnvironment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentEnvironment.processChildrenUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentEnvironment.</span>processChildrenUpdates
            <span class="apidocSignatureSpan">(parentInst, updates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentEnvironment.replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentEnvironment.</span>replaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactComponentEnvironment.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactComponentTreeTestUtils">module react-dom.ReactComponentTreeTestUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.expectTree">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>expectTree
            <span class="apidocSignatureSpan">(rootID, expectedTree, parentPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.getRegisteredDisplayNames">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>getRegisteredDisplayNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.getRootDisplayNames">
            function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>getRootDisplayNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactCompositeComponent">module react-dom.ReactCompositeComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._checkContextTypes">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_checkContextTypes
            <span class="apidocSignatureSpan">(typeSpecs, values, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._constructComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_constructComponent
            <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._constructComponentWithoutOwner">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_constructComponentWithoutOwner
            <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._maskContext">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_maskContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._performComponentUpdate">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_performComponentUpdate
            <span class="apidocSignatureSpan">(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._processChildContext">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processChildContext
            <span class="apidocSignatureSpan">(currentContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._processContext">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._processPendingState">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processPendingState
            <span class="apidocSignatureSpan">(props, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_renderValidatedComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_renderValidatedComponentWithoutOwnerOrContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_replaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldHostNode, nextMarkup, prevInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent._updateRenderedComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_updateRenderedComponent
            <span class="apidocSignatureSpan">(transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.attachRef">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>attachRef
            <span class="apidocSignatureSpan">(ref, component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.construct">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>construct
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.detachRef">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>detachRef
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.getName">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.getPublicInstance">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getPublicInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.performInitialMount">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performInitialMount
            <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.performInitialMountWithErrorHandling">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performInitialMountWithErrorHandling
            <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.performUpdateIfNecessary">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performUpdateIfNecessary
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextElement, transaction, nextContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>unmountComponent
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCompositeComponent.updateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>updateComponent
            <span class="apidocSignatureSpan">(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_instantiateReactComponent</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactCoroutine">module react-dom.ReactCoroutine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCoroutine.createCoroutine">
            function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>createCoroutine
            <span class="apidocSignatureSpan">(children, handler, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCoroutine.createYield">
            function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>createYield
            <span class="apidocSignatureSpan">(props, continuation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCoroutine.isCoroutine">
            function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>isCoroutine
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactCoroutine.isYield">
            function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>isYield
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">symbol <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>REACT_COROUTINE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">symbol <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>REACT_YIELD_TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMComponent">module react-dom.ReactDOMComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.ReactDOMComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.</span>Mixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMComponent.prototype">module react-dom.ReactDOMComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createContentMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createContentMarkup
            <span class="apidocSignatureSpan">(transaction, props, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createInitialChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createInitialChildren
            <span class="apidocSignatureSpan">(transaction, props, context, lazyTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createOpenTagMarkupAndPutListeners
            <span class="apidocSignatureSpan">(transaction, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._mountChildAtIndex">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_mountChildAtIndex
            <span class="apidocSignatureSpan">(child, mountImage, afterNode, index, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerInstantiateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_reconcilerInstantiateChildren
            <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerUpdateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_reconcilerUpdateChildren
            <span class="apidocSignatureSpan">(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._unmountChild">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_unmountChild
            <span class="apidocSignatureSpan">(child, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateChildren
            <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateDOMChildren
            <span class="apidocSignatureSpan">(lastProps, nextProps, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMProperties">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateDOMProperties
            <span class="apidocSignatureSpan">(lastProps, nextProps, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.createChild">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>createChild
            <span class="apidocSignatureSpan">(child, afterNode, mountImage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.getPublicInstance">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>getPublicInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.mountChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>mountChildren
            <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.moveChild">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>moveChild
            <span class="apidocSignatureSpan">(child, afterNode, toIndex, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextElement, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.removeChild">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>removeChild
            <span class="apidocSignatureSpan">(child, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.unmountChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>unmountChildren
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateChildren
            <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateComponent
            <span class="apidocSignatureSpan">(transaction, prevElement, nextElement, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateMarkup
            <span class="apidocSignatureSpan">(nextMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateTextContent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateTextContent
            <span class="apidocSignatureSpan">(nextContent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMComponentTree">module react-dom.ReactDOMComponentTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.getClosestInstanceFromNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getClosestInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.getInstanceFromNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.getNodeFromInstance">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getNodeFromInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.precacheChildNodes">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>precacheChildNodes
            <span class="apidocSignatureSpan">(inst, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.precacheNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>precacheNode
            <span class="apidocSignatureSpan">(inst, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMComponentTree.uncacheNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>uncacheNode
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMEmptyComponent">module react-dom.ReactDOMEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent.ReactDOMEmptyComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMEmptyComponent
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMEmptyComponent.prototype">module react-dom.ReactDOMEmptyComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMIDOperations">module react-dom.ReactDOMIDOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMIDOperations.</span>dangerouslyProcessChildrenUpdates
            <span class="apidocSignatureSpan">(parentInst, updates)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMInput">module react-dom.ReactDOMInput</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInput.getHostProps">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInput.mountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInput.postMountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInput.updateWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>updateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMInvalidARIAHook">module react-dom.ReactDOMInvalidARIAHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInvalidARIAHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMInvalidARIAHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMNullInputValuePropHook">module react-dom.ReactDOMNullInputValuePropHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMNullInputValuePropHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMNullInputValuePropHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMOption">module react-dom.ReactDOMOption</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMOption.getHostProps">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMOption.mountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props, hostParent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMOption.postMountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMSelect">module react-dom.ReactDOMSelect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelect.getHostProps">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelect.getSelectValueContext">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>getSelectValueContext
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelect.mountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelect.postUpdateWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>postUpdateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMSelection">module react-dom.ReactDOMSelection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelection.getOffsets">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelection.</span>getOffsets
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMSelection.setOffsets">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMSelection.</span>setOffsets
            <span class="apidocSignatureSpan">(node, offsets)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMServer">module react-dom.ReactDOMServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMServer.renderToStaticMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMServer.</span>renderToStaticMarkup
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMServer.renderToString">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMServer.</span>renderToString
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.ReactDOMServer.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMTextComponent">module react-dom.ReactDOMTextComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent.ReactDOMTextComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextComponent
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMTextComponent.prototype">module react-dom.ReactDOMTextComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextText, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMTextarea">module react-dom.ReactDOMTextarea</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextarea.getHostProps">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextarea.mountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextarea.postMountWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTextarea.updateWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>updateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMTreeTraversal">module react-dom.ReactDOMTreeTraversal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTreeTraversal.getLowestCommonAncestor">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>getLowestCommonAncestor
            <span class="apidocSignatureSpan">(instA, instB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTreeTraversal.getParentInstance">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>getParentInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTreeTraversal.isAncestor">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>isAncestor
            <span class="apidocSignatureSpan">(instA, instB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTreeTraversal.traverseEnterLeave">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>traverseEnterLeave
            <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMTreeTraversal.traverseTwoPhase">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>traverseTwoPhase
            <span class="apidocSignatureSpan">(inst, fn, arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDOMUnknownPropertyHook">module react-dom.ReactDOMUnknownPropertyHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMUnknownPropertyHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDOMUnknownPropertyHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDebugTool">module react-dom.ReactDebugTool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.addDevtool">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>addDevtool
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.addHook">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>addHook
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.beginProfiling">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>beginProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.endProfiling">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>endProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.getFlushHistory">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>getFlushHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.isProfiling">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>isProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element, parentDebugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeforeUnmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeUnmountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeginFlush">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeginLifeCycleTimer">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginLifeCycleTimer
            <span class="apidocSignatureSpan">(debugID, timerType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onBeginProcessingChildContext">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onEndFlush">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onEndLifeCycleTimer">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndLifeCycleTimer
            <span class="apidocSignatureSpan">(debugID, timerType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onEndProcessingChildContext">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onHostOperation">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onHostOperation
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onMountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onMountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onSetChildren">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onSetChildren
            <span class="apidocSignatureSpan">(debugID, childDebugIDs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onSetState">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onSetState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onTestEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onTestEvent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onUnmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onUnmountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.onUpdateComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onUpdateComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.removeDevtool">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>removeDevtool
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDebugTool.removeHook">
            function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>removeHook
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDefaultBatchingStrategy">module react-dom.ReactDefaultBatchingStrategy</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactDefaultBatchingStrategy.</span>isBatchingUpdates</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDefaultBatchingStrategy.batchedUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactDefaultBatchingStrategy.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactDefaultInjection">module react-dom.ReactDefaultInjection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactDefaultInjection.inject">
            function <span class="apidocSignatureSpan">react-dom.ReactDefaultInjection.</span>inject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactEmptyComponent">module react-dom.ReactEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEmptyComponent.create">
            function <span class="apidocSignatureSpan">react-dom.ReactEmptyComponent.</span>create
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactEmptyComponent.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactErrorUtils">module react-dom.ReactErrorUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallback">
            function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>invokeGuardedCallback
            <span class="apidocSignatureSpan">(name, func, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallbackWithCatch">
            function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>invokeGuardedCallbackWithCatch
            <span class="apidocSignatureSpan">(name, func, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactErrorUtils.rethrowCaughtError">
            function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>rethrowCaughtError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactEventEmitterMixin">module react-dom.ReactEventEmitterMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventEmitterMixin.handleTopLevel">
            function <span class="apidocSignatureSpan">react-dom.ReactEventEmitterMixin.</span>handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactEventListener">module react-dom.ReactEventListener</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>_enabled</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener._handleTopLevel">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>_handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.dispatchEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>dispatchEvent
            <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.isEnabled">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>isEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.monitorScrollValue">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>monitorScrollValue
            <span class="apidocSignatureSpan">(refresh)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.setEnabled">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>setEnabled
            <span class="apidocSignatureSpan">(enabled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.setHandleTopLevel">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>setHandleTopLevel
            <span class="apidocSignatureSpan">(handleTopLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.trapBubbledEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>trapBubbledEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactEventListener.trapCapturedEvent">
            function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>trapCapturedEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>WINDOW_HANDLE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactFiber">module react-dom.ReactFiber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.cloneFiber">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>cloneFiber
            <span class="apidocSignatureSpan">(fiber, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.createFiberFromCoroutine">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromCoroutine
            <span class="apidocSignatureSpan">(coroutine, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.createFiberFromElement">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromElement
            <span class="apidocSignatureSpan">(element, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.createFiberFromElementType">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromElementType
            <span class="apidocSignatureSpan">(type, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.createFiberFromYield">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromYield
            <span class="apidocSignatureSpan">(yieldNode, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiber.createHostContainerFiber">
            function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createHostContainerFiber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactFiberRoot">module react-dom.ReactFiberRoot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberRoot.createFiberRoot">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberRoot.</span>createFiberRoot
            <span class="apidocSignatureSpan">(containerInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactFiberUpdateQueue">module react-dom.ReactFiberUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberUpdateQueue.addCallbackToQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>addCallbackToQueue
            <span class="apidocSignatureSpan">(queue, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberUpdateQueue.addToQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>addToQueue
            <span class="apidocSignatureSpan">(queue, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberUpdateQueue.callCallbacks">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>callCallbacks
            <span class="apidocSignatureSpan">(queue, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberUpdateQueue.createUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>createUpdateQueue
            <span class="apidocSignatureSpan">(partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactFiberUpdateQueue.mergeUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>mergeUpdateQueue
            <span class="apidocSignatureSpan">(queue, prevState, props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactHostComponent">module react-dom.ReactHostComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostComponent.createInstanceForText">
            function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>createInstanceForText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostComponent.createInternalComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>createInternalComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostComponent.isTextComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>isTextComponent
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactHostOperationHistoryHook">module react-dom.ReactHostOperationHistoryHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.clearHistory">
            function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>clearHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.getHistory">
            function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>getHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.onHostOperation">
            function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>onHostOperation
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactInputSelection">module react-dom.ReactInputSelection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInputSelection.getSelection">
            function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>getSelection
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInputSelection.getSelectionInformation">
            function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>getSelectionInformation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInputSelection.hasSelectionCapabilities">
            function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>hasSelectionCapabilities
            <span class="apidocSignatureSpan">(elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInputSelection.restoreSelection">
            function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>restoreSelection
            <span class="apidocSignatureSpan">(priorSelectionInformation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInputSelection.setSelection">
            function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>setSelection
            <span class="apidocSignatureSpan">(input, offsets)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactInstanceMap">module react-dom.ReactInstanceMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInstanceMap.get">
            function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInstanceMap.has">
            function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInstanceMap.remove">
            function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>remove
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInstanceMap.set">
            function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>set
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactInvalidSetStateWarningHook">module react-dom.ReactInvalidSetStateWarningHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext">
            function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onBeginProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onEndProcessingChildContext">
            function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onEndProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onSetState">
            function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onSetState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactMarkupChecksum">module react-dom.ReactMarkupChecksum</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMarkupChecksum.addChecksumToMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactMarkupChecksum.</span>addChecksumToMarkup
            <span class="apidocSignatureSpan">(markup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMarkupChecksum.canReuseMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactMarkupChecksum.</span>canReuseMarkup
            <span class="apidocSignatureSpan">(markup, element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-dom.ReactMarkupChecksum.</span>CHECKSUM_ATTR_NAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactMount">module react-dom.ReactMount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount.TopLevelWrapper">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>TopLevelWrapper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount._mountImageIntoNode">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_mountImageIntoNode
            <span class="apidocSignatureSpan">(markup, container, instance, shouldReuseMarkup, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount._renderNewRootComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_renderNewRootComponent
            <span class="apidocSignatureSpan">(nextElement, container, shouldReuseMarkup, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount._renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount._updateRootComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_updateRootComponent
            <span class="apidocSignatureSpan">(prevComponent, nextElement, nextContext, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount.render">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>render
            <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount.renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount.scrollMonitor">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>scrollMonitor
            <span class="apidocSignatureSpan">(container, renderCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactMount.unmountComponentAtNode">
            function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>unmountComponentAtNode
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_instancesByReactRootID</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactNodeTypes">module react-dom.ReactNodeTypes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactNodeTypes.getType">
            function <span class="apidocSignatureSpan">react-dom.ReactNodeTypes.</span>getType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactNodeTypes.</span>COMPOSITE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactNodeTypes.</span>EMPTY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactNodeTypes.</span>HOST</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactOwner">module react-dom.ReactOwner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactOwner.addComponentAsRefTo">
            function <span class="apidocSignatureSpan">react-dom.ReactOwner.</span>addComponentAsRefTo
            <span class="apidocSignatureSpan">(component, ref, owner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactOwner.removeComponentAsRefFrom">
            function <span class="apidocSignatureSpan">react-dom.ReactOwner.</span>removeComponentAsRefFrom
            <span class="apidocSignatureSpan">(component, ref, owner)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactPerf">module react-dom.ReactPerf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getExclusive">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getExclusive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getInclusive">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getInclusive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getLastMeasurements">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getLastMeasurements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getMeasurementsSummaryMap">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getMeasurementsSummaryMap
            <span class="apidocSignatureSpan">(measurements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getOperations">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getOperations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.getWasted">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getWasted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.isRunning">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>isRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.printDOM">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printDOM
            <span class="apidocSignatureSpan">(measurements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.printExclusive">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printExclusive
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.printInclusive">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printInclusive
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.printOperations">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printOperations
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.printWasted">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printWasted
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.start">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactPerf.stop">
            function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactReconcileTransaction">module react-dom.ReactReconcileTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(useCreateElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.release">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactReconcileTransaction.prototype">module react-dom.ReactReconcileTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">(checkpoint)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactReconciler">module react-dom.ReactReconciler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconciler.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>getHostNode
            <span class="apidocSignatureSpan">(internalInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconciler.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>mountComponent
            <span class="apidocSignatureSpan">(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconciler.performUpdateIfNecessary">
            function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>performUpdateIfNecessary
            <span class="apidocSignatureSpan">(internalInstance, transaction, updateBatchNumber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconciler.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>receiveComponent
            <span class="apidocSignatureSpan">(internalInstance, nextElement, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReconciler.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>unmountComponent
            <span class="apidocSignatureSpan">(internalInstance, safely)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactRef">module react-dom.ReactRef</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactRef.attachRefs">
            function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>attachRefs
            <span class="apidocSignatureSpan">(instance, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactRef.detachRefs">
            function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>detachRefs
            <span class="apidocSignatureSpan">(instance, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactRef.shouldUpdateRefs">
            function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>shouldUpdateRefs
            <span class="apidocSignatureSpan">(prevElement, nextElement)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactReifiedYield">module react-dom.ReactReifiedYield</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReifiedYield.createReifiedYield">
            function <span class="apidocSignatureSpan">react-dom.ReactReifiedYield.</span>createReifiedYield
            <span class="apidocSignatureSpan">(yieldNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactReifiedYield.createUpdatedReifiedYield">
            function <span class="apidocSignatureSpan">react-dom.ReactReifiedYield.</span>createUpdatedReifiedYield
            <span class="apidocSignatureSpan">(previousYield, yieldNode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerBatchingStrategy">module react-dom.ReactServerBatchingStrategy</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactServerBatchingStrategy.</span>isBatchingUpdates</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerBatchingStrategy.batchedUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactServerBatchingStrategy.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerRendering">module react-dom.ReactServerRendering</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRendering.renderToStaticMarkup">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRendering.</span>renderToStaticMarkup
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRendering.renderToString">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRendering.</span>renderToString
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerRenderingTransaction">module react-dom.ReactServerRenderingTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.ReactServerRenderingTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactServerRenderingTransaction
            <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.release">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerRenderingTransaction.prototype">module react-dom.ReactServerRenderingTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerUpdateQueue">module react-dom.ReactServerUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.ReactServerUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactServerUpdateQueue
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactServerUpdateQueue.prototype">module react-dom.ReactServerUpdateQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueCallback">
            function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueCallback
            <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueForceUpdate">
            function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueForceUpdate
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueReplaceState">
            function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueReplaceState
            <span class="apidocSignatureSpan">(publicInstance, completeState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueSetState">
            function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueSetState
            <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.isMounted">
            function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>isMounted
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactShallowRenderer">module react-dom.ReactShallowRenderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.ReactShallowRenderer">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactShallowRenderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.createRenderer">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.</span>createRenderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactShallowRenderer.prototype">module react-dom.ReactShallowRenderer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.prototype._render">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>_render
            <span class="apidocSignatureSpan">(element, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.getMountedInstance">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>getMountedInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.getRenderOutput">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>getRenderOutput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.render">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>render
            <span class="apidocSignatureSpan">(element, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.unmount">
            function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>unmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactSimpleEmptyComponent">module react-dom.ReactSimpleEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactSimpleEmptyComponent
            <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactSimpleEmptyComponent.prototype">module react-dom.ReactSimpleEmptyComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactTestReconcileTransaction">module react-dom.ReactTestReconcileTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.ReactTestReconcileTransaction">
            function <span class="apidocSignatureSpan">react-dom.</span>ReactTestReconcileTransaction
            <span class="apidocSignatureSpan">(testOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.release">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactTestReconcileTransaction.prototype">module react-dom.ReactTestReconcileTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTestOptions">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getTestOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">(checkpoint)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactTestUtils">module react-dom.ReactTestUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.createRenderer">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>createRenderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.findAllInRenderedTree">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findAllInRenderedTree
            <span class="apidocSignatureSpan">(inst, test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.findRenderedComponentWithType">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedComponentWithType
            <span class="apidocSignatureSpan">(root, componentType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithClass">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedDOMComponentWithClass
            <span class="apidocSignatureSpan">(root, className)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithTag">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedDOMComponentWithTag
            <span class="apidocSignatureSpan">(root, tagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.getRenderedChildOfCompositeComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>getRenderedChildOfCompositeComponent
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponent
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElement">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentElement
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElementWithType">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentElementWithType
            <span class="apidocSignatureSpan">(inst, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentWithType">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentWithType
            <span class="apidocSignatureSpan">(inst, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isDOMComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isDOMComponent
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isDOMComponentElement">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isDOMComponentElement
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isElement">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.isElementOfType">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isElementOfType
            <span class="apidocSignatureSpan">(inst, convenienceConstructor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.mockComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>mockComponent
            <span class="apidocSignatureSpan">(module, mockTagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.nativeTouchData">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>nativeTouchData
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.renderIntoDocument">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>renderIntoDocument
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedComponentsWithType">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedComponentsWithType
            <span class="apidocSignatureSpan">(root, componentType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithClass">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedDOMComponentsWithClass
            <span class="apidocSignatureSpan">(root, classNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithTag">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedDOMComponentsWithTag
            <span class="apidocSignatureSpan">(root, tagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnDOMComponent">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>simulateNativeEventOnDOMComponent
            <span class="apidocSignatureSpan">(topLevelType, comp, fakeNativeEvent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnNode">
            function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>simulateNativeEventOnNode
            <span class="apidocSignatureSpan">(topLevelType, node, fakeNativeEvent)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>Simulate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>SimulateNative</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactUpdateQueue">module react-dom.ReactUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueCallback">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueCallback
            <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueCallbackInternal">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueCallbackInternal
            <span class="apidocSignatureSpan">(internalInstance, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueElementInternal">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueElementInternal
            <span class="apidocSignatureSpan">(internalInstance, nextElement, nextContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueForceUpdate">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueForceUpdate
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueReplaceState">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueReplaceState
            <span class="apidocSignatureSpan">(publicInstance, completeState, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueSetState">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueSetState
            <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.isMounted">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>isMounted
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdateQueue.validateCallback">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>validateCallback
            <span class="apidocSignatureSpan">(callback, callerName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ReactUpdates">module react-dom.ReactUpdates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdates.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(useCreateElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdates.asap">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>asap
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdates.batchedUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdates.enqueueUpdate">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>enqueueUpdate
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ReactUpdates.flushBatchedUpdates">
            function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>flushBatchedUpdates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ResponderEventPlugin">module react-dom.ResponderEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderEventPlugin._getResponderID">
            function <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>_getResponderID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>GlobalInteractionHandler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>GlobalResponderHandler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>eventTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ResponderSyntheticEvent">module react-dom.ResponderSyntheticEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent.ResponderSyntheticEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>ResponderSyntheticEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent.release">
            function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ResponderSyntheticEvent.prototype">module react-dom.ResponderSyntheticEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderSyntheticEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ResponderTouchHistoryStore">module react-dom.ResponderTouchHistoryStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ResponderTouchHistoryStore.recordTouchTrack">
            function <span class="apidocSignatureSpan">react-dom.ResponderTouchHistoryStore.</span>recordTouchTrack
            <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.ResponderTouchHistoryStore.</span>touchHistory</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SelectEventPlugin">module react-dom.SelectEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SelectEventPlugin.didPutListener">
            function <span class="apidocSignatureSpan">react-dom.SelectEventPlugin.</span>didPutListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SelectEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.SelectEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SelectEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SimpleEventPlugin">module react-dom.SimpleEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SimpleEventPlugin.didPutListener">
            function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>didPutListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SimpleEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SimpleEventPlugin.willDeleteListener">
            function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>willDeleteListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticAnimationEvent">module react-dom.SyntheticAnimationEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent.SyntheticAnimationEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticAnimationEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticAnimationEvent.prototype">module react-dom.SyntheticAnimationEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticAnimationEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticClipboardEvent">module react-dom.SyntheticClipboardEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent.SyntheticClipboardEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticClipboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticClipboardEvent.prototype">module react-dom.SyntheticClipboardEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticClipboardEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticCompositionEvent">module react-dom.SyntheticCompositionEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent.SyntheticCompositionEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticCompositionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticCompositionEvent.prototype">module react-dom.SyntheticCompositionEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticCompositionEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticDragEvent">module react-dom.SyntheticDragEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent.SyntheticDragEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticDragEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticDragEvent.prototype">module react-dom.SyntheticDragEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticDragEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticEvent">module react-dom.SyntheticEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.SyntheticEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticEvent
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticEvent.prototype">module react-dom.SyntheticEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.prototype.destructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.prototype.isPersistent">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>isPersistent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.prototype.persist">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>persist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.prototype.preventDefault">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>preventDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticEvent.prototype.stopPropagation">
            function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>stopPropagation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticFocusEvent">module react-dom.SyntheticFocusEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent.SyntheticFocusEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticFocusEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticFocusEvent.prototype">module react-dom.SyntheticFocusEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticFocusEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticInputEvent">module react-dom.SyntheticInputEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent.SyntheticInputEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticInputEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticInputEvent.prototype">module react-dom.SyntheticInputEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticInputEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticKeyboardEvent">module react-dom.SyntheticKeyboardEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent.SyntheticKeyboardEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticKeyboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticKeyboardEvent.prototype">module react-dom.SyntheticKeyboardEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticKeyboardEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticMouseEvent">module react-dom.SyntheticMouseEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent.SyntheticMouseEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticMouseEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticMouseEvent.prototype">module react-dom.SyntheticMouseEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticMouseEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticTouchEvent">module react-dom.SyntheticTouchEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent.SyntheticTouchEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTouchEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticTouchEvent.prototype">module react-dom.SyntheticTouchEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTouchEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticTransitionEvent">module react-dom.SyntheticTransitionEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent.SyntheticTransitionEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTransitionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticTransitionEvent.prototype">module react-dom.SyntheticTransitionEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticTransitionEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticUIEvent">module react-dom.SyntheticUIEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent.SyntheticUIEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticUIEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticUIEvent.prototype">module react-dom.SyntheticUIEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticUIEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticWheelEvent">module react-dom.SyntheticWheelEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent.SyntheticWheelEvent">
            function <span class="apidocSignatureSpan">react-dom.</span>SyntheticWheelEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent.getPooled">
            function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent.release">
            function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.SyntheticWheelEvent.prototype">module react-dom.SyntheticWheelEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.SyntheticWheelEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.TapEventPlugin">module react-dom.TapEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TapEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-dom.TapEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.TapEventPlugin.</span>tapMoveThreshold</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.TapEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.TouchHistoryMath">module react-dom.TouchHistoryMath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.centroidDimension">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>centroidDimension
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter, isXAxis, ofCurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidX">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidX
            <span class="apidocSignatureSpan">(touchHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidXOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidY">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidY
            <span class="apidocSignatureSpan">(touchHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidYOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>previousCentroidXOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>previousCentroidYOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>noCentroid</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.Transaction">module react-dom.Transaction</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-dom.Transaction.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Transaction.closeAll">
            function <span class="apidocSignatureSpan">react-dom.Transaction.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Transaction.initializeAll">
            function <span class="apidocSignatureSpan">react-dom.Transaction.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Transaction.isInTransaction">
            function <span class="apidocSignatureSpan">react-dom.Transaction.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Transaction.perform">
            function <span class="apidocSignatureSpan">react-dom.Transaction.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.Transaction.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-dom.Transaction.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-dom.Transaction.</span>getTransactionWrappers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.ViewportMetrics">module react-dom.ViewportMetrics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.ViewportMetrics.refreshScrollValues">
            function <span class="apidocSignatureSpan">react-dom.ViewportMetrics.</span>refreshScrollValues
            <span class="apidocSignatureSpan">(scrollPosition)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ViewportMetrics.</span>currentScrollLeft</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-dom.ViewportMetrics.</span>currentScrollTop</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-dom.validateDOMNesting">module react-dom.validateDOMNesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.validateDOMNesting.validateDOMNesting">
            function <span class="apidocSignatureSpan">react-dom.</span>validateDOMNesting
            <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.validateDOMNesting.isTagValidInContext">
            function <span class="apidocSignatureSpan">react-dom.validateDOMNesting.</span>isTagValidInContext
            <span class="apidocSignatureSpan">(tag, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-dom.validateDOMNesting.updatedAncestorInfo">
            function <span class="apidocSignatureSpan">react-dom.validateDOMNesting.</span>updatedAncestorInfo
            <span class="apidocSignatureSpan">(oldInfo, tag, instance)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom" id="apidoc.module.react-dom">module react-dom</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue" id="apidoc.element.react-dom.CallbackQueue">
        function <span class="apidocSignatureSpan">react-dom.</span>CallbackQueue
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackQueue(arg) {
  _classCallCheck(this, CallbackQueue);

  this._callbacks = null;
  this._contexts = null;
  this._arg = arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree" id="apidoc.element.react-dom.DOMLazyTree">
        function <span class="apidocSignatureSpan">react-dom.</span>DOMLazyTree
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState" id="apidoc.element.react-dom.FallbackCompositionState">
        function <span class="apidocSignatureSpan">react-dom.</span>FallbackCompositionState
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent" id="apidoc.element.react-dom.ReactDOMComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent" id="apidoc.element.react-dom.ReactDOMEmptyComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMEmptyComponent
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent" id="apidoc.element.react-dom.ReactDOMTextComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextComponent
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction" id="apidoc.element.react-dom.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(useCreateElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction" id="apidoc.element.react-dom.ReactServerRenderingTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactServerRenderingTransaction
        <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue" id="apidoc.element.react-dom.ReactServerUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactServerUpdateQueue
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerUpdateQueue(transaction) {
  _classCallCheck(this, ReactServerUpdateQueue);

  this.transaction = transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer" id="apidoc.element.react-dom.ReactShallowRenderer">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactShallowRenderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);

  this._instance = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent" id="apidoc.element.react-dom.ReactSimpleEmptyComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactSimpleEmptyComponent
        <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactSimpleEmptyComponent = function (placeholderElement, instantiate) {
  this._currentElement = null;
  this._renderedComponent = instantiate(placeholderElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction" id="apidoc.element.react-dom.ReactTestReconcileTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactTestReconcileTransaction
        <span class="apidocSignatureSpan">(testOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestReconcileTransaction(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue.getPooled(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent" id="apidoc.element.react-dom.ResponderSyntheticEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>ResponderSyntheticEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent" id="apidoc.element.react-dom.SyntheticAnimationEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticAnimationEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent" id="apidoc.element.react-dom.SyntheticClipboardEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticClipboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent" id="apidoc.element.react-dom.SyntheticCompositionEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticCompositionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent" id="apidoc.element.react-dom.SyntheticDragEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticDragEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent" id="apidoc.element.react-dom.SyntheticEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticEvent
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent" id="apidoc.element.react-dom.SyntheticFocusEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticFocusEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent" id="apidoc.element.react-dom.SyntheticInputEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticInputEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent" id="apidoc.element.react-dom.SyntheticKeyboardEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticKeyboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent" id="apidoc.element.react-dom.SyntheticMouseEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticMouseEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent" id="apidoc.element.react-dom.SyntheticTouchEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTouchEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent" id="apidoc.element.react-dom.SyntheticTransitionEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTransitionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent" id="apidoc.element.react-dom.SyntheticUIEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticUIEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent" id="apidoc.element.react-dom.SyntheticWheelEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticWheelEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.findDOMNode" id="apidoc.element.react-dom.findDOMNode">
        function <span class="apidocSignatureSpan">react-dom.</span>findDOMNode
        <span class="apidocSignatureSpan">(componentOrElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render
(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from
 the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName
() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant
('44') : void 0;
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (
keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.render" id="apidoc.element.react-dom.render">
        function <span class="apidocSignatureSpan">react-dom.</span>render
        <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (nextElement, container, callback) {
  return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello World&lt;/div&gt;;
  }
}

ReactDOM.<span class="apidocCodeKeywordSpan">render</span>(&lt;MyComponent /&gt;, node);
```

### On the server

```js
var React = require('react');
var ReactDOMServer = require('react-dom/server');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.unmountComponentAtNode" id="apidoc.element.react-dom.unmountComponentAtNode">
        function <span class="apidocSignatureSpan">react-dom.</span>unmountComponentAtNode
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponentAtNode = function (container) {
  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (Strictly speaking, unmounting won't cause a
  // render but we still don't expect to be in a render call here.)
  process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should
 be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary,
trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current &amp;&amp; ReactCurrentOwner
.current.getName() || 'ReactCompositeComponent') : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container
 is not a DOM element.') : _prodInvariant('40') : void 0;

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node
 you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);
  if (!prevComponent) {
    // Check if the node being unmounted was rendered by React, but isn't a
    // root node.
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    // Check if the container itself is a React root node.
    var isContainerReactRoot = container.nodeType === 1 &amp;&amp; container.hasAttribute(ROOT_ATTR_NAME);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re
 attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally
 passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender
 in order to remove this component.') : void 0;
    }

    return false;
  }
  delete instancesByReactRootID[prevComponent._instance.rootID];
  ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &amp;&amp; function () {
      callback.call(publicInst);
    };
    ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
    return publicInst;
  } else {
    ReactMount.<span class="apidocCodeKeywordSpan">unmountComponentAtNode</span>(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement);
var containerHasNonRootReactChild = hasNonRootReactChild(container);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.unstable_batchedUpdates" id="apidoc.element.react-dom.unstable_batchedUpdates">
        function <span class="apidocSignatureSpan">react-dom.</span>unstable_batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.unstable_renderSubtreeIntoContainer" id="apidoc.element.react-dom.unstable_renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-dom.</span>unstable_renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unstable_renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '
parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.validateDOMNesting" id="apidoc.element.react-dom.validateDOMNesting">
        function <span class="apidocSignatureSpan">react-dom.</span>validateDOMNesting
        <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &amp;&amp; parentInfo.tag;

  if (childText != null) {
    process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should
 be null') : void 0;
    childTag = '#text';
  }

  var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
  var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
  var problematic = invalidParent || invalidAncestor;

  if (problematic) {
    var ancestorTag = problematic.tag;
    var ancestorInstance = problematic.instance;

    var childOwner = childInstance &amp;&amp; childInstance._currentElement._owner;
    var ancestorOwner = ancestorInstance &amp;&amp; ancestorInstance._currentElement._owner;

    var childOwners = findOwnerStack(childOwner);
    var ancestorOwners = findOwnerStack(ancestorOwner);

    var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
    var i;

    var deepestCommon = -1;
    for (i = 0; i &lt; minStackLen; i++) {
      if (childOwners[i] === ancestorOwners[i]) {
        deepestCommon = i;
      } else {
        break;
      }
    }

    var UNKNOWN = '(unknown)';
    var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ownerInfo = [].concat(
    // If the parent and child instances have a common owner ancestor, start
    // with that -- otherwise we just start with the parent's owners.
    deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
    // If we're warning about an invalid (non-parent) ancestry, add '...'
    invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' &gt; ');

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '&lt;' + childTag + '&gt;';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' &amp;&amp; childTag === 'tr') {
        info += ' Add a &lt;tbody&gt; to your code to match the DOM tree generated by ' + 'the browser.';
      }
      process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of &lt;%s&gt;.%s ' + '
See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '&lt;%
s&gt;. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.AutoFocusUtils" id="apidoc.module.react-dom.AutoFocusUtils">module react-dom.AutoFocusUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.AutoFocusUtils.focusDOMComponent" id="apidoc.element.react-dom.AutoFocusUtils.focusDOMComponent">
        function <span class="apidocSignatureSpan">react-dom.AutoFocusUtils.</span>focusDOMComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">focusDOMComponent = function () {
  focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.BeforeInputEventPlugin" id="apidoc.module.react-dom.BeforeInputEventPlugin">module react-dom.BeforeInputEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.BeforeInputEventPlugin.extractEvents" id="apidoc.element.react-dom.BeforeInputEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.BeforeInputEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType
, targetInst, nativeEvent, nativeEventTarget)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.CSSPropertyOperations" id="apidoc.module.react-dom.CSSPropertyOperations">module react-dom.CSSPropertyOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.CSSPropertyOperations.createMarkupForStyles" id="apidoc.element.react-dom.CSSPropertyOperations.createMarkupForStyles">
        function <span class="apidocSignatureSpan">react-dom.CSSPropertyOperations.</span>createMarkupForStyles
        <span class="apidocSignatureSpan">(styles, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForStyles = function (styles, component) {
  var serialized = '';
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var styleValue = styles[styleName];
    if (process.env.NODE_ENV !== 'production') {
      warnValidStyle(styleName, styleValue, component);
    }
    if (styleValue != null) {
      serialized += processStyleName(styleName) + ':';
      serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
    }
  }
  return serialized || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (propValue) {
    if (process.env.NODE_ENV !== 'production') {
      // See `_updateDOMProperties`. style block
      this._previousStyle = propValue;
    }
    propValue = this._previousStyleCopy = _assign({}, props.style);
  }
  propValue = CSSPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForStyles</span>(propValue, this);
}
var markup = null;
if (this._tag != null &amp;&amp; isCustomComponent(this._tag, props)) {
  if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
    markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
  }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CSSPropertyOperations.setValueForStyles" id="apidoc.element.react-dom.CSSPropertyOperations.setValueForStyles">
        function <span class="apidocSignatureSpan">react-dom.CSSPropertyOperations.</span>setValueForStyles
        <span class="apidocSignatureSpan">(node, styles, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForStyles = function (node, styles, component) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: component._debugID,
      type: 'update styles',
      payload: styles
    });
  }

  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      warnValidStyle(styleName, styles[styleName], component);
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
    if (styleName === 'float' || styleName === 'cssFloat') {
      styleName = styleFloatAccessor;
    }
    if (styleValue) {
      style[styleName] = styleValue;
    } else {
      var expansion = hasShorthandPropertyBug &amp;&amp; CSSProperty.shorthandPropertyExpansions[styleName];
      if (expansion) {
        // Shorthand property that IE8 won't like unsetting, so unset each
        // component to placate it
        for (var individualStyleName in expansion) {
          style[individualStyleName] = '';
        }
      } else {
        style[styleName] = '';
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
  }
  if (styleUpdates) {
    CSSPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForStyles</span>(getNode(this), styleUpdates, this);
  }
},

/**
 * Reconciles the children with the various properties that affect the
 * children content.
 *
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.CallbackQueue" id="apidoc.module.react-dom.CallbackQueue">module react-dom.CallbackQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.CallbackQueue" id="apidoc.element.react-dom.CallbackQueue.CallbackQueue">
        function <span class="apidocSignatureSpan">react-dom.</span>CallbackQueue
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackQueue(arg) {
  _classCallCheck(this, CallbackQueue);

  this._callbacks = null;
  this._contexts = null;
  this._arg = arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.getPooled" id="apidoc.element.react-dom.CallbackQueue.getPooled">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.release" id="apidoc.element.react-dom.CallbackQueue.release">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.CallbackQueue.prototype" id="apidoc.module.react-dom.CallbackQueue.prototype">module react-dom.CallbackQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.checkpoint" id="apidoc.element.react-dom.CallbackQueue.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkpoint() {
  return this._callbacks ? this._callbacks.length : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.destructor" id="apidoc.element.react-dom.CallbackQueue.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destructor() {
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.enqueue" id="apidoc.element.react-dom.CallbackQueue.prototype.enqueue">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueue(callback, context) {
  this._callbacks = this._callbacks || [];
  this._callbacks.push(callback);
  this._contexts = this._contexts || [];
  this._contexts.push(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.getReactMountReady().<span class="apidocCodeKeywordSpan">enqueue</span>(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, 'componentDidMount');
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.notifyAll" id="apidoc.element.react-dom.CallbackQueue.prototype.notifyAll">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>notifyAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notifyAll() {
  var callbacks = this._callbacks;
  var contexts = this._contexts;
  var arg = this._arg;
  if (callbacks &amp;&amp; contexts) {
    !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts
 in callback queue') : _prodInvariant('24') : void 0;
    this._callbacks = null;
    this._contexts = null;
    for (var i = 0; i &lt; callbacks.length; i++) {
      callbacks[i].call(contexts[i], arg);
    }
    callbacks.length = 0;
    contexts.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.reactMountReady.reset();
 },

 /**
  * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
  */
 close: function () {
   this.reactMountReady.<span class="apidocCodeKeywordSpan">notifyAll</span>();
 }
};

/**
* Executed within the scope of the `Transaction` instance. Consider these as
* being member methods, but with an implied ordering while being isolated from
* each other.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.reset" id="apidoc.element.react-dom.CallbackQueue.prototype.reset">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  this._callbacks = null;
  this._contexts = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.<span class="apidocCodeKeywordSpan">reset</span>();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.CallbackQueue.prototype.rollback" id="apidoc.element.react-dom.CallbackQueue.prototype.rollback">
        function <span class="apidocSignatureSpan">react-dom.CallbackQueue.prototype.</span>rollback
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rollback(len) {
  if (this._callbacks &amp;&amp; this._contexts) {
    this._callbacks.length = len;
    this._contexts.length = len;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ChangeEventPlugin" id="apidoc.module.react-dom.ChangeEventPlugin">module react-dom.ChangeEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ChangeEventPlugin.extractEvents" id="apidoc.element.react-dom.ChangeEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.ChangeEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

  var getTargetInstFunc, handleEventFunc;
  if (shouldUseChangeEvent(targetNode)) {
    if (doesChangeEventBubble) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else {
      handleEventFunc = handleEventsForChangeEventIE8;
    }
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventIE;
      handleEventFunc = handleEventsForInputEventIE;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(topLevelType, targetInst);
    if (inst) {
      var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
      event.type = 'change';
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(topLevelType, targetNode, targetInst);
  }

  // When blurring, set the value attribute for number inputs
  if (topLevelType === 'topBlur') {
    handleControlledInputBlur(targetInst, targetNode);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.DOMChildrenOperations" id="apidoc.module.react-dom.DOMChildrenOperations">module react-dom.DOMChildrenOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup" id="apidoc.element.react-dom.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>dangerouslyReplaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: 'replace with',
      payload: markup.toString()
    });
  } else {
    var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
    if (nextInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: nextInstance._debugID,
        type: 'mount',
        payload: markup.toString()
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.<span class="apidocCodeKeywordSpan">dangerouslyReplaceNodeWithMarkup</span>(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: 'replace with',
      payload: markup.toString()
    });
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMChildrenOperations.processUpdates" id="apidoc.element.react-dom.DOMChildrenOperations.processUpdates">
        function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>processUpdates
        <span class="apidocSignatureSpan">(parentNode, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processUpdates = function (parentNode, updates) {
  if (process.env.NODE_ENV !== 'production') {
    var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
  }

  for (var k = 0; k &lt; updates.length; k++) {
    var update = updates[k];
    switch (update.type) {
      case 'INSERT_MARKUP':
        insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: 'insert child',
            payload: { toIndex: update.toIndex, content: update.content.toString() }
          });
        }
        break;
      case 'MOVE_EXISTING':
        moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: 'move child',
            payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
          });
        }
        break;
      case 'SET_MARKUP':
        setInnerHTML(parentNode, update.content);
        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: 'replace children',
            payload: update.content.toString()
          });
        }
        break;
      case 'TEXT_CONTENT':
        setTextContent(parentNode, update.content);
        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: 'replace text',
            payload: update.content.toString()
          });
        }
        break;
      case 'REMOVE_NODE':
        removeChild(parentNode, update.fromNode);
        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: 'remove child',
            payload: { fromIndex: update.fromIndex }
          });
        }
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Updates a component's children by processing a series of updates.
   *
   * @param {array&lt;object&gt;} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.<span class="apidocCodeKeywordSpan">processUpdates</span>(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMChildrenOperations.replaceDelimitedText" id="apidoc.element.react-dom.DOMChildrenOperations.replaceDelimitedText">
        function <span class="apidocSignatureSpan">react-dom.DOMChildrenOperations.</span>replaceDelimitedText
        <span class="apidocSignatureSpan">(openingComment, closingComment, stringText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var nextStringText = '' + nextText;
    if (nextStringText !== this._stringText) {
      // TODO: Save this as pending props and use performUpdateIfNecessary
      // and/or updateComponent to do the actual update for consistency with
      // other component types?
      this._stringText = nextStringText;
      var commentNodes = this.getHostNode();
      DOMChildrenOperations.<span class="apidocCodeKeywordSpan">replaceDelimitedText</span>(commentNodes[0], commentNodes[1], nextStringText
);
    }
  }
},

getHostNode: function () {
  var hostNode = this._commentNodes;
  if (hostNode) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.DOMLazyTree" id="apidoc.module.react-dom.DOMLazyTree">module react-dom.DOMLazyTree</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.DOMLazyTree" id="apidoc.element.react-dom.DOMLazyTree.DOMLazyTree">
        function <span class="apidocSignatureSpan">react-dom.</span>DOMLazyTree
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.insertTreeBefore" id="apidoc.element.react-dom.DOMLazyTree.insertTreeBefore">
        function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>insertTreeBefore
        <span class="apidocSignatureSpan">(parentNode, tree, referenceNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertTreeBefore = function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some &lt;object&gt; plugins (like Flash Player) will read
  // &lt;param&gt; nodes immediately upon insertion into the DOM, so &lt;object&gt;
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE &amp;&amp; tree.node.nodeName.toLowerCase
() === 'object' &amp;&amp; (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// We rely exclusively on `insertBefore(node, null)` instead of also using
// `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
// we are careful to use `null`.)
parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
DOMLazyTree.<span class="apidocCodeKeywordSpan">insertTreeBefore</span>(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
if (Array.isArray(childNode)) {
  moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
} else {
  insertChildAt(parentNode, childNode, referenceNode);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.queueChild" id="apidoc.element.react-dom.DOMLazyTree.queueChild">
        function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueChild
        <span class="apidocSignatureSpan">(parentTree, childTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          setAndValidateContentChildDev.call(this, contentToUse);
        }
        DOMLazyTree.queueText(lazyTree, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      for (var i = 0; i &lt; mountImages.length; i++) {
        DOMLazyTree.<span class="apidocCodeKeywordSpan">queueChild</span>(lazyTree, mountImages[i]);
      }
    }
  }
},

/**
 * Receives a next element and updates the component.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.queueHTML" id="apidoc.element.react-dom.DOMLazyTree.queueHTML">
        function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueHTML
        <span class="apidocSignatureSpan">(tree, html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

_createInitialChildren: function (transaction, props, context, lazyTree) {
  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      DOMLazyTree.<span class="apidocCodeKeywordSpan">queueHTML</span>(lazyTree, innerHTML.__html);
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    // TODO: Validate that text is allowed as a child of this node
    if (contentToUse != null) {
      // Avoid setting textContent when the text is empty. In IE11 setting
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.queueText" id="apidoc.element.react-dom.DOMLazyTree.queueText">
        function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>queueText
        <span class="apidocSignatureSpan">(tree, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // textContent on a text area will cause the placeholder to not
  // show within the textarea until it has been focused and blurred again.
  // https://github.com/facebook/react/issues/6731#issuecomment-254874553
  if (contentToUse !== '') {
    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, contentToUse);
    }
    DOMLazyTree.<span class="apidocCodeKeywordSpan">queueText</span>(lazyTree, contentToUse);
  }
} else if (childrenToUse != null) {
  var mountImages = this.mountChildren(childrenToUse, transaction, context);
  for (var i = 0; i &lt; mountImages.length; i++) {
    DOMLazyTree.queueChild(lazyTree, mountImages[i]);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMLazyTree.replaceChildWithTree" id="apidoc.element.react-dom.DOMLazyTree.replaceChildWithTree">
        function <span class="apidocSignatureSpan">react-dom.DOMLazyTree.</span>replaceChildWithTree
        <span class="apidocSignatureSpan">(oldNode, newTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing
 markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup
(...): Cannot replace markup of the &lt;html&gt; node. This is because browser quirks make this unreliable and/or slow. If you
 want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58
') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.<span class="apidocCodeKeywordSpan">replaceChildWithTree</span>(oldChild, markup);
    }
  }

};

module.exports = Danger;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.DOMProperty" id="apidoc.module.react-dom.DOMProperty">module react-dom.DOMProperty</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.DOMProperty.isCustomAttribute" id="apidoc.element.react-dom.DOMProperty.isCustomAttribute">
        function <span class="apidocSignatureSpan">react-dom.DOMProperty.</span>isCustomAttribute
        <span class="apidocSignatureSpan">(attributeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCustomAttribute = function (attributeName) {
  for (var i = 0; i &lt; DOMProperty._isCustomAttributeFunctions.length; i++) {
    var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
    if (isCustomAttributeFn(attributeName)) {
      return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return '';
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &amp;&amp; value === true) {
      return attributeName + '=""';
    }
    return attributeName + '=' + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.<span class="apidocCodeKeywordSpan">isCustomAttribute</span>(name)) {
    if (value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  }
  return null;
},
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.DOMPropertyOperations" id="apidoc.module.react-dom.DOMPropertyOperations">module react-dom.DOMPropertyOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForCustomAttribute" id="apidoc.element.react-dom.DOMPropertyOperations.createMarkupForCustomAttribute">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForCustomAttribute
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForCustomAttribute = function (name, value) {
  if (!isAttributeNameSafe(name) || value == null) {
    return '';
  }
  return name + '=' + quoteAttributeValueForBrowser(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    propValue = this._previousStyleCopy = _assign({}, props.style);
  }
  propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
}
var markup = null;
if (this._tag != null &amp;&amp; isCustomComponent(this._tag, props)) {
  if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
    markup = DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForCustomAttribute</span>(propKey, propValue);
  }
} else {
  markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
}
if (markup) {
  ret += ' ' + markup;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForID" id="apidoc.element.react-dom.DOMPropertyOperations.createMarkupForID">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForID = function (id) {
  return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
  }
  ret += ' ' + DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForID</span>(this._domID);
  return ret;
},

/**
 * Creates markup for the content between the tags.
 *
 * @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForProperty" id="apidoc.element.react-dom.DOMPropertyOperations.createMarkupForProperty">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForProperty
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForProperty = function (name, value) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    if (shouldIgnoreValue(propertyInfo, value)) {
      return '';
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &amp;&amp; value === true) {
      return attributeName + '=""';
    }
    return attributeName + '=' + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.isCustomAttribute(name)) {
    if (value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    var markup = null;
    if (this._tag != null &amp;&amp; isCustomComponent(this._tag, props)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
      }
    } else {
      markup = DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForProperty</span>(propKey, propValue);
    }
    if (markup) {
      ret += ' ' + markup;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.createMarkupForRoot" id="apidoc.element.react-dom.DOMPropertyOperations.createMarkupForRoot">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>createMarkupForRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForRoot = function () {
  return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += ' ' + DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForRoot</span>();
  }
  ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
  return ret;
},

/**
 * Creates markup for the content between the tags.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.deleteValueForAttribute" id="apidoc.element.react-dom.DOMPropertyOperations.deleteValueForAttribute">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>deleteValueForAttribute
        <span class="apidocSignatureSpan">(node, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteValueForAttribute = function (node, name) {
  node.removeAttribute(name);
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: 'remove attribute',
      payload: name
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // Only call deleteListener if there was a listener previously or
      // else willDeleteListener gets called when there wasn't actually a
      // listener (e.g., onClick={null})
      deleteListener(this, propKey);
    }
  } else if (isCustomComponent(this._tag, lastProps)) {
    if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
      DOMPropertyOperations.<span class="apidocCodeKeywordSpan">deleteValueForAttribute</span>(getNode(this), propKey);
    }
  } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
    DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
  }
}
for (propKey in nextProps) {
  var nextProp = nextProps[propKey];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.deleteValueForProperty" id="apidoc.element.react-dom.DOMPropertyOperations.deleteValueForProperty">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>deleteValueForProperty
        <span class="apidocSignatureSpan">(node, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteValueForProperty = function (node, name) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else if (DOMProperty.isCustomAttribute(name)) {
    node.removeAttribute(name);
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: 'remove attribute',
      payload: name
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setValueForProperty: function (node, name, value) {
var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
if (propertyInfo) {
  var mutationMethod = propertyInfo.mutationMethod;
  if (mutationMethod) {
    mutationMethod(node, value);
  } else if (shouldIgnoreValue(propertyInfo, value)) {
    this.<span class="apidocCodeKeywordSpan">deleteValueForProperty</span>(node, name);
    return;
  } else if (propertyInfo.mustUseProperty) {
    // Contrary to `setAttribute`, object properties are properly
    // `toString`ed by IE8/9.
    node[propertyInfo.propertyName] = value;
  } else {
    var attributeName = propertyInfo.attributeName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.setAttributeForID" id="apidoc.element.react-dom.DOMPropertyOperations.setAttributeForID">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setAttributeForID
        <span class="apidocSignatureSpan">(node, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAttributeForID = function (node, id) {
  node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.setAttributeForRoot" id="apidoc.element.react-dom.DOMPropertyOperations.setAttributeForRoot">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setAttributeForRoot
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAttributeForRoot = function (node) {
  node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  } else {
    el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
  }
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setAttributeForRoot</span>(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.setValueForAttribute" id="apidoc.element.react-dom.DOMPropertyOperations.setValueForAttribute">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setValueForAttribute
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForAttribute = function (node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  if (process.env.NODE_ENV !== 'production') {
    var payload = {};
    payload[name] = value;
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: 'update attribute',
      payload: payload
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &amp;&amp; value === true) {
      node.setAttribute(attributeName, '');
    } else {
      node.setAttribute(attributeName, '' + value);
    }
  }
} else if (DOMProperty.isCustomAttribute(name)) {
  DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForAttribute</span>(node, name, value);
  return;
}

if (process.env.NODE_ENV !== 'production') {
  var payload = {};
  payload[name] = value;
  ReactInstrumentation.debugTool.onHostOperation({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.DOMPropertyOperations.setValueForProperty" id="apidoc.element.react-dom.DOMPropertyOperations.setValueForProperty">
        function <span class="apidocSignatureSpan">react-dom.DOMPropertyOperations.</span>setValueForProperty
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForProperty = function (node, name, value) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      this.deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &amp;&amp; value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else if (DOMProperty.isCustomAttribute(name)) {
    DOMPropertyOperations.setValueForAttribute(node, name, value);
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    var payload = {};
    payload[name] = value;
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: 'update attribute',
      payload: payload
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
    var node = getNode(this);
    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertently setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (nextProp != null) {
      DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForProperty</span>(node, propKey, nextProp);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, propKey);
    }
  }
}
if (styleUpdates) {
  CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.Danger" id="apidoc.module.react-dom.Danger">module react-dom.Danger</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.Danger.dangerouslyReplaceNodeWithMarkup" id="apidoc.element.react-dom.Danger.dangerouslyReplaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-dom.Danger.</span>dangerouslyReplaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyReplaceNodeWithMarkup = function (oldChild, markup) {
  !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...):
Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit
 testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
  !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') :
_prodInvariant('57') : void 0;
  !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...):
Cannot replace markup of the &lt;html&gt; node. This is because browser quirks make this unreliable and/or slow. If you want to render
 to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

  if (typeof markup === 'string') {
    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  } else {
    DOMLazyTree.replaceChildWithTree(oldChild, markup);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.<span class="apidocCodeKeywordSpan">dangerouslyReplaceNodeWithMarkup</span>(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: 'replace with',
      payload: markup.toString()
    });
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.EnterLeaveEventPlugin" id="apidoc.module.react-dom.EnterLeaveEventPlugin">module react-dom.EnterLeaveEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.EnterLeaveEventPlugin.extractEvents" id="apidoc.element.react-dom.EnterLeaveEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.EnterLeaveEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (topLevelType === 'topMouseOver' &amp;&amp; (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
    return null;
  }
  if (topLevelType !== 'topMouseOut' &amp;&amp; topLevelType !== 'topMouseOver') {
    // Must not be a mouse in or mouse out - ignoring.
    return null;
  }

  var win;
  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;
    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;
  if (topLevelType === 'topMouseOut') {
    from = targetInst;
    var related = nativeEvent.relatedTarget || nativeEvent.toElement;
    to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return null;
  }

  var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
  var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

  var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
  leave.type = 'mouseleave';
  leave.target = fromNode;
  leave.relatedTarget = toNode;

  var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
  enter.type = 'mouseenter';
  enter.target = toNode;
  enter.relatedTarget = fromNode;

  EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

  return [leave, enter];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.EventPluginHub" id="apidoc.module.react-dom.EventPluginHub">module react-dom.EventPluginHub</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.__getListenerBank" id="apidoc.element.react-dom.EventPluginHub.__getListenerBank">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>__getListenerBank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__getListenerBank = function () {
  return listenerBank;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.__purge" id="apidoc.element.react-dom.EventPluginHub.__purge">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>__purge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__purge = function () {
  listenerBank = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.deleteAllListeners" id="apidoc.element.react-dom.EventPluginHub.deleteAllListeners">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>deleteAllListeners
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteAllListeners = function (inst) {
  var key = getDictionaryKey(inst);
  for (var registrationName in listenerBank) {
    if (!listenerBank.hasOwnProperty(registrationName)) {
      continue;
    }

    if (!listenerBank[registrationName][key]) {
      continue;
    }

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule &amp;&amp; PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    delete listenerBank[registrationName][key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;%s&gt; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &lt;html&gt;, &lt;head&gt;, and &lt;body
&gt;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.'
;, this._tag) : _prodInvariant('66', this._tag) : void 0;
    break;
}

this.unmountChildren(safely);
ReactDOMComponentTree.uncacheNode(this);
EventPluginHub.<span class="apidocCodeKeywordSpan">deleteAllListeners</span>(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev.call(this, null);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.deleteListener" id="apidoc.element.react-dom.EventPluginHub.deleteListener">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>deleteListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteListener = function (inst, registrationName) {
  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &amp;&amp; PluginModule.willDeleteListener) {
    PluginModule.willDeleteListener(inst, registrationName);
  }

  var bankForRegistrationName = listenerBank[registrationName];
  // TODO: This should never be null -- when is it?
  if (bankForRegistrationName) {
    var key = getDictionaryKey(inst);
    delete bankForRegistrationName[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.enqueueEvents" id="apidoc.element.react-dom.EventPluginHub.enqueueEvents">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>enqueueEvents
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueEvents = function (events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
EventPluginHub.<span class="apidocCodeKeywordSpan">enqueueEvents</span>(event);
EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
activeElement = target;
activeElementInst = targetInst;
activeElement.attachEvent('onchange', manualDispatchChangeEvent);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.extractEvents" id="apidoc.element.react-dom.EventPluginHub.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.getListener" id="apidoc.element.react-dom.EventPluginHub.getListener">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>getListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getListener = function (inst, registrationName) {
  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var bankForRegistrationName = listenerBank[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
    return null;
  }
  var key = getDictionaryKey(inst);
  return bankForRegistrationName &amp;&amp; bankForRegistrationName[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.processEventQueue" id="apidoc.element.react-dom.EventPluginHub.processEventQueue">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>processEventQueue
        <span class="apidocSignatureSpan">(simulated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processEventQueue = function (simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;
  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued
while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.<span class="apidocCodeKeywordSpan">processEventQueue</span>(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginHub.putListener" id="apidoc.element.react-dom.EventPluginHub.putListener">
        function <span class="apidocSignatureSpan">react-dom.EventPluginHub.</span>putListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putListener = function (inst, registrationName, listener) {
  !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function
, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &amp;&amp; PluginModule.didPutListener) {
    PluginModule.didPutListener(inst, registrationName, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.<span class="apidocCodeKeywordSpan">putListener</span>('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.EventPluginRegistry" id="apidoc.module.react-dom.EventPluginRegistry">module react-dom.EventPluginRegistry</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.EventPluginRegistry._resetEventPlugins" id="apidoc.element.react-dom.EventPluginRegistry._resetEventPlugins">
        function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>_resetEventPlugins
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resetEventPlugins = function () {
  eventPluginOrder = null;
  for (var pluginName in namesToPlugins) {
    if (namesToPlugins.hasOwnProperty(pluginName)) {
      delete namesToPlugins[pluginName];
    }
  }
  EventPluginRegistry.plugins.length = 0;

  var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
  for (var eventName in eventNameDispatchConfigs) {
    if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
      delete eventNameDispatchConfigs[eventName];
    }
  }

  var registrationNameModules = EventPluginRegistry.registrationNameModules;
  for (var registrationName in registrationNameModules) {
    if (registrationNameModules.hasOwnProperty(registrationName)) {
      delete registrationNameModules[registrationName];
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
    for (var lowerCasedName in possibleRegistrationNames) {
      if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
        delete possibleRegistrationNames[lowerCasedName];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginRegistry.getPluginModuleForEvent" id="apidoc.element.react-dom.EventPluginRegistry.getPluginModuleForEvent">
        function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>getPluginModuleForEvent
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPluginModuleForEvent = function (event) {
  var dispatchConfig = event.dispatchConfig;
  if (dispatchConfig.registrationName) {
    return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
  }
  if (dispatchConfig.phasedRegistrationNames !== undefined) {
    // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
    // that it is not undefined.
    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

    for (var phase in phasedRegistrationNames) {
      if (!phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
      if (pluginModule) {
        return pluginModule;
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginRegistry.injectEventPluginOrder" id="apidoc.element.react-dom.EventPluginRegistry.injectEventPluginOrder">
        function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>injectEventPluginOrder
        <span class="apidocSignatureSpan">(injectedEventPluginOrder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">injectEventPluginOrder = function (injectedEventPluginOrder) {
  !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin
 ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
alreadyInjected = true;

ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
ReactInjection.EventPluginHub.<span class="apidocCodeKeywordSpan">injectEventPluginOrder</span>(DefaultEventPluginOrder);
ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginRegistry.injectEventPluginsByName" id="apidoc.element.react-dom.EventPluginRegistry.injectEventPluginsByName">
        function <span class="apidocSignatureSpan">react-dom.EventPluginRegistry.</span>injectEventPluginsByName
        <span class="apidocSignatureSpan">(injectedNamesToPlugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">injectEventPluginsByName = function (injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject
 two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
ReactInjection.EventPluginHub.<span class="apidocCodeKeywordSpan">injectEventPluginsByName</span>({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.EventPluginUtils" id="apidoc.module.react-dom.EventPluginUtils">module react-dom.EventPluginUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.executeDirectDispatch" id="apidoc.element.react-dom.EventPluginUtils.executeDirectDispatch">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDirectDispatch
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid
 `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrder" id="apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrder">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDispatchesInOrder
        <span class="apidocSignatureSpan">(event, simulated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i &lt; dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.<span class="apidocCodeKeywordSpan">executeDispatchesInOrder</span>(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrderStopAtTrue" id="apidoc.element.react-dom.EventPluginUtils.executeDispatchesInOrderStopAtTrue">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>executeDispatchesInOrderStopAtTrue
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.getInstanceFromNode" id="apidoc.element.react-dom.EventPluginUtils.getInstanceFromNode">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInstanceFromNode = function (node) {
  return ComponentTree.getInstanceFromNode(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getInstanceFromNode</span>(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.getLowestCommonAncestor" id="apidoc.element.react-dom.EventPluginUtils.getLowestCommonAncestor">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getLowestCommonAncestor
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowestCommonAncestor = function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getLowestCommonAncestor</span>(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.getNodeFromInstance" id="apidoc.element.react-dom.EventPluginUtils.getNodeFromInstance">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getNodeFromInstance
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeFromInstance = function (node) {
  return ComponentTree.getNodeFromInstance(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getNodeFromInstance</span>(this));
  }
};

module.exports = AutoFocusUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.getParentInstance" id="apidoc.element.react-dom.EventPluginUtils.getParentInstance">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>getParentInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParentInstance = function (inst) {
  return TreeTraversal.getParentInstance(inst);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getParentInstance</span>(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.hasDispatches" id="apidoc.element.react-dom.EventPluginUtils.hasDispatches">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>hasDispatches
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasDispatches(event) {
  return !!event._dispatchListeners;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.isAncestor" id="apidoc.element.react-dom.EventPluginUtils.isAncestor">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isAncestor
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAncestor = function (a, b) {
  return TreeTraversal.isAncestor(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getInstanceFromNode: function (node) {
  return ComponentTree.getInstanceFromNode(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">isAncestor</span>(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.isEndish" id="apidoc.element.react-dom.EventPluginUtils.isEndish">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isEndish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.isMoveish" id="apidoc.element.react-dom.EventPluginUtils.isMoveish">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isMoveish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.isStartish" id="apidoc.element.react-dom.EventPluginUtils.isStartish">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>isStartish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.traverseEnterLeave" id="apidoc.element.react-dom.EventPluginUtils.traverseEnterLeave">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>traverseEnterLeave
        <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseEnterLeave = function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseEnterLeave</span>(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPluginUtils.traverseTwoPhase" id="apidoc.element.react-dom.EventPluginUtils.traverseTwoPhase">
        function <span class="apidocSignatureSpan">react-dom.EventPluginUtils.</span>traverseTwoPhase
        <span class="apidocSignatureSpan">(target, fn, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseTwoPhase = function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseTwoPhase</span>(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.EventPropagators" id="apidoc.module.react-dom.EventPropagators">module react-dom.EventPropagators</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.EventPropagators.accumulateDirectDispatches" id="apidoc.element.react-dom.EventPropagators.accumulateDirectDispatches">
        function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateDirectDispatches
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // sure it's marked and won't warn when setting additional properties.
  event.persist();
  _assign(event, eventData);

  if (dispatchConfig.phasedRegistrationNames) {
    EventPropagators.accumulateTwoPhaseDispatches(event);
  } else {
    EventPropagators.<span class="apidocCodeKeywordSpan">accumulateDirectDispatches</span>(event);
  }

  ReactUpdates.batchedUpdates(function () {
    EventPluginHub.enqueueEvents(event);
    EventPluginHub.processEventQueue(true);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPropagators.accumulateEnterLeaveDispatches" id="apidoc.element.react-dom.EventPropagators.accumulateEnterLeaveDispatches">
        function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateEnterLeaveDispatches
        <span class="apidocSignatureSpan">(leave, enter, from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.<span class="apidocCodeKeywordSpan">accumulateEnterLeaveDispatches</span>(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatches" id="apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatches">
        function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateTwoPhaseDispatches
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var customData = getDataFromCustomEvent(nativeEvent);
   if (customData !== null) {
     event.data = customData;
   }
 }

 EventPropagators.<span class="apidocCodeKeywordSpan">accumulateTwoPhaseDispatches</span>(event);
 return event;
}

/**
* @param {string} topLevelType Record from `EventConstants`.
* @param {object} nativeEvent Native browser event.
* @return {?string} The string corresponding to this `beforeInput` event.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget" id="apidoc.element.react-dom.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget">
        function <span class="apidocSignatureSpan">react-dom.EventPropagators.</span>accumulateTwoPhaseDispatchesSkipTarget
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (deepest ID) if it happens to be the current responder. The reasoning:
// It's strange to get an `onMoveShouldSetResponder` when you're *already*
// the responder.
var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
if (skipOverBubbleShouldSetFrom) {
  EventPropagators.<span class="apidocCodeKeywordSpan">accumulateTwoPhaseDispatchesSkipTarget</span>(shouldSetEvent);
} else {
  EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);
}
var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
if (!shouldSetEvent.isPersistent()) {
  shouldSetEvent.constructor.release(shouldSetEvent);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.FallbackCompositionState" id="apidoc.module.react-dom.FallbackCompositionState">module react-dom.FallbackCompositionState</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.FallbackCompositionState" id="apidoc.element.react-dom.FallbackCompositionState.FallbackCompositionState">
        function <span class="apidocSignatureSpan">react-dom.</span>FallbackCompositionState
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.getPooled" id="apidoc.element.react-dom.FallbackCompositionState.getPooled">
        function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.release" id="apidoc.element.react-dom.FallbackCompositionState.release">
        function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.FallbackCompositionState.prototype" id="apidoc.module.react-dom.FallbackCompositionState.prototype">module react-dom.FallbackCompositionState.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.prototype.destructor" id="apidoc.element.react-dom.FallbackCompositionState.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  this._root = null;
  this._startText = null;
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.prototype.getData" id="apidoc.element.react-dom.FallbackCompositionState.prototype.getData">
        function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>getData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getData = function () {
  if (this._fallbackText) {
    return this._fallbackText;
  }

  var start;
  var startValue = this._startText;
  var startLength = startValue.length;
  var end;
  var endValue = this.getText();
  var endLength = endValue.length;

  for (start = 0; start &lt; startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end &lt;= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end &gt; 1 ? 1 - end : undefined;
  this._fallbackText = endValue.slice(start, sliceTail);
  return this._fallbackText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.<span class="apidocCodeKeywordSpan">getData</span>();
    }
  }
}

var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

if (fallbackData) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.FallbackCompositionState.prototype.getText" id="apidoc.element.react-dom.FallbackCompositionState.prototype.getText">
        function <span class="apidocSignatureSpan">react-dom.FallbackCompositionState.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  if ('value' in this._root) {
    return this._root.value;
  }
  return this._root[getTextContentAccessor()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
this._root = root;
this._startText = this.<span class="apidocCodeKeywordSpan">getText</span>();
this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
destructor: function () {
  this._root = null;
  this._startText = null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.HTMLDOMPropertyConfig" id="apidoc.module.react-dom.HTMLDOMPropertyConfig">module react-dom.HTMLDOMPropertyConfig</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.HTMLDOMPropertyConfig.isCustomAttribute" id="apidoc.element.react-dom.HTMLDOMPropertyConfig.isCustomAttribute">
        function <span class="apidocSignatureSpan">react-dom.HTMLDOMPropertyConfig.</span>isCustomAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCustomAttribute = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return '';
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &amp;&amp; value === true) {
      return attributeName + '=""';
    }
    return attributeName + '=' + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.<span class="apidocCodeKeywordSpan">isCustomAttribute</span>(name)) {
    if (value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  }
  return null;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.KeyEscapeUtils" id="apidoc.module.react-dom.KeyEscapeUtils">module react-dom.KeyEscapeUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.KeyEscapeUtils.escape" id="apidoc.element.react-dom.KeyEscapeUtils.escape">
        function <span class="apidocSignatureSpan">react-dom.KeyEscapeUtils.</span>escape
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {string}
*/
function getComponentKey(component, index) {
 // Do some typechecking here since we call this blindly. We want to ensure
 // that we don't block potential future ES APIs.
 if (component &amp;&amp; typeof component === 'object' &amp;&amp; component.key != null) {
   // Explicit key
   return KeyEscapeUtils.<span class="apidocCodeKeywordSpan">escape</span>(component.key);
 }
 // Implicit key determined by the index in the set
 return index.toString(36);
}

/**
* @param {?*} children Children tree container.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.KeyEscapeUtils.unescape" id="apidoc.element.react-dom.KeyEscapeUtils.unescape">
        function <span class="apidocSignatureSpan">react-dom.KeyEscapeUtils.</span>unescape
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' &amp;&amp; key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    if (!keyUnique) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with
 the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child
 will be used.%s', KeyEscapeUtils.<span class="apidocCodeKeywordSpan">unescape</span>(name), ReactComponentTreeHook.getStackAddendumByID
(selfDebugID)) : void 0;
    }
  }
  if (child != null &amp;&amp; keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.LinkedValueUtils" id="apidoc.module.react-dom.LinkedValueUtils">module react-dom.LinkedValueUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.LinkedValueUtils.checkPropTypes" id="apidoc.element.react-dom.LinkedValueUtils.checkPropTypes">
        function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>checkPropTypes
        <span class="apidocSignatureSpan">(tagName, props, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPropTypes = function (tagName, props, owner) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
    }
    if (error instanceof Error &amp;&amp; !(error.message in loggedTypeFailures)) {
      // Only monitor this failure once because there tends to be a lot of the
      // same error.
      loggedTypeFailures[error.message] = true;

      var addendum = getDeclarationErrorAddendum(owner);
      process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
LinkedValueUtils.<span class="apidocCodeKeywordSpan">checkPropTypes</span>('input', props, inst._currentElement._owner
);

var owner = inst._currentElement._owner;

if (props.valueLink !== undefined &amp;&amp; !didWarnValueLink) {
  process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value`
and `onChange` instead.') : void 0;
  didWarnValueLink = true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.LinkedValueUtils.executeOnChange" id="apidoc.element.react-dom.LinkedValueUtils.executeOnChange">
        function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>executeOnChange
        <span class="apidocSignatureSpan">(inputProps, event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnChange = function (inputProps, event) {
  if (inputProps.valueLink) {
    _assertValueLink(inputProps);
    return inputProps.valueLink.requestChange(event.target.value);
  } else if (inputProps.checkedLink) {
    _assertCheckedLink(inputProps);
    return inputProps.checkedLink.requestChange(event.target.checked);
  } else if (inputProps.onChange) {
    return inputProps.onChange.call(undefined, event);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
};

function _handleChange(event) {
var props = this._currentElement.props;

var returnValue = LinkedValueUtils.<span class="apidocCodeKeywordSpan">executeOnChange</span>(props, event);

// Here we use asap to wait until all updates have propagated, which
// is important when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
ReactUpdates.asap(forceUpdateIfMounted, this);

var name = props.name;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.LinkedValueUtils.getChecked" id="apidoc.element.react-dom.LinkedValueUtils.getChecked">
        function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>getChecked
        <span class="apidocSignatureSpan">(inputProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChecked = function (inputProps) {
  if (inputProps.checkedLink) {
    _assertCheckedLink(inputProps);
    return inputProps.checkedLink.value;
  }
  return inputProps.checked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
var value = LinkedValueUtils.getValue(props);
var checked = LinkedValueUtils.<span class="apidocCodeKeywordSpan">getChecked</span>(props);

var hostProps = _assign({
  // Make sure we set .type before any other properties (setting .value
  // before .type means .value is lost in IE11 and below)
  type: undefined,
  // Make sure we set .step before .value (setting .value before .step
  // means .value is rounded on mount, based upon step precision)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.LinkedValueUtils.getValue" id="apidoc.element.react-dom.LinkedValueUtils.getValue">
        function <span class="apidocSignatureSpan">react-dom.LinkedValueUtils.</span>getValue
        <span class="apidocSignatureSpan">(inputProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function (inputProps) {
  if (inputProps.valueLink) {
    _assertValueLink(inputProps);
    return inputProps.valueLink.value;
  }
  return inputProps.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
var value = LinkedValueUtils.<span class="apidocCodeKeywordSpan">getValue</span>(props);
var checked = LinkedValueUtils.getChecked(props);

var hostProps = _assign({
  // Make sure we set .type before any other properties (setting .value
  // before .type means .value is lost in IE11 and below)
  type: undefined,
  // Make sure we set .step before .value (setting .value before .step
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.PooledClass" id="apidoc.module.react-dom.PooledClass">module react-dom.PooledClass</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.PooledClass.addPoolingTo" id="apidoc.element.react-dom.PooledClass.addPoolingTo">
        function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>addPoolingTo
        <span class="apidocSignatureSpan">(CopyConstructor, pooler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.<span class="apidocCodeKeywordSpan">addPoolingTo</span>(CallbackQueue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.PooledClass.fourArgumentPooler" id="apidoc.element.react-dom.PooledClass.fourArgumentPooler">
        function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>fourArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.PooledClass.oneArgumentPooler" id="apidoc.element.react-dom.PooledClass.oneArgumentPooler">
        function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>oneArgumentPooler
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.PooledClass.threeArgumentPooler" id="apidoc.element.react-dom.PooledClass.threeArgumentPooler">
        function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>threeArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2, a3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.PooledClass.twoArgumentPooler" id="apidoc.element.react-dom.PooledClass.twoArgumentPooler">
        function <span class="apidocSignatureSpan">react-dom.PooledClass.</span>twoArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactBrowserEventEmitter" id="apidoc.module.react-dom.ReactBrowserEventEmitter">module react-dom.ReactBrowserEventEmitter</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.ensureScrollValueMonitoring" id="apidoc.element.react-dom.ReactBrowserEventEmitter.ensureScrollValueMonitoring">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>ensureScrollValueMonitoring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureScrollValueMonitoring = function () {
  if (hasEventPageXY === undefined) {
    hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
  }
  if (!hasEventPageXY &amp;&amp; !isMonitoringScrollValue) {
    var refresh = ViewportMetrics.refreshScrollValues;
    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
    isMonitoringScrollValue = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Various parts of our code (such as ReactCompositeComponent's
// _renderValidatedComponent) assume that calls to render aren't nested;
// verify that that's the case.
process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render
 methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render
 is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.',
ReactCurrentOwner.current &amp;&amp; ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

!isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...):
Target container is not a DOM element.') : _prodInvariant('37') : void 0;

ReactBrowserEventEmitter.<span class="apidocCodeKeywordSpan">ensureScrollValueMonitoring</span>();
var componentInstance = instantiateReactComponent(nextElement, false);

// The initial render is synchronous but any updates that happen during
// rendering, in componentWillMount or componentDidMount, will be batched
// according to the current batching strategy.

ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.handleTopLevel" id="apidoc.element.react-dom.ReactBrowserEventEmitter.handleTopLevel">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.isEnabled" id="apidoc.element.react-dom.ReactBrowserEventEmitter.isEnabled">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>isEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnabled = function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &amp;&amp; ReactBrowserEventEmitter.ReactEventListener.isEnabled());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &amp;&amp; ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan
">isEnabled</span>());
},

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.listenTo" id="apidoc.element.react-dom.ReactBrowserEventEmitter.listenTo">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>listenTo
        <span class="apidocSignatureSpan">(registrationName, contentDocumentHandle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenTo = function (registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

  for (var i = 0; i &lt; dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) {
      if (dependency === 'topWheel') {
        if (isEventSupported('wheel')) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
        } else if (isEventSupported('mousewheel')) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
        } else {
          // Firefox needs to capture a different mouse scroll event.
          // @see http://www.quirksmode.org/dom/events/tests/scroll.html
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
        }
      } else if (dependency === 'topScroll') {

        if (isEventSupported('scroll', true)) {
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
        } else {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener
.WINDOW_HANDLE);
        }
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {

        if (isEventSupported('focus', true)) {
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
        } else if (isEventSupported('focusin')) {
          // IE has `focusin` and `focusout` events which bubble.
          // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
        }

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (topEventMapping.hasOwnProperty(dependency)) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.setEnabled" id="apidoc.element.react-dom.ReactBrowserEventEmitter.setEnabled">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>setEnabled
        <span class="apidocSignatureSpan">(enabled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnabled = function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sets whether or not any created callbacks should be enabled.
 *
 * @param {boolean} enabled True if callbacks should be enabled.
 */
setEnabled: function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">setEnabled</span>(enabled);
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.supportsEventPageXY" id="apidoc.element.react-dom.ReactBrowserEventEmitter.supportsEventPageXY">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>supportsEventPageXY
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supportsEventPageXY = function () {
  if (!document.createEvent) {
    return false;
  }
  var ev = document.createEvent('MouseEvent');
  return ev != null &amp;&amp; 'pageX' in ev;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * NOTE: Scroll events do not bubble.
 *
 * @see http://www.quirksmode.org/dom/events/scroll.html
 */
ensureScrollValueMonitoring: function () {
  if (hasEventPageXY === undefined) {
    hasEventPageXY = ReactBrowserEventEmitter.<span class="apidocCodeKeywordSpan">supportsEventPageXY</span>();
  }
  if (!hasEventPageXY &amp;&amp; !isMonitoringScrollValue) {
    var refresh = ViewportMetrics.refreshScrollValues;
    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
    isMonitoringScrollValue = true;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.trapBubbledEvent" id="apidoc.element.react-dom.ReactBrowserEventEmitter.trapBubbledEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>trapBubbledEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapBubbledEvent = function (topLevelType, handlerBaseName, handle) {
  return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

for (var i = 0; i &lt; dependencies.length; i++) {
  var dependency = dependencies[i];
  if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) {
    if (dependency === 'topWheel') {
      if (isEventSupported('wheel')) {
        ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapBubbledEvent</span>('topWheel&amp;#
x27;, 'wheel', mountAt);
      } else if (isEventSupported('mousewheel')) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
      } else {
        // Firefox needs to capture a different mouse scroll event.
        // @see http://www.quirksmode.org/dom/events/tests/scroll.html
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactBrowserEventEmitter.trapCapturedEvent" id="apidoc.element.react-dom.ReactBrowserEventEmitter.trapCapturedEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactBrowserEventEmitter.</span>trapCapturedEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapCapturedEvent = function (topLevelType, handlerBaseName, handle) {
  return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Firefox needs to capture a different mouse scroll event.
  // @see http://www.quirksmode.org/dom/events/tests/scroll.html
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
}
        } else if (dependency === 'topScroll') {

if (isEventSupported('scroll', true)) {
  ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapCapturedEvent</span>('topScroll', &amp;#
x27;scroll', mountAt);
} else {
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter
.ReactEventListener.WINDOW_HANDLE);
}
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

if (isEventSupported('focus', true)) {
  ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactChildFiber" id="apidoc.module.react-dom.ReactChildFiber">module react-dom.ReactChildFiber</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactChildFiber.cloneChildFibers" id="apidoc.element.react-dom.ReactChildFiber.cloneChildFibers">
        function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>cloneChildFibers
        <span class="apidocSignatureSpan">(current, workInProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneChildFibers = function (current, workInProgress) {
  if (!workInProgress.child) {
    return;
  }
  if (current &amp;&amp; workInProgress.child === current.child) {
    // We use workInProgress.child since that lets Flow know that it can't be
    // null since we validated that already. However, as the line above suggests
    // they're actually the same thing.
    var currentChild = workInProgress.child;
    // TODO: This used to reset the pending priority. Not sure if that is needed.
    // workInProgress.pendingWorkPriority = current.pendingWorkPriority;
    // TODO: The below priority used to be set to NoWork which would've
    // dropped work. This is currently unobservable but will become
    // observable when the first sibling has lower priority work remaining
    // than the next sibling. At that point we should add tests that catches
    // this.
    var newChild = cloneFiber(currentChild, currentChild.pendingWorkPriority);
    workInProgress.child = newChild;
    cloneSiblings(currentChild, newChild, workInProgress);
  }

  // If there is no alternate, then we don't need to clone the children.
  // If the children of the alternate fiber is a different set, then we don't
  // need to clone. We need to reset the return fiber though since we'll
  // traverse down into them.
  var child = workInProgress.child;
  while (child) {
    child['return'] = workInProgress;
    child = child.sibling;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactChildFiber.reconcileChildFibers" id="apidoc.element.react-dom.ReactChildFiber.reconcileChildFibers">
        function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>reconcileChildFibers
        <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconcileChildFibers(returnFiber, currentFirstChild, newChildren, priority) {
  return createFirstChild(returnFiber, currentFirstChild, newChildren, priority);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactChildFiber.reconcileChildFibersInPlace" id="apidoc.element.react-dom.ReactChildFiber.reconcileChildFibersInPlace">
        function <span class="apidocSignatureSpan">react-dom.ReactChildFiber.</span>reconcileChildFibersInPlace
        <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconcileChildFibers(returnFiber, currentFirstChild, newChildren, priority) {
  return createFirstChild(returnFiber, currentFirstChild, newChildren, priority);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactChildReconciler" id="apidoc.module.react-dom.ReactChildReconciler">module react-dom.ReactChildReconciler</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactChildReconciler.instantiateChildren" id="apidoc.element.react-dom.ReactChildReconciler.instantiateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>instantiateChildren
        <span class="apidocSignatureSpan">(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instantiateChildren = function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots ) {
  if (nestedChildNodes == null) {
    return null;
  }
  var childInstances = {};

  if (process.env.NODE_ENV !== 'production') {
    traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
      return instantiateChild(childInsts, child, name, selfDebugID);
    }, childInstances);
  } else {
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
  }
  return childInstances;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
  if (process.env.NODE_ENV !== 'production') {
    var selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        return ReactChildReconciler.<span class="apidocCodeKeywordSpan">instantiateChildren</span>(nestedChildren, transaction,
context, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
    }
  }
  return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactChildReconciler.unmountChildren" id="apidoc.element.react-dom.ReactChildReconciler.unmountChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>unmountChildren
        <span class="apidocSignatureSpan">(renderedChildren, safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountChildren = function (renderedChildren, safely) {
  for (var name in renderedChildren) {
    if (renderedChildren.hasOwnProperty(name)) {
      var renderedChild = renderedChildren[name];
      ReactReconciler.unmountComponent(renderedChild, safely);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * take advantage of React's reconciliation for styling and &lt;title&gt;
     * management. So we just document it and throw in dangerous cases.
     */
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;%s&gt; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &lt;html&gt;, &lt;head&gt;, and &lt;body
&gt;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.'
;, this._tag) : _prodInvariant('66', this._tag) : void 0;
    break;
}

this.<span class="apidocCodeKeywordSpan">unmountChildren</span>(safely);
ReactDOMComponentTree.uncacheNode(this);
EventPluginHub.deleteAllListeners(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactChildReconciler.updateChildren" id="apidoc.element.react-dom.ReactChildReconciler.updateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactChildReconciler.</span>updateChildren
        <span class="apidocSignatureSpan">(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateChildren = function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots ) {
  // We currently don't have a way to track moves here but if we use iterators
  // instead of for..in we can zip the iterators and check if an item has
  // moved.
  // TODO: If nothing has changed, return the prevChildren object so that we
  // can quickly bailout if nothing has changed.
  if (!nextChildren &amp;&amp; !prevChildren) {
    return;
  }
  var name;
  var prevChild;
  for (name in nextChildren) {
    if (!nextChildren.hasOwnProperty(name)) {
      continue;
    }
    prevChild = prevChildren &amp;&amp; prevChildren[name];
    var prevElement = prevChild &amp;&amp; prevChild._currentElement;
    var nextElement = nextChildren[name];
    if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
      ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
      nextChildren[name] = prevChild;
    } else {
      if (prevChild) {
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
      // The child must be instantiated before it's mounted.
      var nextChildInstance = instantiateReactComponent(nextElement, true);
      nextChildren[name] = nextChildInstance;
      // Creating mount image now ensures refs are resolved in right order
      // (see https://github.com/facebook/react/pull/7101 for explanation).
      var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
      mountImages.push(nextChildMountImage);
    }
  }
  // Unmount children that are no longer present.
  for (name in prevChildren) {
    if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
      prevChild = prevChildren[name];
      removedNodes[name] = ReactReconciler.getHostNode(prevChild);
      ReactReconciler.unmountComponent(prevChild, false);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextChildren = nextContent != null ? null : nextProps.children;

// If we're switching from children to content/html or vice versa, remove
// the old content
var lastHasContentOrHtml = lastContent != null || lastHtml != null;
var nextHasContentOrHtml = nextContent != null || nextHtml != null;
if (lastChildren != null &amp;&amp; nextChildren == null) {
  this.<span class="apidocCodeKeywordSpan">updateChildren</span>(null, transaction, context);
} else if (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) {
  this.updateTextContent('');
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactComponentBrowserEnvironment" id="apidoc.module.react-dom.ReactComponentBrowserEnvironment">module react-dom.ReactComponentBrowserEnvironment</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentBrowserEnvironment.processChildrenUpdates" id="apidoc.element.react-dom.ReactComponentBrowserEnvironment.processChildrenUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentBrowserEnvironment.</span>processChildrenUpdates
        <span class="apidocSignatureSpan">(parentInst, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChildrenUpdates = function (parentInst, updates) {
  var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
  DOMChildrenOperations.processUpdates(node, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">processChildrenUpdates</span>(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
var getDebugID = function (inst) {
  if (!inst._debugID) {
    // Check for ART-like instances. TODO: This is silly/gross.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentBrowserEnvironment.replaceNodeWithMarkup" id="apidoc.element.react-dom.ReactComponentBrowserEnvironment.replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentBrowserEnvironment.</span>replaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: 'replace with',
      payload: markup.toString()
    });
  } else {
    var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
    if (nextInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: nextInstance._debugID,
        type: 'mount',
        payload: markup.toString()
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Overridden in shallow rendering.
 *
 * @protected
 */
_replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevInstance
);
},

/**
 * @protected
 */
_renderValidatedComponentWithoutOwnerOrContext: function () {
  var inst = this._instance;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactComponentEnvironment" id="apidoc.module.react-dom.ReactComponentEnvironment">module react-dom.ReactComponentEnvironment</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentEnvironment.processChildrenUpdates" id="apidoc.element.react-dom.ReactComponentEnvironment.processChildrenUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentEnvironment.</span>processChildrenUpdates
        <span class="apidocSignatureSpan">(parentInst, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChildrenUpdates = function (parentInst, updates) {
  var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
  DOMChildrenOperations.processUpdates(node, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">processChildrenUpdates</span>(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
var getDebugID = function (inst) {
  if (!inst._debugID) {
    // Check for ART-like instances. TODO: This is silly/gross.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentEnvironment.replaceNodeWithMarkup" id="apidoc.element.react-dom.ReactComponentEnvironment.replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentEnvironment.</span>replaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: 'replace with',
      payload: markup.toString()
    });
  } else {
    var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
    if (nextInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: nextInstance._debugID,
        type: 'mount',
        payload: markup.toString()
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Overridden in shallow rendering.
 *
 * @protected
 */
_replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevInstance
);
},

/**
 * @protected
 */
_renderValidatedComponentWithoutOwnerOrContext: function () {
  var inst = this._instance;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactComponentTreeTestUtils" id="apidoc.module.react-dom.ReactComponentTreeTestUtils">module react-dom.ReactComponentTreeTestUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.expectTree" id="apidoc.element.react-dom.ReactComponentTreeTestUtils.expectTree">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>expectTree
        <span class="apidocSignatureSpan">(rootID, expectedTree, parentPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expectTree(rootID, expectedTree, parentPath) {
  var displayName = ReactComponentTreeHook.getDisplayName(rootID);
  var ownerID = ReactComponentTreeHook.getOwnerID(rootID);
  var parentID = ReactComponentTreeHook.getParentID(rootID);
  var childIDs = ReactComponentTreeHook.getChildIDs(rootID);
  var text = ReactComponentTreeHook.getText(rootID);
  var element = ReactComponentTreeHook.getElement(rootID);
  var path = parentPath ? parentPath + ' &gt; ' + displayName : displayName;

  function expectEqual(actual, expected, name) {
    // Get Jasmine to print descriptive error messages.
    // We pass path so that we know where the mismatch occurred.
    expect(_defineProperty({
      path: path
    }, name, actual)).toEqual(_defineProperty({
      path: path
    }, name, expected));
  }

  if (expectedTree.parentDisplayName !== undefined) {
    expectEqual(ReactComponentTreeHook.getDisplayName(parentID), expectedTree.parentDisplayName, 'parentDisplayName');
  }
  if (expectedTree.ownerDisplayName !== undefined) {
    expectEqual(ReactComponentTreeHook.getDisplayName(ownerID), expectedTree.ownerDisplayName, 'ownerDisplayName');
  }
  if (expectedTree.parentID !== undefined) {
    expectEqual(parentID, expectedTree.parentID, 'parentID');
  }
  if (expectedTree.text !== undefined) {
    expectEqual(text, expectedTree.text, 'text');
    expectEqual('' + element, expectedTree.text, 'element.toString()');
  } else {
    expectEqual(text, null, 'text');
  }
  if (expectedTree.element !== undefined) {
    // TODO: Comparing elements makes tests run out of memory on errors.
    // For now, compare just types.
    expectEqual(element &amp;&amp; element.type, expectedTree.element &amp;&amp; expectedTree.element.type, 'element.type');
  } else if (text == null) {
    expectEqual(typeof element, 'object', 'typeof element');
  }
  if (expectedTree.children !== undefined) {
    expectEqual(childIDs.length, expectedTree.children.length, 'children.length');
    for (var i = 0; i &lt; childIDs.length; i++) {
      expectTree(childIDs[i], _extends({ parentID: rootID }, expectedTree.children[i]), path);
    }
  } else {
    expectEqual(childIDs, [], 'childIDs');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.getRegisteredDisplayNames" id="apidoc.element.react-dom.ReactComponentTreeTestUtils.getRegisteredDisplayNames">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>getRegisteredDisplayNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRegisteredDisplayNames() {
  return ReactComponentTreeHook.getRegisteredIDs().map(ReactComponentTreeHook.getDisplayName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactComponentTreeTestUtils.getRootDisplayNames" id="apidoc.element.react-dom.ReactComponentTreeTestUtils.getRootDisplayNames">
        function <span class="apidocSignatureSpan">react-dom.ReactComponentTreeTestUtils.</span>getRootDisplayNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRootDisplayNames() {
  return ReactComponentTreeHook.getRootIDs().map(ReactComponentTreeHook.getDisplayName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactCompositeComponent" id="apidoc.module.react-dom.ReactCompositeComponent">module react-dom.ReactCompositeComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._checkContextTypes" id="apidoc.element.react-dom.ReactCompositeComponent._checkContextTypes">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_checkContextTypes
        <span class="apidocSignatureSpan">(typeSpecs, values, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkContextTypes = function (typeSpecs, values, location) {
  if (process.env.NODE_ENV !== 'production') {
    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
_processContext: function (context) {
  var maskedContext = this._maskContext(context);
  if (process.env.NODE_ENV !== 'production') {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this.<span class="apidocCodeKeywordSpan">_checkContextTypes</span>(Component.contextTypes, maskedContext, 'context'
;);
    }
  }
  return maskedContext;
},

/**
 * @param {object} currentContext
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._constructComponent" id="apidoc.element.react-dom.ReactCompositeComponent._constructComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_constructComponent
        <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_constructComponent = function (doConstruct, publicProps, publicContext, updateQueue) {
  if (process.env.NODE_ENV !== 'production') {
    ReactCurrentOwner.current = this;
    try {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var Component = this._currentElement.type;

var updateQueue = transaction.getUpdateQueue();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this.<span class="apidocCodeKeywordSpan">_constructComponent</span>(doConstruct, publicProps, publicContext, updateQueue
);
var renderedElement;

// Support functional components
if (!doConstruct &amp;&amp; (inst == null || inst.render == null)) {
  renderedElement = inst;
  warnIfInvalidElement(Component, renderedElement);
  !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant
(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other
 invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component
.displayName || Component.name || 'Component') : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._constructComponentWithoutOwner" id="apidoc.element.react-dom.ReactCompositeComponent._constructComponentWithoutOwner">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_constructComponentWithoutOwner
        <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_constructComponentWithoutOwner = function (doConstruct, publicProps, publicContext, updateQueue) {
  var Component = this._currentElement.type;

  if (doConstruct) {
    if (process.env.NODE_ENV !== 'production') {
      return measureLifeCyclePerf(function () {
        return new Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'ctor');
    } else {
      return new Component(publicProps, publicContext, updateQueue);
    }
  }

  // This can still be an instance in case of factory components
  // but we'll count this as time spent rendering as the more common case.
  if (process.env.NODE_ENV !== 'production') {
    return measureLifeCyclePerf(function () {
      return Component(publicProps, publicContext, updateQueue);
    }, this._debugID, 'render');
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return markup;
},

_constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
  if (process.env.NODE_ENV !== 'production') {
    ReactCurrentOwner.current = this;
    try {
      return this.<span class="apidocCodeKeywordSpan">_constructComponentWithoutOwner</span>(doConstruct, publicProps, publicContext
, updateQueue);
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._maskContext" id="apidoc.element.react-dom.ReactCompositeComponent._maskContext">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_maskContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_maskContext = function (context) {
  var Component = this._currentElement.type;
  var contextTypes = Component.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }
  var maskedContext = {};
  for (var contextName in contextTypes) {
    maskedContext[contextName] = context[contextName];
  }
  return maskedContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * `contextTypes`, and asserts that they are valid.
 *
 * @param {object} context
 * @return {?object}
 * @private
 */
_processContext: function (context) {
  var maskedContext = this.<span class="apidocCodeKeywordSpan">_maskContext</span>(context);
  if (process.env.NODE_ENV !== 'production') {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
    }
  }
  return maskedContext;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._performComponentUpdate" id="apidoc.element.react-dom.ReactCompositeComponent._performComponentUpdate">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_performComponentUpdate
        <span class="apidocSignatureSpan">(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_performComponentUpdate = function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
  var _this2 = this;

  var inst = this._instance;

  var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
  var prevProps;
  var prevState;
  var prevContext;
  if (hasComponentDidUpdate) {
    prevProps = inst.props;
    prevState = inst.state;
    prevContext = inst.context;
  }

  if (inst.componentWillUpdate) {
    if (process.env.NODE_ENV !== 'production') {
      measureLifeCyclePerf(function () {
        return inst.componentWillUpdate(nextProps, nextState, nextContext);
      }, this._debugID, 'componentWillUpdate');
    } else {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }
  }

  this._currentElement = nextElement;
  this._context = unmaskedContext;
  inst.props = nextProps;
  inst.state = nextState;
  inst.context = nextContext;

  this._updateRenderedComponent(transaction, unmaskedContext);

  if (hasComponentDidUpdate) {
    if (process.env.NODE_ENV !== 'production') {
      transaction.getReactMountReady().enqueue(function () {
        measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate
');
      });
    } else {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned
 undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent
') : void 0;
}

this._updateBatchNumber = null;
if (shouldUpdate) {
  this._pendingForceUpdate = false;
  // Will set `this.props`, `this.state` and `this.context`.
  this.<span class="apidocCodeKeywordSpan">_performComponentUpdate</span>(nextParentElement, nextProps, nextState, nextContext,
transaction, nextUnmaskedContext);
} else {
  // If it's determined that a component should not update, we still want
  // to set props and state but we shortcut the rest of the update.
  this._currentElement = nextParentElement;
  this._context = nextUnmaskedContext;
  inst.props = nextProps;
  inst.state = nextState;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._processChildContext" id="apidoc.element.react-dom.ReactCompositeComponent._processChildContext">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processChildContext
        <span class="apidocSignatureSpan">(currentContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processChildContext = function (currentContext) {
  var Component = this._currentElement.type;
  var inst = this._instance;
  var childContext;

  if (inst.getChildContext) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
      try {
        childContext = inst.getChildContext();
      } finally {
        ReactInstrumentation.debugTool.onEndProcessingChildContext();
      }
    } else {
      childContext = inst.getChildContext();
    }
  }

  if (childContext) {
    !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext
(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant
('107', this.getName() || 'ReactCompositeComponent') : void 0;
    if (process.env.NODE_ENV !== 'production') {
      this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
    }
    for (var name in childContext) {
      !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key
 "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName
() || 'ReactCompositeComponent', name) : void 0;
    }
    return _assign({}, currentContext, childContext);
  }
  return currentContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var nodeType = ReactNodeTypes.getType(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;

var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this.<span class="apidocCodeKeywordSpan
">_processChildContext</span>(context), debugID);

if (process.env.NODE_ENV !== 'production') {
  if (debugID !== 0) {
    var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
    ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._processContext" id="apidoc.element.react-dom.ReactCompositeComponent._processContext">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processContext = function (context) {
  var maskedContext = this._maskContext(context);
  if (process.env.NODE_ENV !== 'production') {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
    }
  }
  return maskedContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._context = context;
this._mountOrder = nextMountID++;
this._hostParent = hostParent;
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this.<span class="apidocCodeKeywordSpan">_processContext</span>(context);

var Component = this._currentElement.type;

var updateQueue = transaction.getUpdateQueue();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._processPendingState" id="apidoc.element.react-dom.ReactCompositeComponent._processPendingState">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_processPendingState
        <span class="apidocSignatureSpan">(props, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processPendingState = function (props, context) {
  var inst = this._instance;
  var queue = this._pendingStateQueue;
  var replace = this._pendingReplaceState;
  this._pendingReplaceState = false;
  this._pendingStateQueue = null;

  if (!queue) {
    return inst.state;
  }

  if (replace &amp;&amp; queue.length === 1) {
    return queue[0];
  }

  var nextState = _assign({}, replace ? queue[0] : inst.state);
  for (var i = replace ? 1 : 0; i &lt; queue.length; i++) {
    var partial = queue[i];
    _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
  }

  return nextState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.rollback(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this.<span class="apidocCodeKeywordSpan">_processPendingState</span>(this._instance.props, this._instance
.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
transaction.rollback(checkpoint);

// Try again - we've informed the component about the error, so they can render an error message this time.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponent" id="apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_renderValidatedComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderValidatedComponent = function () {
  var renderedElement;
  if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
    ReactCurrentOwner.current = this;
    try {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
  }
  !(
  // TODO: An `isValidNode` function would probably be more appropriate
  renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production
' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or
 some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent
') : void 0;

  return renderedElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this._pendingStateQueue) {
    inst.state = this._processPendingState(inst.props, inst.context);
  }
}

// If not a stateless component, we now render
if (renderedElement === undefined) {
  renderedElement = this.<span class="apidocCodeKeywordSpan">_renderValidatedComponent</span>();
}

var nodeType = ReactNodeTypes.getType(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext" id="apidoc.element.react-dom.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_renderValidatedComponentWithoutOwnerOrContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderValidatedComponentWithoutOwnerOrContext = function () {
  var inst = this._instance;
  var renderedElement;

  if (process.env.NODE_ENV !== 'production') {
    renderedElement = measureLifeCyclePerf(function () {
      return inst.render();
    }, this._debugID, 'render');
  } else {
    renderedElement = inst.render();
  }

  if (process.env.NODE_ENV !== 'production') {
    // We allow auto-mocks to proceed as if they're returning null.
    if (renderedElement === undefined &amp;&amp; inst.render._isMockFunction) {
      // This is probably bad practice. Consider warning here and
      // deprecating this convenience.
      renderedElement = null;
    }
  }

  return renderedElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
_renderValidatedComponent: function () {
  var renderedElement;
  if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
    ReactCurrentOwner.current = this;
    try {
      renderedElement = this.<span class="apidocCodeKeywordSpan">_renderValidatedComponentWithoutOwnerOrContext</span>();
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
  }
  !(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._replaceNodeWithMarkup" id="apidoc.element.react-dom.ReactCompositeComponent._replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_replaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldHostNode, nextMarkup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_replaceNodeWithMarkup = function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    this.<span class="apidocCodeKeywordSpan">_replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevComponentInstance);
  }
},

/**
 * Overridden in shallow rendering.
 *
 * @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent._updateRenderedComponent" id="apidoc.element.react-dom.ReactCompositeComponent._updateRenderedComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>_updateRenderedComponent
        <span class="apidocSignatureSpan">(transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateRenderedComponent = function (transaction, context) {
  var prevComponentInstance = this._renderedComponent;
  var prevRenderedElement = prevComponentInstance._currentElement;
  var nextRenderedElement = this._renderValidatedComponent();

  var debugID = 0;
  if (process.env.NODE_ENV !== 'production') {
    debugID = this._debugID;
  }

  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
    ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
  } else {
    var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
    ReactReconciler.unmountComponent(prevComponentInstance, false);

    var nodeType = ReactNodeTypes.getType(nextRenderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY<span class="apidocCodeCommentSpan"> /* shouldHaveDebugID */
</span>    );
    this._renderedComponent = child;

    var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext
(context), debugID);

    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._currentElement = nextElement;
this._context = unmaskedContext;
inst.props = nextProps;
inst.state = nextState;
inst.context = nextContext;

this.<span class="apidocCodeKeywordSpan">_updateRenderedComponent</span>(transaction, unmaskedContext);

if (hasComponentDidUpdate) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.getReactMountReady().enqueue(function () {
      measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate
');
    });
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.attachRef" id="apidoc.element.react-dom.ReactCompositeComponent.attachRef">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>attachRef
        <span class="apidocSignatureSpan">(ref, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachRef = function (ref, component) {
  var inst = this.getPublicInstance();
  !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') :
_prodInvariant('110') : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== 'production') {
    var componentName = component &amp;&amp; component.getName ? component.getName() : 'a component';
    process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts
 to access this ref will fail.', ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
  refs[ref] = publicComponentInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} ref Name by which to refer to the component.
 * @param {ReactOwner} owner Component on which to record the ref.
 * @final
 * @internal
 */
addComponentAsRefTo: function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only
 a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
  owner.<span class="apidocCodeKeywordSpan">attachRef</span>(ref, component);
},

/**
 * Removes a component by ref from an owner component.
 *
 * @param {ReactComponent} component Component to dereference.
 * @param {string} ref Name of the ref to remove.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.construct" id="apidoc.element.react-dom.ReactCompositeComponent.construct">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>construct
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">construct = function (element) {
  this._currentElement = element;
  this._rootNodeID = 0;
  this._compositeType = null;
  this._instance = null;
  this._hostParent = null;
  this._hostContainerInfo = null;

  // See ReactUpdateQueue
  this._updateBatchNumber = null;
  this._pendingElement = null;
  this._pendingStateQueue = null;
  this._pendingReplaceState = false;
  this._pendingForceUpdate = false;

  this._renderedNodeType = null;
  this._renderedComponent = null;
  this._context = null;
  this._mountOrder = 0;
  this._topLevelWrapper = null;

  // See ReactUpdates and ReactUpdateQueue.
  this._pendingCallbacks = null;

  // ComponentWillUnmount shall only be called once
  this._calledComponentWillUnmount = false;

  if (process.env.NODE_ENV !== 'production') {
    this._warnedAboutRefsInRender = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var ShallowComponentWrapper = function (element) {
// TODO: Consolidate with instantiateReactComponent
if (process.env.NODE_ENV !== 'production') {
  this._debugID = getNextDebugID();
}

this.<span class="apidocCodeKeywordSpan">construct</span>(element);
};
_assign(ShallowComponentWrapper.prototype, ReactCompositeComponent, {
_constructComponent: ReactCompositeComponent._constructComponentWithoutOwner,
_instantiateReactComponent: function (element) {
  return new NoopInternalComponent(element);
},
_replaceNodeWithMarkup: function () {},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.detachRef" id="apidoc.element.react-dom.ReactCompositeComponent.detachRef">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>detachRef
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachRef = function (ref) {
  var refs = this.getPublicInstance().refs;
  delete refs[ref];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...):
Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance &amp;&amp; ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.<span class="apidocCodeKeywordSpan">detachRef</span>(ref);
    }
  }

};

module.exports = ReactOwner;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.getHostNode" id="apidoc.element.react-dom.ReactCompositeComponent.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactReconciler.getHostNode(this._renderedComponent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.getName" id="apidoc.element.react-dom.ReactCompositeComponent.getName">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getName = function () {
  var type = this._currentElement.type;
  var constructor = this._instance &amp;&amp; this._instance.constructor;
  return type.displayName || constructor &amp;&amp; constructor.displayName || type.name || constructor &amp;&amp; constructor.name || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  warnedForNaNValue = true;
  process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property
.%s', name, checkRenderMessage(owner)) : void 0;
};

var checkRenderMessage = function (owner) {
  if (owner) {
    var name = owner.<span class="apidocCodeKeywordSpan">getName</span>();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.getPublicInstance" id="apidoc.element.react-dom.ReactCompositeComponent.getPublicInstance">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>getPublicInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicInstance = function () {
  var inst = this._instance;
  if (this._compositeType === CompositeTypes.StatelessFunctional) {
    return null;
  }
  return inst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} ref Reference name.
 * @param {component} component Component to store as `ref`.
 * @final
 * @private
 */
attachRef: function (ref, component) {
  var inst = this.<span class="apidocCodeKeywordSpan">getPublicInstance</span>();
  !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot
 have refs.') : _prodInvariant('110') : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== 'production') {
    var componentName = component &amp;&amp; component.getName ? component.getName() : 'a component';
    process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created
 by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.mountComponent" id="apidoc.element.react-dom.ReactCompositeComponent.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  var _this = this;

  this._context = context;
  this._mountOrder = nextMountID++;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var publicProps = this._currentElement.props;
  var publicContext = this._processContext(context);

  var Component = this._currentElement.type;

  var updateQueue = transaction.getUpdateQueue();

  // Initialize the public class
  var doConstruct = shouldConstruct(Component);
  var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
  var renderedElement;

  // Support functional components
  if (!doConstruct &amp;&amp; (inst == null || inst.render == null)) {
    renderedElement = inst;
    warnIfInvalidElement(Component, renderedElement);
    !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%
s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object
.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || '
Component') : void 0;
    inst = new StatelessComponent(Component);
    this._compositeType = CompositeTypes.StatelessFunctional;
  } else {
    if (isPureComponent(Component)) {
      this._compositeType = CompositeTypes.PureClass;
    } else {
      this._compositeType = CompositeTypes.ImpureClass;
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    // This will throw later in _renderValidatedComponent, but add an early
    // warning now to help debugging
    if (inst.render == null) {
      process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance
: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
    }

    var propsMutated = inst.props !== publicProps;
    var componentName = Component.displayName || Component.name || 'Component';

    process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in
 `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
  }

  // These should be set up in the constructor, but as a convenience for
  // simpler class abstractions, we set them up after the fact.
  inst.props = publicProps;
  inst.context = publicContext;
  inst.refs = emptyObject;
  inst.updater = updateQueue;

  this._instance = inst;

  // Store a reference from the instance back to the internal representation
  ReactInstanceMap.set(inst, this);

  if (process.env.NODE_ENV !== 'production') {
    // Since plain JS classes are defined without any special initialization
    // logic, we can not catch common errors early. Therefore, we have to
    // catch them here, at initialization time, instead.
    process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state
, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass
. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps
 was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use
a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a
 static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s.
U ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.performInitialMount" id="apidoc.element.react-dom.ReactCompositeComponent.performInitialMount">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performInitialMount
        <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performInitialMount = function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var inst = this._instance;

  var debugID = 0;
  if (process.env.NODE_ENV !== 'production') {
    debugID = this._debugID;
  }

  if (inst.componentWillMount) {
    if (process.env.NODE_ENV !== 'production') {
      measureLifeCyclePerf(function () {
        return inst.componentWillMount();
      }, debugID, 'componentWillMount');
    } else {
      inst.componentWillMount();
    }
    // When mounting, calls to `setState` by `componentWillMount` will set
    // `this._pendingStateQueue` without triggering a re-render.
    if (this._pendingStateQueue) {
      inst.state = this._processPendingState(inst.props, inst.context);
    }
  }

  // If not a stateless component, we now render
  if (renderedElement === undefined) {
    renderedElement = this._renderValidatedComponent();
  }

  var nodeType = ReactNodeTypes.getType(renderedElement);
  this._renderedNodeType = nodeType;
  var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY<span class="apidocCodeCommentSpan"> /* shouldHaveDebugID */
</span>  );
  this._renderedComponent = child;

  var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);

  if (process.env.NODE_ENV !== 'production') {
    if (debugID !== 0) {
      var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
      ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
    }
  }

  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._pendingReplaceState = false;
this._pendingForceUpdate = false;

var markup;
if (inst.unstable_handleError) {
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.<span class="apidocCodeKeywordSpan">performInitialMount</span>(renderedElement, hostParent, hostContainerInfo, transaction
, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.getReactMountReady().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.performInitialMountWithErrorHandling" id="apidoc.element.react-dom.ReactCompositeComponent.performInitialMountWithErrorHandling">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performInitialMountWithErrorHandling
        <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performInitialMountWithErrorHandling = function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.checkpoint();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
      this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
    }
    checkpoint = transaction.checkpoint();

    this._renderedComponent.unmountComponent(true);
    transaction.rollback(checkpoint);

    // Try again - we've informed the component about the error, so they can render an error message this time.
    // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  }
  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._pendingStateQueue = null;
this._pendingReplaceState = false;
this._pendingForceUpdate = false;

var markup;
if (inst.unstable_handleError) {
  markup = this.<span class="apidocCodeKeywordSpan">performInitialMountWithErrorHandling</span>(renderedElement, hostParent, hostContainerInfo
, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.getReactMountReady().enqueue(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.performUpdateIfNecessary" id="apidoc.element.react-dom.ReactCompositeComponent.performUpdateIfNecessary">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>performUpdateIfNecessary
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performUpdateIfNecessary = function (transaction) {
  if (this._pendingElement != null) {
    ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
  } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
    this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
  } else {
    this._updateBatchNumber = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.<span class="apidocCodeKeywordSpan">performUpdateIfNecessary</span>(transaction);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.receiveComponent" id="apidoc.element.react-dom.ReactCompositeComponent.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextElement, transaction, nextContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.unmountComponent" id="apidoc.element.react-dom.ReactCompositeComponent.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>unmountComponent
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (safely) {
  if (!this._renderedComponent) {
    return;
  }

  var inst = this._instance;

  if (inst.componentWillUnmount &amp;&amp; !inst._calledComponentWillUnmount) {
    inst._calledComponentWillUnmount = true;

    if (safely) {
      var name = this.getName() + '.componentWillUnmount()';
      ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
    } else {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUnmount();
        }, this._debugID, 'componentWillUnmount');
      } else {
        inst.componentWillUnmount();
      }
    }
  }

  if (this._renderedComponent) {
    ReactReconciler.unmountComponent(this._renderedComponent, safely);
    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._instance = null;
  }

  // Reset pending fields
  // Even if this component is scheduled for another update in ReactUpdates,
  // it would still be ignored because these fields are reset.
  this._pendingStateQueue = null;
  this._pendingReplaceState = false;
  this._pendingForceUpdate = false;
  this._pendingCallbacks = null;
  this._pendingElement = null;

  // These fields do not really need to be reset since this object is no
  // longer accessible.
  this._context = null;
  this._rootNodeID = 0;
  this._topLevelWrapper = null;

  // Delete the reference from the instance to this internal representation
  // which allow the internals to be properly cleaned up even if the user
  // leaks a reference to the public instance.
  ReactInstanceMap.remove(inst);

  // Some existing components rely on inst.props even after they've been
  // destroyed (in event handlers).
  // TODO: inst.props = null;
  // TODO: inst.state = null;
  // TODO: inst.context = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCompositeComponent.updateComponent" id="apidoc.element.react-dom.ReactCompositeComponent.updateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactCompositeComponent.</span>updateComponent
        <span class="apidocSignatureSpan">(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateComponent = function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
  var inst = this._instance;
  !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already
 been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || '
ReactCompositeComponent') : void 0;

  var willReceive = false;
  var nextContext;

  // Determine if the context has changed or not
  if (this._context === nextUnmaskedContext) {
    nextContext = inst.context;
  } else {
    nextContext = this._processContext(nextUnmaskedContext);
    willReceive = true;
  }

  var prevProps = prevParentElement.props;
  var nextProps = nextParentElement.props;

  // Not a simple state update but a props update
  if (prevParentElement !== nextParentElement) {
    willReceive = true;
  }

  // An update here will schedule an update but immediately set
  // _pendingStateQueue which will ensure that any state updates gets
  // immediately reconciled instead of waiting for the next batch.
  if (willReceive &amp;&amp; inst.componentWillReceiveProps) {
    if (process.env.NODE_ENV !== 'production') {
      measureLifeCyclePerf(function () {
        return inst.componentWillReceiveProps(nextProps, nextContext);
      }, this._debugID, 'componentWillReceiveProps');
    } else {
      inst.componentWillReceiveProps(nextProps, nextContext);
    }
  }

  var nextState = this._processPendingState(nextProps, nextContext);
  var shouldUpdate = true;

  if (!this._pendingForceUpdate) {
    if (inst.shouldComponentUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        shouldUpdate = measureLifeCyclePerf(function () {
          return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'shouldComponentUpdate');
      } else {
        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
      }
    } else {
      if (this._compositeType === CompositeTypes.PureClass) {
        shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
      }
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined
instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
  }

  this._updateBatchNumber = null;
  if (shouldUpdate) {
    this._pendingForceUpdate = false;
    // Will set `this.props`, `this.state` and `this.context`.
    this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
  } else {
    // If it's determined that a component should not update, we still want
    // to set props and state but we shortcut the rest of the update.
    this._currentElement = nextParentElement;
    this._context = nextUnmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

receiveComponent: function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.<span class="apidocCodeKeywordSpan">updateComponent</span>(transaction, prevElement, nextElement, prevContext, nextContext
);
},

/**
 * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
 * is set, update the component.
 *
 * @param {ReactReconcileTransaction} transaction
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactCoroutine" id="apidoc.module.react-dom.ReactCoroutine">module react-dom.ReactCoroutine</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactCoroutine.createCoroutine" id="apidoc.element.react-dom.ReactCoroutine.createCoroutine">
        function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>createCoroutine
        <span class="apidocSignatureSpan">(children, handler, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCoroutine = function (children, handler, props) {
  var key = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : null;

  var coroutine = {
    // This tag allow us to uniquely identify this as a React Coroutine
    $$typeof: REACT_COROUTINE_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    handler: handler,
    props: props
  };

  if (process.env.NODE_ENV !== 'production') {
    // TODO: Add _store property for marking this as validated.
    if (Object.freeze) {
      Object.freeze(coroutine.props);
      Object.freeze(coroutine);
    }
  }

  return coroutine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCoroutine.createYield" id="apidoc.element.react-dom.ReactCoroutine.createYield">
        function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>createYield
        <span class="apidocSignatureSpan">(props, continuation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createYield = function (props, continuation) {
  var key = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : null;

  var yieldNode = {
    // This tag allow us to uniquely identify this as a React Yield
    $$typeof: REACT_YIELD_TYPE,
    key: key == null ? null : '' + key,
    props: props,
    continuation: continuation
  };

  if (process.env.NODE_ENV !== 'production') {
    // TODO: Add _store property for marking this as validated.
    if (Object.freeze) {
      Object.freeze(yieldNode.props);
      Object.freeze(yieldNode);
    }
  }

  return yieldNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCoroutine.isCoroutine" id="apidoc.element.react-dom.ReactCoroutine.isCoroutine">
        function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>isCoroutine
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCoroutine = function (object) {
  return typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_COROUTINE_TYPE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactCoroutine.isYield" id="apidoc.element.react-dom.ReactCoroutine.isYield">
        function <span class="apidocSignatureSpan">react-dom.ReactCoroutine.</span>isYield
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isYield = function (object) {
  return typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_YIELD_TYPE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMComponent" id="apidoc.module.react-dom.ReactDOMComponent">module react-dom.ReactDOMComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.ReactDOMComponent" id="apidoc.element.react-dom.ReactDOMComponent.ReactDOMComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMComponent.prototype" id="apidoc.module.react-dom.ReactDOMComponent.prototype">module react-dom.ReactDOMComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createContentMarkup" id="apidoc.element.react-dom.ReactDOMComponent.prototype._createContentMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createContentMarkup
        <span class="apidocSignatureSpan">(transaction, props, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createContentMarkup = function (transaction, props, context) {
  var ret = '';

  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      ret = innerHTML.__html;
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    if (contentToUse != null) {
      // TODO: Validate that text is allowed as a child of this node
      ret = escapeTextContentForBrowser(contentToUse);
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      ret = mountImages.join('');
    }
  }
  if (newlineEatingTags[this._tag] &amp;&amp; ret.charAt(0) === '\n') {
    // text/html ignores the first character in these tags if it's a newline
    // Prefer to break application/xml over text/html (for now) by adding
    // a newline specifically to get eaten by the parser. (Alternately for
    // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
    // \r is normalized out by HTMLTextAreaElement#value.)
    // See: &lt;http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre&gt;
    // See: &lt;http://www.w3.org/TR/html5/syntax.html#element-restrictions&gt;
    // See: &lt;http://www.w3.org/TR/html5/syntax.html#newlines&gt;
    // See: Parsing of "textarea" "listing" and "pre" elements
    //  from &lt;http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody&gt;
    return '\n' + ret;
  } else {
    return ret;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this.<span class="apidocCodeKeywordSpan">_createContentMarkup</span>(transaction, props, context);
  if (!tagContent &amp;&amp; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + '/&gt;';
  } else {
    mountImage = tagOpen + '&gt;' + tagContent + '&lt;/' + this._currentElement.type + '&gt;'
;;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createInitialChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype._createInitialChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createInitialChildren
        <span class="apidocSignatureSpan">(transaction, props, context, lazyTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createInitialChildren = function (transaction, props, context, lazyTree) {
  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    // TODO: Validate that text is allowed as a child of this node
    if (contentToUse != null) {
      // Avoid setting textContent when the text is empty. In IE11 setting
      // textContent on a text area will cause the placeholder to not
      // show within the textarea until it has been focused and blurred again.
      // https://github.com/facebook/react/issues/6731#issuecomment-254874553
      if (contentToUse !== '') {
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
        DOMLazyTree.queueText(lazyTree, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      for (var i = 0; i &lt; mountImages.length; i++) {
        DOMLazyTree.queueChild(lazyTree, mountImages[i]);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this.<span class="apidocCodeKeywordSpan">_createInitialChildren</span>(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &amp;&amp; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + '/&gt;';
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners" id="apidoc.element.react-dom.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_createOpenTagMarkupAndPutListeners
        <span class="apidocSignatureSpan">(transaction, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createOpenTagMarkupAndPutListeners = function (transaction, props) {
  var ret = '&lt;' + this._currentElement.type;

  for (var propKey in props) {
    if (!props.hasOwnProperty(propKey)) {
      continue;
    }
    var propValue = props[propKey];
    if (propValue == null) {
      continue;
    }
    if (registrationNameModules.hasOwnProperty(propKey)) {
      if (propValue) {
        enqueuePutListener(this, propKey, propValue, transaction);
      }
    } else {
      if (propKey === STYLE) {
        if (propValue) {
          if (process.env.NODE_ENV !== 'production') {
            // See `_updateDOMProperties`. style block
            this._previousStyle = propValue;
          }
          propValue = this._previousStyleCopy = _assign({}, props.style);
        }
        propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
      }
      var markup = null;
      if (this._tag != null &amp;&amp; isCustomComponent(this._tag, props)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
        }
      } else {
        markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
      }
      if (markup) {
        ret += ' ' + markup;
      }
    }
  }

  // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
  }
  ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this.<span class="apidocCodeKeywordSpan">_createOpenTagMarkupAndPutListeners</span>(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &amp;&amp; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + '/&gt;';
  } else {
    mountImage = tagOpen + '&gt;' + tagContent + '&lt;/' + this._currentElement.type + '&gt;'
;;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._mountChildAtIndex" id="apidoc.element.react-dom.ReactDOMComponent.prototype._mountChildAtIndex">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_mountChildAtIndex
        <span class="apidocSignatureSpan">(child, mountImage, afterNode, index, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mountChildAtIndex = function (child, mountImage, afterNode, index, transaction, context) {
  child._mountIndex = index;
  return this.createChild(child, afterNode, mountImage);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    if (prevChild) {
      // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
      lastIndex = Math.max(prevChild._mountIndex, lastIndex);
      // The `removedNodes` loop below will actually remove the child.
    }
    // The child must be instantiated before it's mounted.
    updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">_mountChildAtIndex</span>(nextChild, mountImages[nextMountIndex
], lastPlacedNode, nextIndex, transaction, context));
    nextMountIndex++;
  }
  nextIndex++;
  lastPlacedNode = ReactReconciler.getHostNode(nextChild);
}
// Remove children that are no longer present.
for (name in removedNodes) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerInstantiateChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerInstantiateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_reconcilerInstantiateChildren
        <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reconcilerInstantiateChildren = function (nestedChildren, transaction, context) {
  if (process.env.NODE_ENV !== 'production') {
    var selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
    }
  }
  return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
var children = this.<span class="apidocCodeKeywordSpan">_reconcilerInstantiateChildren</span>(nestedChildren, transaction, context
);
this._renderedChildren = children;

var mountImages = [];
var index = 0;
for (var name in children) {
  if (children.hasOwnProperty(name)) {
    var child = children[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerUpdateChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype._reconcilerUpdateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_reconcilerUpdateChildren
        <span class="apidocSignatureSpan">(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reconcilerUpdateChildren = function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
  var nextChildren;
  var selfDebugID = 0;
  if (process.env.NODE_ENV !== 'production') {
    selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
      return nextChildren;
    }
  }
  nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
  ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
  return nextChildren;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @protected
 */
_updateChildren: function (nextNestedChildrenElements, transaction, context) {
  var prevChildren = this._renderedChildren;
  var removedNodes = {};
  var mountImages = [];
  var nextChildren = this.<span class="apidocCodeKeywordSpan">_reconcilerUpdateChildren</span>(prevChildren, nextNestedChildrenElements
, mountImages, removedNodes, transaction, context);
  if (!nextChildren &amp;&amp; !prevChildren) {
    return;
  }
  var updates = null;
  var name;
  // `nextIndex` will increment for each child in `nextChildren`, but
  // `lastIndex` will be the last index visited in `prevChildren`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._unmountChild" id="apidoc.element.react-dom.ReactDOMComponent.prototype._unmountChild">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_unmountChild
        <span class="apidocSignatureSpan">(child, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unmountChild = function (child, node) {
  var update = this.removeChild(child, node);
  child._mountIndex = null;
  return update;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  nextIndex++;
  lastPlacedNode = ReactReconciler.getHostNode(nextChild);
}
// Remove children that are no longer present.
for (name in removedNodes) {
  if (removedNodes.hasOwnProperty(name)) {
    updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">_unmountChild</span>(prevChildren[name], removedNodes[name
]));
  }
}
if (updates) {
  processQueue(this, updates);
}
this._renderedChildren = nextChildren;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype._updateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateChildren
        <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateChildren = function (nextNestedChildrenElements, transaction, context) {
  var prevChildren = this._renderedChildren;
  var removedNodes = {};
  var mountImages = [];
  var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction
, context);
  if (!nextChildren &amp;&amp; !prevChildren) {
    return;
  }
  var updates = null;
  var name;
  // `nextIndex` will increment for each child in `nextChildren`, but
  // `lastIndex` will be the last index visited in `prevChildren`.
  var nextIndex = 0;
  var lastIndex = 0;
  // `nextMountIndex` will increment for each newly mounted child.
  var nextMountIndex = 0;
  var lastPlacedNode = null;
  for (name in nextChildren) {
    if (!nextChildren.hasOwnProperty(name)) {
      continue;
    }
    var prevChild = prevChildren &amp;&amp; prevChildren[name];
    var nextChild = nextChildren[name];
    if (prevChild === nextChild) {
      updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
      lastIndex = Math.max(prevChild._mountIndex, lastIndex);
      prevChild._mountIndex = nextIndex;
    } else {
      if (prevChild) {
        // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
        lastIndex = Math.max(prevChild._mountIndex, lastIndex);
        // The `removedNodes` loop below will actually remove the child.
      }
      // The child must be instantiated before it's mounted.
      updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction
, context));
      nextMountIndex++;
    }
    nextIndex++;
    lastPlacedNode = ReactReconciler.getHostNode(nextChild);
  }
  // Remove children that are no longer present.
  for (name in removedNodes) {
    if (removedNodes.hasOwnProperty(name)) {
      updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
    }
  }
  if (updates) {
    processQueue(this, updates);
  }
  this._renderedChildren = nextChildren;

  if (process.env.NODE_ENV !== 'production') {
    setChildrenForInstrumentation.call(this, nextChildren);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {?object} nextNestedChildrenElements Nested child element maps.
 * @param {ReactReconcileTransaction} transaction
 * @internal
 */
updateChildren: function (nextNestedChildrenElements, transaction, context) {
  // Hook used by React ART
  this.<span class="apidocCodeKeywordSpan">_updateChildren</span>(nextNestedChildrenElements, transaction, context);
},

/**
 * @param {?object} nextNestedChildrenElements Nested child element maps.
 * @param {ReactReconcileTransaction} transaction
 * @final
 * @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateDOMChildren
        <span class="apidocSignatureSpan">(lastProps, nextProps, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateDOMChildren = function (lastProps, nextProps, transaction, context) {
  var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
  var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

  var lastHtml = lastProps.dangerouslySetInnerHTML &amp;&amp; lastProps.dangerouslySetInnerHTML.__html;
  var nextHtml = nextProps.dangerouslySetInnerHTML &amp;&amp; nextProps.dangerouslySetInnerHTML.__html;

  // Note the use of `!=` which checks for null or undefined.
  var lastChildren = lastContent != null ? null : lastProps.children;
  var nextChildren = nextContent != null ? null : nextProps.children;

  // If we're switching from children to content/html or vice versa, remove
  // the old content
  var lastHasContentOrHtml = lastContent != null || lastHtml != null;
  var nextHasContentOrHtml = nextContent != null || nextHtml != null;
  if (lastChildren != null &amp;&amp; nextChildren == null) {
    this.updateChildren(null, transaction, context);
  } else if (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) {
    this.updateTextContent('');
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
    }
  }

  if (nextContent != null) {
    if (lastContent !== nextContent) {
      this.updateTextContent('' + nextContent);
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, nextContent);
      }
    }
  } else if (nextHtml != null) {
    if (lastHtml !== nextHtml) {
      this.updateMarkup('' + nextHtml);
    }
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
    }
  } else if (nextChildren != null) {
    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }

    this.updateChildren(nextChildren, transaction, context);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
    nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
    break;
}

assertValidProps(this, nextProps);
this._updateDOMProperties(lastProps, nextProps, transaction);
this.<span class="apidocCodeKeywordSpan">_updateDOMChildren</span>(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case 'input':
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.updateWrapper(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMProperties" id="apidoc.element.react-dom.ReactDOMComponent.prototype._updateDOMProperties">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>_updateDOMProperties
        <span class="apidocSignatureSpan">(lastProps, nextProps, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateDOMProperties = function (lastProps, nextProps, transaction) {
  var propKey;
  var styleName;
  var styleUpdates;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = this._previousStyleCopy;
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          styleUpdates = styleUpdates || {};
          styleUpdates[styleName] = '';
        }
      }
      this._previousStyleCopy = null;
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (lastProps[propKey]) {
        // Only call deleteListener if there was a listener previously or
        // else willDeleteListener gets called when there wasn't actually a
        // listener (e.g., onClick={null})
        deleteListener(this, propKey);
      }
    } else if (isCustomComponent(this._tag, lastProps)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
      }
    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null &amp;&amp; lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      if (nextProp) {
        if (process.env.NODE_ENV !== 'production') {
          checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
          this._previousStyle = nextProp;
        }
        nextProp = this._previousStyleCopy = _assign({}, nextProp);
      } else {
        this._previousStyleCopy = null;
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        styleUpdates = nextProp;
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp) {
        enqueuePutListener(this, propKey, nextProp, transaction);
      } else if (lastProp) {
        deleteListener(this, propKey);
      }
    } else if (isCustomComponent(this._tag, nextProps)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
      }
    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      var node = getNode(this);
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      if (nextProp != null) {
        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
  }
  if (styleUpdates) {
    CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
  }
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this.<span class="apidocCodeKeywordSpan">_updateDOMProperties</span>(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &amp;&amp; omittedCloseTags[this._tag]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.createChild" id="apidoc.element.react-dom.ReactDOMComponent.prototype.createChild">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>createChild
        <span class="apidocSignatureSpan">(child, afterNode, mountImage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChild = function (child, afterNode, mountImage) {
  return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} name Name of the child.
 * @param {number} index Index at which to insert the child.
 * @param {ReactReconcileTransaction} transaction
 * @private
 */
_mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
  child._mountIndex = index;
  return this.<span class="apidocCodeKeywordSpan">createChild</span>(child, afterNode, mountImage);
},

/**
 * Unmounts a rendered child.
 *
 * NOTE: This is part of `updateChildren` and is here for readability.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.getHostNode" id="apidoc.element.react-dom.ReactDOMComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return getNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.getPublicInstance" id="apidoc.element.react-dom.ReactDOMComponent.prototype.getPublicInstance">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>getPublicInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicInstance = function () {
  return getNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} ref Reference name.
 * @param {component} component Component to store as `ref`.
 * @final
 * @private
 */
attachRef: function (ref, component) {
  var inst = this.<span class="apidocCodeKeywordSpan">getPublicInstance</span>();
  !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot
 have refs.') : _prodInvariant('110') : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== 'production') {
    var componentName = component &amp;&amp; component.getName ? component.getName() : 'a component';
    process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created
 by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.mountChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype.mountChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>mountChildren
        <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountChildren = function (nestedChildren, transaction, context) {
  var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
  this._renderedChildren = children;

  var mountImages = [];
  var index = 0;
  for (var name in children) {
    if (children.hasOwnProperty(name)) {
      var child = children[name];
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== 'production') {
        selfDebugID = getDebugID(this);
      }
      var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
      child._mountIndex = index++;
      mountImages.push(mountImage);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    setChildrenForInstrumentation.call(this, children);
  }

  return mountImages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (contentToUse != null) {
    // TODO: Validate that text is allowed as a child of this node
    ret = escapeTextContentForBrowser(contentToUse);
    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, contentToUse);
    }
  } else if (childrenToUse != null) {
    var mountImages = this.<span class="apidocCodeKeywordSpan">mountChildren</span>(childrenToUse, transaction, context);
    ret = mountImages.join('');
  }
}
if (newlineEatingTags[this._tag] &amp;&amp; ret.charAt(0) === '\n') {
  // text/html ignores the first character in these tags if it's a newline
  // Prefer to break application/xml over text/html (for now) by adding
  // a newline specifically to get eaten by the parser. (Alternately for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.mountComponent" id="apidoc.element.react-dom.ReactDOMComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  this._rootNodeID = globalIdCounter++;
  this._domID = hostContainerInfo._idCounter++;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var props = this._currentElement.props;

  switch (this._tag) {
    case 'audio':
    case 'form':
    case 'iframe':
    case 'img':
    case 'link':
    case 'object':
    case 'source':
    case 'video':
      this._wrapperState = {
        listeners: null
      };
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case 'input':
      ReactDOMInput.mountWrapper(this, props, hostParent);
      props = ReactDOMInput.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case 'option':
      ReactDOMOption.mountWrapper(this, props, hostParent);
      props = ReactDOMOption.getHostProps(this, props);
      break;
    case 'select':
      ReactDOMSelect.mountWrapper(this, props, hostParent);
      props = ReactDOMSelect.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case 'textarea':
      ReactDOMTextarea.mountWrapper(this, props, hostParent);
      props = ReactDOMTextarea.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
  }

  assertValidProps(this, props);

  // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.
  var namespaceURI;
  var parentTag;
  if (hostParent != null) {
    namespaceURI = hostParent._namespaceURI;
    parentTag = hostParent._tag;
  } else if (hostContainerInfo._tag) {
    namespaceURI = hostContainerInfo._namespaceURI;
    parentTag = hostContainerInfo._tag;
  }
  if (namespaceURI == null || namespaceURI === DOMNamespaces.svg &amp;&amp; parentTag === 'foreignobject') {
    namespaceURI = DOMNamespaces.html;
  }
  if (namespaceURI === DOMNamespaces.html) {
    if (this._tag === 'svg') {
      namespaceURI = DOMNamespaces.svg;
    } else if (this._tag === 'math') {
      namespaceURI = DOMNamespaces.mathml;
    }
  }
  this._namespaceURI = namespaceURI;

  if (process.env.NODE_ENV !== 'production') {
    var parentInfo;
    if (hostParent != null) {
      parentInfo = hostParent._ancestorInfo;
    } else if (hostContainerInfo._tag) {
      parentInfo = hostContainerInfo._ancestorInfo;
    }
    if (parentInfo) {
      // parentInfo should always be present except for the top-level
      // component when server rendering
      validateDOMNesting(this._tag, null, this, parentInfo);
    }
    this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
  }

  var mountImage;
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var el;
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'script') {
        // Create the script via .innerHTML so its "parser-inserted" flag is
        // set to true and it does not execute
        var div = ownerDocument.createElement('div');
        var type = this._currentElement.type;
        div.innerHTML = '&lt;' + type + '&gt;&lt;/' + type + '&gt;';
        el = div.removeChild(div.firstChild);
      } else if (props.is) {
        el = ownerDocument.createElement(this._currentElement.type, props.is);
      } else {
        // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
        // See discussion in https://github.com/facebook/react/pull/6896
        // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
        el = ownerDocument.createElement(this._currentElement.type);
      }
    } else {
      el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
    }
    ReactDOMComponentTree.precacheNode(this, el);
    this._flags |= Flags.hasCachedChildNodes;
    if (!this._hostParent) {
      DOMPropertyOperations.setAttributeForRoot(el);
    }
    this._updateDOMProperties(null, pr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.moveChild" id="apidoc.element.react-dom.ReactDOMComponent.prototype.moveChild">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>moveChild
        <span class="apidocSignatureSpan">(child, afterNode, toIndex, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveChild = function (child, afterNode, toIndex, lastIndex) {
  // If the index of `child` is less than `lastIndex`, then it needs to
  // be moved. Otherwise, we do not need to move it because a child will be
  // inserted or moved before `child`.
  if (child._mountIndex &lt; lastIndex) {
    return makeMove(child, afterNode, toIndex);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      for (name in nextChildren) {
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
var prevChild = prevChildren &amp;&amp; prevChildren[name];
var nextChild = nextChildren[name];
if (prevChild === nextChild) {
  updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">moveChild</span>(prevChild, lastPlacedNode, nextIndex, lastIndex
));
  lastIndex = Math.max(prevChild._mountIndex, lastIndex);
  prevChild._mountIndex = nextIndex;
} else {
  if (prevChild) {
    // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
    // The `removedNodes` loop below will actually remove the child.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.receiveComponent" id="apidoc.element.react-dom.ReactDOMComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextElement, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextElement, transaction, context) {
  var prevElement = this._currentElement;
  this._currentElement = nextElement;
  this.updateComponent(transaction, prevElement, nextElement, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.removeChild" id="apidoc.element.react-dom.ReactDOMComponent.prototype.removeChild">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>removeChild
        <span class="apidocSignatureSpan">(child, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeChild = function (child, node) {
  return makeRemove(child, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function removeChild(parentNode, childNode) {
if (Array.isArray(childNode)) {
  var closingComment = childNode[1];
  childNode = childNode[0];
  removeDelimitedText(parentNode, childNode, closingComment);
  parentNode.<span class="apidocCodeKeywordSpan">removeChild</span>(closingComment);
}
parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
var node = openingComment;
while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.unmountChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype.unmountChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>unmountChildren
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountChildren = function (safely) {
  var renderedChildren = this._renderedChildren;
  ReactChildReconciler.unmountChildren(renderedChildren, safely);
  this._renderedChildren = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * take advantage of React's reconciliation for styling and &lt;title&gt;
     * management. So we just document it and throw in dangerous cases.
     */
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;%s&gt; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &lt;html&gt;, &lt;head&gt;, and &lt;body
&gt;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.'
;, this._tag) : _prodInvariant('66', this._tag) : void 0;
    break;
}

this.<span class="apidocCodeKeywordSpan">unmountChildren</span>(safely);
ReactDOMComponentTree.uncacheNode(this);
EventPluginHub.deleteAllListeners(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.unmountComponent" id="apidoc.element.react-dom.ReactDOMComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (safely) {
  switch (this._tag) {
    case 'audio':
    case 'form':
    case 'iframe':
    case 'img':
    case 'link':
    case 'object':
    case 'source':
    case 'video':
      var listeners = this._wrapperState.listeners;
      if (listeners) {
        for (var i = 0; i &lt; listeners.length; i++) {
          listeners[i].remove();
        }
      }
      break;
    case 'html':
    case 'head':
    case 'body':
<span class="apidocCodeCommentSpan">      /**
       * Components like &lt;html&gt; &lt;head&gt; and &lt;body&gt; can't be removed or added
       * easily in a cross-browser way, however it's valuable to be able to
       * take advantage of React's reconciliation for styling and &lt;title&gt;
       * management. So we just document it and throw in dangerous cases.
       */
</span>      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;%s&gt; tried to unmount. Because of cross-browser quirks
it is impossible to unmount some top-level components (eg &lt;html&gt;, &lt;head&gt;, and &lt;body&gt;) reliably and efficiently. To fix this, have
 a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0
;
      break;
  }

  this.unmountChildren(safely);
  ReactDOMComponentTree.uncacheNode(this);
  EventPluginHub.deleteAllListeners(this);
  this._rootNodeID = 0;
  this._domID = 0;
  this._wrapperState = null;

  if (process.env.NODE_ENV !== 'production') {
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateChildren" id="apidoc.element.react-dom.ReactDOMComponent.prototype.updateChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateChildren
        <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateChildren = function (nextNestedChildrenElements, transaction, context) {
  // Hook used by React ART
  this._updateChildren(nextNestedChildrenElements, transaction, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextChildren = nextContent != null ? null : nextProps.children;

// If we're switching from children to content/html or vice versa, remove
// the old content
var lastHasContentOrHtml = lastContent != null || lastHtml != null;
var nextHasContentOrHtml = nextContent != null || nextHtml != null;
if (lastChildren != null &amp;&amp; nextChildren == null) {
  this.<span class="apidocCodeKeywordSpan">updateChildren</span>(null, transaction, context);
} else if (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) {
  this.updateTextContent('');
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateComponent" id="apidoc.element.react-dom.ReactDOMComponent.prototype.updateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateComponent
        <span class="apidocSignatureSpan">(transaction, prevElement, nextElement, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateComponent = function (transaction, prevElement, nextElement, context) {
  var lastProps = prevElement.props;
  var nextProps = this._currentElement.props;

  switch (this._tag) {
    case 'input':
      lastProps = ReactDOMInput.getHostProps(this, lastProps);
      nextProps = ReactDOMInput.getHostProps(this, nextProps);
      break;
    case 'option':
      lastProps = ReactDOMOption.getHostProps(this, lastProps);
      nextProps = ReactDOMOption.getHostProps(this, nextProps);
      break;
    case 'select':
      lastProps = ReactDOMSelect.getHostProps(this, lastProps);
      nextProps = ReactDOMSelect.getHostProps(this, nextProps);
      break;
    case 'textarea':
      lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
      nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
      break;
  }

  assertValidProps(this, nextProps);
  this._updateDOMProperties(lastProps, nextProps, transaction);
  this._updateDOMChildren(lastProps, nextProps, transaction, context);

  switch (this._tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      ReactDOMInput.updateWrapper(this);
      break;
    case 'textarea':
      ReactDOMTextarea.updateWrapper(this);
      break;
    case 'select':
      // &lt;select&gt; value update needs to occur after &lt;option&gt; children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
      break;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

receiveComponent: function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.<span class="apidocCodeKeywordSpan">updateComponent</span>(transaction, prevElement, nextElement, prevContext, nextContext
);
},

/**
 * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
 * is set, update the component.
 *
 * @param {ReactReconcileTransaction} transaction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateMarkup" id="apidoc.element.react-dom.ReactDOMComponent.prototype.updateMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateMarkup
        <span class="apidocSignatureSpan">(nextMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMarkup = function (nextMarkup) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.unmountChildren(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant
('118') : void 0;
    }
  }
  var updates = [makeSetMarkup(nextMarkup)];
  processQueue(this, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.updateTextContent('' + nextContent);
    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, nextContent);
    }
  }
} else if (nextHtml != null) {
  if (lastHtml !== nextHtml) {
    this.<span class="apidocCodeKeywordSpan">updateMarkup</span>('' + nextHtml);
  }
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
} else if (nextChildren != null) {
  if (process.env.NODE_ENV !== 'production') {
    setAndValidateContentChildDev.call(this, null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponent.prototype.updateTextContent" id="apidoc.element.react-dom.ReactDOMComponent.prototype.updateTextContent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponent.prototype.</span>updateTextContent
        <span class="apidocSignatureSpan">(nextContent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTextContent = function (nextContent) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.unmountChildren(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant
('118') : void 0;
    }
  }
  // Set new text content.
  var updates = [makeTextContent(nextContent)];
  processQueue(this, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we're switching from children to content/html or vice versa, remove
// the old content
var lastHasContentOrHtml = lastContent != null || lastHtml != null;
var nextHasContentOrHtml = nextContent != null || nextHtml != null;
if (lastChildren != null &amp;&amp; nextChildren == null) {
  this.updateChildren(null, transaction, context);
} else if (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) {
  this.<span class="apidocCodeKeywordSpan">updateTextContent</span>('');
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
}

if (nextContent != null) {
  if (lastContent !== nextContent) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMComponentTree" id="apidoc.module.react-dom.ReactDOMComponentTree">module react-dom.ReactDOMComponentTree</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.getClosestInstanceFromNode" id="apidoc.element.react-dom.ReactDOMComponentTree.getClosestInstanceFromNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getClosestInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node &amp;&amp; (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var from;
var to;
if (topLevelType === 'topMouseOut') {
  from = targetInst;
  var related = nativeEvent.relatedTarget || nativeEvent.toElement;
  to = related ? ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getClosestInstanceFromNode</span>(related) : null;
} else {
  // Moving to a node from outside the window.
  from = null;
  to = targetInst;
}

if (from === to) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.getInstanceFromNode" id="apidoc.element.react-dom.ReactDOMComponentTree.getInstanceFromNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null &amp;&amp; inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getInstanceFromNode</span>(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.getNodeFromInstance" id="apidoc.element.react-dom.ReactDOMComponentTree.getNodeFromInstance">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>getNodeFromInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument
.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node
reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getNodeFromInstance</span>(this));
  }
};

module.exports = AutoFocusUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.precacheChildNodes" id="apidoc.element.react-dom.ReactDOMComponentTree.precacheChildNodes">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>precacheChildNodes
        <span class="apidocSignatureSpan">(inst, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function precacheChildNodes(inst, node) {
  if (inst._flags &amp; Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant
('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.precacheNode" id="apidoc.element.react-dom.ReactDOMComponentTree.precacheNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>precacheNode
        <span class="apidocSignatureSpan">(inst, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // See discussion in https://github.com/facebook/react/pull/6896
    // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
    el = ownerDocument.createElement(this._currentElement.type);
  }
} else {
  el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
}
ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">precacheNode</span>(this, el);
this._flags |= Flags.hasCachedChildNodes;
if (!this._hostParent) {
  DOMPropertyOperations.setAttributeForRoot(el);
}
this._updateDOMProperties(null, props, transaction);
var lazyTree = DOMLazyTree(el);
this._createInitialChildren(transaction, props, context, lazyTree);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMComponentTree.uncacheNode" id="apidoc.element.react-dom.ReactDOMComponentTree.uncacheNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMComponentTree.</span>uncacheNode
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * management. So we just document it and throw in dangerous cases.
     */
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;%s&gt; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &lt;html&gt;, &lt;head&gt;, and &lt;body
&gt;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.'
;, this._tag) : _prodInvariant('66', this._tag) : void 0;
    break;
}

this.unmountChildren(safely);
ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">uncacheNode</span>(this);
EventPluginHub.deleteAllListeners(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev.call(this, null);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMEmptyComponent" id="apidoc.module.react-dom.ReactDOMEmptyComponent">module react-dom.ReactDOMEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent.ReactDOMEmptyComponent" id="apidoc.element.react-dom.ReactDOMEmptyComponent.ReactDOMEmptyComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMEmptyComponent
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMEmptyComponent.prototype" id="apidoc.module.react-dom.ReactDOMEmptyComponent.prototype">module react-dom.ReactDOMEmptyComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.getHostNode" id="apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactDOMComponentTree.getNodeFromInstance(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.mountComponent" id="apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  var domID = hostContainerInfo._idCounter++;
  this._domID = domID;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var nodeValue = ' react-empty: ' + this._domID + ' ';
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var node = ownerDocument.createComment(nodeValue);
    ReactDOMComponentTree.precacheNode(this, node);
    return DOMLazyTree(node);
  } else {
    if (transaction.renderToStaticMarkup) {
      // Normally we'd insert a comment node, but since this is a situation
      // where React won't take over (static pages), we can simply return
      // nothing.
      return '';
    }
    return '&lt;!--' + nodeValue + '--&gt;';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.receiveComponent" id="apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.unmountComponent" id="apidoc.element.react-dom.ReactDOMEmptyComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMEmptyComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  ReactDOMComponentTree.uncacheNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMIDOperations" id="apidoc.module.react-dom.ReactDOMIDOperations">module react-dom.ReactDOMIDOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates" id="apidoc.element.react-dom.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMIDOperations.</span>dangerouslyProcessChildrenUpdates
        <span class="apidocSignatureSpan">(parentInst, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyProcessChildrenUpdates = function (parentInst, updates) {
  var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
  DOMChildrenOperations.processUpdates(node, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMInput" id="apidoc.module.react-dom.ReactDOMInput">module react-dom.ReactDOMInput</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInput.getHostProps" id="apidoc.element.react-dom.ReactDOMInput.getHostProps">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  var value = LinkedValueUtils.getValue(props);
  var checked = LinkedValueUtils.getChecked(props);

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min &amp; .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : inst._wrapperState.initialValue,
    checked: checked != null ? checked : inst._wrapperState.initialChecked,
    onChange: inst._wrapperState.onChange
  });

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case 'select':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInput.mountWrapper" id="apidoc.element.react-dom.ReactDOMInput.mountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== 'production') {
    LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

    var owner = inst._currentElement._owner;

    if (props.valueLink !== undefined &amp;&amp; !didWarnValueLink) {
      process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange
` instead.') : void 0;
      didWarnValueLink = true;
    }
    if (props.checkedLink !== undefined &amp;&amp; !didWarnCheckedLink) {
      process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange
` instead.') : void 0;
      didWarnCheckedLink = true;
    }
    if (props.checked !== undefined &amp;&amp; props.defaultChecked !== undefined &amp;&amp; !didWarnCheckedDefaultChecked) {
      process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked
 props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked
 prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More
 info: ' + 'https://fb.me/react-controlled-components', owner &amp;&amp; owner.getName() || 'A component', props.type) : void 0;
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props
. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but
 not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + '
https://fb.me/react-controlled-components', owner &amp;&amp; owner.getName() || 'A component', props.type) : void 0;
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  inst._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    listeners: null,
    onChange: _handleChange.bind(inst),
    controlled: isControlled(props)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'video':
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInput.postMountWrapper" id="apidoc.element.react-dom.ReactDOMInput.postMountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  var props = inst._currentElement.props;

  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var node = ReactDOMComponentTree.getNodeFromInstance(inst);

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values &amp; defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInput.updateWrapper" id="apidoc.element.react-dom.ReactDOMInput.updateWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInput.</span>updateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateWrapper = function (inst) {
  var props = inst._currentElement.props;

  if (process.env.NODE_ENV !== 'production') {
    var controlled = isControlled(props);
    var owner = inst._currentElement._owner;

    if (!inst._wrapperState.controlled &amp;&amp; controlled &amp;&amp; !didWarnUncontrolledToControlled) {
      process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + '
Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled
 input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner &amp;&amp; owner.getName
() || 'A component', props.type) : void 0;
      didWarnUncontrolledToControlled = true;
    }
    if (inst._wrapperState.controlled &amp;&amp; !controlled &amp;&amp; !didWarnControlledToUncontrolled) {
      process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + '
Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled
 input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner &amp;&amp; owner.getName
() || 'A component', props.type) : void 0;
      didWarnControlledToUncontrolled = true;
    }
  }

  // TODO: Shouldn't this be getChecked(props)?
  var checked = props.checked;
  if (checked != null) {
    DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
  }

  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    if (value === 0 &amp;&amp; node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value, 10) || 0;

      // eslint-disable-next-line
      if (value != valueAsNumber) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
      // eslint-disable-next-line
    } else if (value != node.value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null &amp;&amp; props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value &lt;x&gt; is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null &amp;&amp; props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._updateDOMChildren(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case 'input':
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.<span class="apidocCodeKeywordSpan">updateWrapper</span>(this);
    break;
  case 'textarea':
    ReactDOMTextarea.updateWrapper(this);
    break;
  case 'select':
    // &lt;select&gt; value update needs to occur after &lt;option&gt; children
    // reconciliation
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMInvalidARIAHook" id="apidoc.module.react-dom.ReactDOMInvalidARIAHook">module react-dom.ReactDOMInvalidARIAHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeMountComponent" id="apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInvalidARIAHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  if (process.env.NODE_ENV !== 'production') {
    handleElement(debugID, element);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(contentDebugID, content,
debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeUpdateComponent" id="apidoc.element.react-dom.ReactDOMInvalidARIAHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMInvalidARIAHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  if (process.env.NODE_ENV !== 'production') {
    handleElement(debugID, element);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._contentDebugID = null;
    return;
  }

  validateDOMNesting(null, String(content), this, this._ancestorInfo);
  this._contentDebugID = contentDebugID;
  if (hasExistingContent) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(contentDebugID, content);
    ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
  } else {
    ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMNullInputValuePropHook" id="apidoc.module.react-dom.ReactDOMNullInputValuePropHook">module react-dom.ReactDOMNullInputValuePropHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeMountComponent" id="apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMNullInputValuePropHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(contentDebugID, content,
debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent" id="apidoc.element.react-dom.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMNullInputValuePropHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._contentDebugID = null;
    return;
  }

  validateDOMNesting(null, String(content), this, this._ancestorInfo);
  this._contentDebugID = contentDebugID;
  if (hasExistingContent) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(contentDebugID, content);
    ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
  } else {
    ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMOption" id="apidoc.module.react-dom.ReactDOMOption">module react-dom.ReactDOMOption</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMOption.getHostProps" id="apidoc.element.react-dom.ReactDOMOption.getHostProps">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  var hostProps = _assign({ selected: undefined, children: undefined }, props);

  // Read state only from initial mount because &lt;select&gt; updates value
  // manually; we need the initial state only for server rendering
  if (inst._wrapperState.selected != null) {
    hostProps.selected = inst._wrapperState.selected;
  }

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case 'select':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMOption.mountWrapper" id="apidoc.element.react-dom.ReactDOMOption.mountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props, hostParent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props, hostParent) {
  // TODO (yungsters): Remove support for `selected` in &lt;option&gt;.
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on &lt;select&gt;
instead of ' + 'setting `selected` on &lt;option&gt;.') : void 0;
  }

  // Look up whether this option is 'selected'
  var selectValue = null;
  if (hostParent != null) {
    var selectParent = hostParent;

    if (selectParent._tag === 'optgroup') {
      selectParent = selectParent._hostParent;
    }

    if (selectParent != null &amp;&amp; selectParent._tag === 'select') {
      selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
    }
  }

  // If the value is null (e.g., no specified value or after initial mount)
  // or missing (e.g., for &lt;datalist&gt;), we don't change props.selected
  var selected = null;
  if (selectValue != null) {
    var value;
    if (props.value != null) {
      value = props.value + '';
    } else {
      value = flattenChildren(props.children);
    }
    selected = false;
    if (Array.isArray(selectValue)) {
      // multiple
      for (var i = 0; i &lt; selectValue.length; i++) {
        if ('' + selectValue[i] === value) {
          selected = true;
          break;
        }
      }
    } else {
      selected = '' + selectValue === value;
    }
  }

  inst._wrapperState = { selected: selected };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'video':
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMOption.postMountWrapper" id="apidoc.element.react-dom.ReactDOMOption.postMountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMOption.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  // value="" should make a value attribute (#6219)
  var props = inst._currentElement.props;
  if (props.value != null) {
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    node.setAttribute('value', props.value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMSelect" id="apidoc.module.react-dom.ReactDOMSelect">module react-dom.ReactDOMSelect</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelect.getHostProps" id="apidoc.element.react-dom.ReactDOMSelect.getHostProps">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  return _assign({}, props, {
    onChange: inst._wrapperState.onChange,
    value: undefined
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case 'select':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelect.getSelectValueContext" id="apidoc.element.react-dom.ReactDOMSelect.getSelectValueContext">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>getSelectValueContext
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelectValueContext = function (inst) {
  // ReactDOMOption looks at this initial value so the initial generated
  // markup has correct `selected` attributes
  return inst._wrapperState.initialValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var selectParent = hostParent;

  if (selectParent._tag === 'optgroup') {
    selectParent = selectParent._hostParent;
  }

  if (selectParent != null &amp;&amp; selectParent._tag === 'select') {
    selectValue = ReactDOMSelect.<span class="apidocCodeKeywordSpan">getSelectValueContext</span>(selectParent);
  }
}

// If the value is null (e.g., no specified value or after initial mount)
// or missing (e.g., for &lt;datalist&gt;), we don't change props.selected
var selected = null;
if (selectValue != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelect.mountWrapper" id="apidoc.element.react-dom.ReactDOMSelect.mountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== 'production') {
    checkSelectPropTypes(inst, props);
  }

  var value = LinkedValueUtils.getValue(props);
  inst._wrapperState = {
    pendingUpdate: false,
    initialValue: value != null ? value : props.defaultValue,
    listeners: null,
    onChange: _handleChange.bind(inst),
    wasMultiple: Boolean(props.multiple)
  };

  if (props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValueDefaultValue) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify
 either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + '
element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
    didWarnValueDefaultValue = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'video':
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelect.postUpdateWrapper" id="apidoc.element.react-dom.ReactDOMSelect.postUpdateWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelect.</span>postUpdateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postUpdateWrapper = function (inst) {
  var props = inst._currentElement.props;

  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  inst._wrapperState.initialValue = undefined;

  var wasMultiple = inst._wrapperState.wasMultiple;
  inst._wrapperState.wasMultiple = Boolean(props.multiple);

  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    inst._wrapperState.pendingUpdate = false;
    updateOptions(inst, Boolean(props.multiple), value);
  } else if (wasMultiple !== Boolean(props.multiple)) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(inst, Boolean(props.multiple), props.defaultValue);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case 'textarea':
    inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
    break;
}
}

function postUpdateSelectWrapper() {
ReactDOMSelect.<span class="apidocCodeKeywordSpan">postUpdateWrapper</span>(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
'area': true,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMSelection" id="apidoc.module.react-dom.ReactDOMSelection">module react-dom.ReactDOMSelection</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelection.getOffsets" id="apidoc.element.react-dom.ReactDOMSelection.getOffsets">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelection.</span>getOffsets
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getModernOffsets(node) {
  var selection = window.getSelection &amp;&amp; window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an &lt;input type="number"&gt;. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
<span class="apidocCodeCommentSpan">    /* eslint-disable no-unused-expressions */
</span>    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset
);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset
);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      selection = {
        start: -range.moveStart('character', -input.value.length),
        end: -range.moveEnd('character', -input.value.length)
      };
    }
  } else {
    // Content editable or old IE textarea.
    selection = ReactDOMSelection.<span class="apidocCodeKeywordSpan">getOffsets</span>(input);
  }

  return selection || { start: 0, end: 0 };
},

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMSelection.setOffsets" id="apidoc.element.react-dom.ReactDOMSelection.setOffsets">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMSelection.</span>setOffsets
        <span class="apidocSignatureSpan">(node, offsets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend &amp;&amp; start &gt; end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker &amp;&amp; endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start &gt; end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (document.selection &amp;&amp; input.nodeName &amp;&amp; input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.<span class="apidocCodeKeywordSpan">setOffsets</span>(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMServer" id="apidoc.module.react-dom.ReactDOMServer">module react-dom.ReactDOMServer</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMServer.renderToStaticMarkup" id="apidoc.element.react-dom.ReactDOMServer.renderToStaticMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMServer.</span>renderToStaticMarkup
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToStaticMarkup(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass
 a valid ReactElement.') : _prodInvariant('47') : void 0;
  return renderToStringImpl(element, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMServer.renderToString" id="apidoc.element.react-dom.ReactDOMServer.renderToString">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMServer.</span>renderToString
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToString(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid
 ReactElement.') : _prodInvariant('46') : void 0;
  return renderToStringImpl(element, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello World&lt;/div&gt;;
  }
}

ReactDOMServer.<span class="apidocCodeKeywordSpan">renderToString</span>(&lt;MyComponent /&gt;);
```

## API

### `react-dom`

- `findDOMNode`
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMTextComponent" id="apidoc.module.react-dom.ReactDOMTextComponent">module react-dom.ReactDOMTextComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent.ReactDOMTextComponent" id="apidoc.element.react-dom.ReactDOMTextComponent.ReactDOMTextComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactDOMTextComponent
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMTextComponent.prototype" id="apidoc.module.react-dom.ReactDOMTextComponent.prototype">module react-dom.ReactDOMTextComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.getHostNode" id="apidoc.element.react-dom.ReactDOMTextComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  var hostNode = this._commentNodes;
  if (hostNode) {
    return hostNode;
  }
  if (!this._closingComment) {
    var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
    var node = openingComment.nextSibling;
    while (true) {
      !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s',
this._domID) : _prodInvariant('67', this._domID) : void 0;
      if (node.nodeType === 8 &amp;&amp; node.nodeValue === ' /react-text ') {
        this._closingComment = node;
        break;
      }
      node = node.nextSibling;
    }
  }
  hostNode = [this._hostNode, this._closingComment];
  this._commentNodes = hostNode;
  return hostNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.mountComponent" id="apidoc.element.react-dom.ReactDOMTextComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  if (process.env.NODE_ENV !== 'production') {
    var parentInfo;
    if (hostParent != null) {
      parentInfo = hostParent._ancestorInfo;
    } else if (hostContainerInfo != null) {
      parentInfo = hostContainerInfo._ancestorInfo;
    }
    if (parentInfo) {
      // parentInfo should always be present except for the top-level
      // component when server rendering
      validateDOMNesting(null, this._stringText, this, parentInfo);
    }
  }

  var domID = hostContainerInfo._idCounter++;
  var openingValue = ' react-text: ' + domID + ' ';
  var closingValue = ' /react-text ';
  this._domID = domID;
  this._hostParent = hostParent;
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var openingComment = ownerDocument.createComment(openingValue);
    var closingComment = ownerDocument.createComment(closingValue);
    var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
    DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
    if (this._stringText) {
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
    }
    DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
    ReactDOMComponentTree.precacheNode(this, openingComment);
    this._closingComment = closingComment;
    return lazyTree;
  } else {
    var escapedText = escapeTextContentForBrowser(this._stringText);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this between comment nodes for the reasons stated
      // above, but since this is a situation where React won't take over
      // (static pages), we can simply return the text as it is.
      return escapedText;
    }

    return '&lt;!--' + openingValue + '--&gt;' + escapedText + '&lt;!--' + closingValue + '--&gt;';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.receiveComponent" id="apidoc.element.react-dom.ReactDOMTextComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextText, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextText, transaction) {
  if (nextText !== this._currentElement) {
    this._currentElement = nextText;
    var nextStringText = '' + nextText;
    if (nextStringText !== this._stringText) {
      // TODO: Save this as pending props and use performUpdateIfNecessary
      // and/or updateComponent to do the actual update for consistency with
      // other component types?
      this._stringText = nextStringText;
      var commentNodes = this.getHostNode();
      DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextComponent.prototype.unmountComponent" id="apidoc.element.react-dom.ReactDOMTextComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  this._closingComment = null;
  this._commentNodes = null;
  ReactDOMComponentTree.uncacheNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMTextarea" id="apidoc.module.react-dom.ReactDOMTextarea">module react-dom.ReactDOMTextarea</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextarea.getHostProps" id="apidoc.element.react-dom.ReactDOMTextarea.getHostProps">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML`
does not make sense on &lt;textarea&gt;.') : _prodInvariant('91') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
  // The value can be a boolean or object so that's why it's forced to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + inst._wrapperState.initialValue,
    onChange: inst._wrapperState.onChange
  });

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case 'select':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextarea.mountWrapper" id="apidoc.element.react-dom.ReactDOMTextarea.mountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== 'production') {
    LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
    if (props.valueLink !== undefined &amp;&amp; !didWarnValueLink) {
      process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange
` instead.') : void 0;
      didWarnValueLink = true;
    }
    if (props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValDefaultVal) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(
specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea
 ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValDefaultVal = true;
    }
  }

  var value = LinkedValueUtils.getValue(props);
  var initialValue = value;

  // Only bother fetching default value if we're going to use it
  if (value == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in &lt;textarea&gt;.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + '
children on &lt;textarea&gt;.') : void 0;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a &lt;textarea
&gt;, do not pass children.') : _prodInvariant('92') : void 0;
      if (Array.isArray(children)) {
        !(children.length &lt;= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '&lt;textarea&gt; can only have at most one
 child.') : _prodInvariant('93') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  inst._wrapperState = {
    initialValue: '' + initialValue,
    listeners: null,
    onChange: _handleChange.bind(inst)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'video':
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'input':
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case 'option':
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextarea.postMountWrapper" id="apidoc.element.react-dom.ReactDOMTextarea.postMountWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === inst._wrapperState.initialValue) {
    node.value = textContent;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTextarea.updateWrapper" id="apidoc.element.react-dom.ReactDOMTextarea.updateWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTextarea.</span>updateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateWrapper = function (inst) {
  var props = inst._currentElement.props;

  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._updateDOMChildren(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case 'input':
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.<span class="apidocCodeKeywordSpan">updateWrapper</span>(this);
    break;
  case 'textarea':
    ReactDOMTextarea.updateWrapper(this);
    break;
  case 'select':
    // &lt;select&gt; value update needs to occur after &lt;option&gt; children
    // reconciliation
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMTreeTraversal" id="apidoc.module.react-dom.ReactDOMTreeTraversal">module react-dom.ReactDOMTreeTraversal</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTreeTraversal.getLowestCommonAncestor" id="apidoc.element.react-dom.ReactDOMTreeTraversal.getLowestCommonAncestor">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>getLowestCommonAncestor
        <span class="apidocSignatureSpan">(instA, instB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') :
_prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') :
_prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB &gt; 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA &gt; 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getLowestCommonAncestor</span>(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTreeTraversal.getParentInstance" id="apidoc.element.react-dom.ReactDOMTreeTraversal.getParentInstance">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>getParentInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getParentInstance(inst) {
  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant
('36') : void 0;

  return inst._hostParent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getParentInstance</span>(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTreeTraversal.isAncestor" id="apidoc.element.react-dom.ReactDOMTreeTraversal.isAncestor">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>isAncestor
        <span class="apidocSignatureSpan">(instA, instB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant
('35') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant
('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getInstanceFromNode: function (node) {
  return ComponentTree.getInstanceFromNode(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">isAncestor</span>(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTreeTraversal.traverseEnterLeave" id="apidoc.element.react-dom.ReactDOMTreeTraversal.traverseEnterLeave">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>traverseEnterLeave
        <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from &amp;&amp; to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from &amp;&amp; from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to &amp;&amp; to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i &lt; pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- &gt; 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseEnterLeave</span>(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMTreeTraversal.traverseTwoPhase" id="apidoc.element.react-dom.ReactDOMTreeTraversal.traverseTwoPhase">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMTreeTraversal.</span>traverseTwoPhase
        <span class="apidocSignatureSpan">(inst, fn, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- &gt; 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i &lt; path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseTwoPhase</span>(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDOMUnknownPropertyHook" id="apidoc.module.react-dom.ReactDOMUnknownPropertyHook">module react-dom.ReactDOMUnknownPropertyHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeMountComponent" id="apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMUnknownPropertyHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(contentDebugID, content,
debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent" id="apidoc.element.react-dom.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDOMUnknownPropertyHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._contentDebugID = null;
    return;
  }

  validateDOMNesting(null, String(content), this, this._ancestorInfo);
  this._contentDebugID = contentDebugID;
  if (hasExistingContent) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(contentDebugID, content);
    ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
  } else {
    ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDebugTool" id="apidoc.module.react-dom.ReactDebugTool">module react-dom.ReactDebugTool</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.addDevtool" id="apidoc.element.react-dom.ReactDebugTool.addDevtool">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>addDevtool
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDevtool = function (hook) {
  hooks.push(hook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.addHook" id="apidoc.element.react-dom.ReactDebugTool.addHook">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>addHook
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHook = function (hook) {
  hooks.push(hook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (isProfiling) {
  return;
}

isProfiling = true;
flushHistory.length = 0;
resetMeasurements();
ReactDebugTool.<span class="apidocCodeKeywordSpan">addHook</span>(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
if (!isProfiling) {
  return;
}

isProfiling = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.beginProfiling" id="apidoc.element.react-dom.ReactDebugTool.beginProfiling">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>beginProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginProfiling = function () {
  if (isProfiling) {
    return;
  }

  isProfiling = true;
  flushHistory.length = 0;
  resetMeasurements();
  ReactDebugTool.addHook(ReactHostOperationHistoryHook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM &amp;&amp; window.location.href || '';
if (/[?&amp;]react_perf\b/.test(url)) {
  ReactDebugTool.<span class="apidocCodeKeywordSpan">beginProfiling</span>();
}

module.exports = ReactDebugTool;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.endProfiling" id="apidoc.element.react-dom.ReactDebugTool.endProfiling">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>endProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endProfiling = function () {
  if (!isProfiling) {
    return;
  }

  isProfiling = false;
  resetMeasurements();
  ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function stop() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
  return;
}

ReactDebugTool.<span class="apidocCodeKeywordSpan">endProfiling</span>();
}

function isRunning() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.getFlushHistory" id="apidoc.element.react-dom.ReactDebugTool.getFlushHistory">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>getFlushHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFlushHistory = function () {
  return flushHistory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getLastMeasurements() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
  return [];
}

return ReactDebugTool.<span class="apidocCodeKeywordSpan">getFlushHistory</span>();
}

function getExclusive() {
var flushHistory = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.isProfiling" id="apidoc.element.react-dom.ReactDebugTool.isProfiling">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>isProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProfiling = function () {
  return isProfiling;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function isRunning() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
  return false;
}

return ReactDebugTool.<span class="apidocCodeKeywordSpan">isProfiling</span>();
}

var ReactPerfAnalysis = {
getLastMeasurements: getLastMeasurements,
getExclusive: getExclusive,
getInclusive: getInclusive,
getWasted: getWasted,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeforeMountComponent" id="apidoc.element.react-dom.ReactDebugTool.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element, parentDebugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element, parentDebugID) {
  checkDebugID(debugID);
  checkDebugID(parentDebugID, true);
  emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
  markBegin(debugID, 'mount');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(contentDebugID, content,
debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeforeUnmountComponent" id="apidoc.element.react-dom.ReactDebugTool.onBeforeUnmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeUnmountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUnmountComponent = function (debugID) {
  checkDebugID(debugID);
  emitEvent('onBeforeUnmountComponent', debugID);
  markBegin(debugID, 'unmount');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @final
 * @internal
 */
unmountComponent: function (internalInstance, safely) {
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUnmountComponent</span>(internalInstance._debugID
);
    }
  }
  ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeforeUpdateComponent" id="apidoc.element.react-dom.ReactDebugTool.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  checkDebugID(debugID);
  emitEvent('onBeforeUpdateComponent', debugID, element);
  markBegin(debugID, 'update');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._contentDebugID = null;
    return;
  }

  validateDOMNesting(null, String(content), this, this._ancestorInfo);
  this._contentDebugID = contentDebugID;
  if (hasExistingContent) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(contentDebugID, content);
    ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
  } else {
    ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeginFlush" id="apidoc.element.react-dom.ReactDebugTool.onBeginFlush">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginFlush = function () {
  currentFlushNesting++;
  resetMeasurements();
  pauseCurrentLifeCycleTimer();
  emitEvent('onBeginFlush');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginFlush</span>();
}
ReactReconciler.unmountComponent(instance, safely);
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.onEndFlush();
}

if (container.nodeType === DOC_NODE_TYPE) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeginLifeCycleTimer" id="apidoc.element.react-dom.ReactDebugTool.onBeginLifeCycleTimer">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginLifeCycleTimer
        <span class="apidocSignatureSpan">(debugID, timerType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginLifeCycleTimer = function (debugID, timerType) {
  checkDebugID(debugID);
  emitEvent('onBeginLifeCycleTimer', debugID, timerType);
  markBegin(debugID, timerType);
  beginLifeCycleTimer(debugID, timerType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginLifeCycleTimer</span>(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onBeginProcessingChildContext" id="apidoc.element.react-dom.ReactDebugTool.onBeginProcessingChildContext">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onBeginProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginProcessingChildContext = function () {
  emitEvent('onBeginProcessingChildContext');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _processChildContext: function (currentContext) {
var Component = this._currentElement.type;
var inst = this._instance;
var childContext;

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginProcessingChildContext</span>();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.onEndProcessingChildContext();
    }
  } else {
    childContext = inst.getChildContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onEndFlush" id="apidoc.element.react-dom.ReactDebugTool.onEndFlush">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndFlush = function () {
  resetMeasurements();
  currentFlushNesting--;
  resumeCurrentLifeCycleTimer();
  emitEvent('onEndFlush');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function unmountComponentFromNode(instance, container, safely) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.onBeginFlush();
}
ReactReconciler.unmountComponent(instance, safely);
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndFlush</span>();
}

if (container.nodeType === DOC_NODE_TYPE) {
  container = container.documentElement;
}

// http://jsperf.com/emptying-a-node
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onEndLifeCycleTimer" id="apidoc.element.react-dom.ReactDebugTool.onEndLifeCycleTimer">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndLifeCycleTimer
        <span class="apidocSignatureSpan">(debugID, timerType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndLifeCycleTimer = function (debugID, timerType) {
  checkDebugID(debugID);
  endLifeCycleTimer(debugID, timerType);
  markEnd(debugID, timerType);
  emitEvent('onEndLifeCycleTimer', debugID, timerType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return fn();
 }

 ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
 try {
   return fn();
 } finally {
   ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndLifeCycleTimer</span>(debugID, timerType);
 }
}

/**
* ------------------ The Life-Cycle of a Composite Component ------------------
*
* - constructor: Initialization of state. The instance is now retained.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onEndProcessingChildContext" id="apidoc.element.react-dom.ReactDebugTool.onEndProcessingChildContext">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onEndProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndProcessingChildContext = function () {
  emitEvent('onEndProcessingChildContext');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginProcessingChildContext();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndProcessingChildContext</span>();
    }
  } else {
    childContext = inst.getChildContext();
  }
}

if (childContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onHostOperation" id="apidoc.element.react-dom.ReactDebugTool.onHostOperation">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onHostOperation
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onHostOperation = function (operation) {
  checkDebugID(operation.instanceID);
  emitEvent('onHostOperation', operation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onHostOperation</span>({
    instanceID: component._debugID,
    type: 'update styles',
    payload: styles
  });
}

var style = node.style;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onMountComponent" id="apidoc.element.react-dom.ReactDebugTool.onMountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onMountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onMountComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, 'mount');
  emitEvent('onMountComponent', debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onMountComponent</span>(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onSetChildren" id="apidoc.element.react-dom.ReactDebugTool.onSetChildren">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onSetChildren
        <span class="apidocSignatureSpan">(debugID, childDebugIDs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetChildren = function (debugID, childDebugIDs) {
  checkDebugID(debugID);
  childDebugIDs.forEach(checkDebugID);
  emitEvent('onSetChildren', debugID, childDebugIDs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._renderedComponent = child;

  var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);

  if (process.env.NODE_ENV !== 'production') {
    if (debugID !== 0) {
      var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetChildren</span>(debugID, childDebugIDs);
    }
  }

  return markup;
},

getHostNode: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onSetState" id="apidoc.element.react-dom.ReactDebugTool.onSetState">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onSetState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetState = function () {
  emitEvent('onSetState');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetState</span>();
  process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or
 null state object; ' + 'instead, use forceUpdate().') : void 0;
}

var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

if (!internalInstance) {
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onTestEvent" id="apidoc.element.react-dom.ReactDebugTool.onTestEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onTestEvent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onTestEvent = function () {
  emitEvent('onTestEvent');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onUnmountComponent" id="apidoc.element.react-dom.ReactDebugTool.onUnmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onUnmountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onUnmountComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, 'unmount');
  emitEvent('onUnmountComponent', debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var hasExistingContent = this._contentDebugID != null;
var debugID = this._debugID;
// This ID represents the inlined child that has no backing instance:
var contentDebugID = -debugID;

if (content == null) {
  if (hasExistingContent) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onUnmountComponent</span>(this._contentDebugID);
  }
  this._contentDebugID = null;
  return;
}

validateDOMNesting(null, String(content), this, this._ancestorInfo);
this._contentDebugID = contentDebugID;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.onUpdateComponent" id="apidoc.element.react-dom.ReactDebugTool.onUpdateComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>onUpdateComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onUpdateComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, 'update');
  emitEvent('onUpdateComponent', debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onUpdateComponent</span>(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.removeDevtool" id="apidoc.element.react-dom.ReactDebugTool.removeDevtool">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>removeDevtool
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDevtool = function (hook) {
  for (var i = 0; i &lt; hooks.length; i++) {
    if (hooks[i] === hook) {
      hooks.splice(i, 1);
      i--;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactDebugTool.removeHook" id="apidoc.element.react-dom.ReactDebugTool.removeHook">
        function <span class="apidocSignatureSpan">react-dom.ReactDebugTool.</span>removeHook
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeHook = function (hook) {
  for (var i = 0; i &lt; hooks.length; i++) {
    if (hooks[i] === hook) {
      hooks.splice(i, 1);
      i--;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
endProfiling: function () {
  if (!isProfiling) {
    return;
  }

  isProfiling = false;
  resetMeasurements();
  ReactDebugTool.<span class="apidocCodeKeywordSpan">removeHook</span>(ReactHostOperationHistoryHook);
},
getFlushHistory: function () {
  return flushHistory;
},
onBeginFlush: function () {
  currentFlushNesting++;
  resetMeasurements();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDefaultBatchingStrategy" id="apidoc.module.react-dom.ReactDefaultBatchingStrategy">module react-dom.ReactDefaultBatchingStrategy</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactDefaultBatchingStrategy.batchedUpdates" id="apidoc.element.react-dom.ReactDefaultBatchingStrategy.batchedUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactDefaultBatchingStrategy.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batchedUpdates = function (callback, a, b, c, d, e) {
  var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

  ReactDefaultBatchingStrategy.isBatchingUpdates = true;

  // The code is written this way to avoid extra allocations
  if (alreadyBatchingUpdates) {
    return callback(a, b, c, d, e);
  } else {
    return transaction.perform(callback, null, a, b, c, d, e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactDefaultInjection" id="apidoc.module.react-dom.ReactDefaultInjection">module react-dom.ReactDefaultInjection</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactDefaultInjection.inject" id="apidoc.element.react-dom.ReactDefaultInjection.inject">
        function <span class="apidocSignatureSpan">react-dom.ReactDefaultInjection.</span>inject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

<span class="apidocCodeCommentSpan">  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
</span>  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

'use strict';

var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactServerRendering = require('./ReactServerRendering');
var ReactVersion = require('./ReactVersion');

ReactDefaultInjection.<span class="apidocCodeKeywordSpan">inject</span>();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  version: ReactVersion
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactEmptyComponent" id="apidoc.module.react-dom.ReactEmptyComponent">module react-dom.ReactEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactEmptyComponent.create" id="apidoc.element.react-dom.ReactEmptyComponent.create">
        function <span class="apidocSignatureSpan">react-dom.ReactEmptyComponent.</span>create
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (instantiate) {
  return emptyComponentFactory(instantiate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
if (isProxySupported) {
  /*eslint-disable no-func-assign */
  SyntheticEvent = new Proxy(SyntheticEvent, {
    construct: function (target, args) {
      return this.apply(target, Object.<span class="apidocCodeKeywordSpan">create</span>(target.prototype), args);
    },
    apply: function (constructor, that, args) {
      return new Proxy(constructor.apply(that, args), {
        set: function (target, prop, value) {
          if (prop !== 'isPersistent' &amp;&amp; !target.constructor.Interface.hasOwnProperty(prop) &amp;&amp; shouldBeReleasedProperties
.indexOf(prop) === -1) {
            process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), '
;This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
            didWarnForAddedNewProperty = true;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactErrorUtils" id="apidoc.module.react-dom.ReactErrorUtils">module react-dom.ReactErrorUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallback" id="apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallback">
        function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>invokeGuardedCallback
        <span class="apidocSignatureSpan">(name, func, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
function executeDispatch(event, simulated, listener, inst) {
 var type = event.type || 'unknown-event';
 event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
 if (simulated) {
   ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
 } else {
   ReactErrorUtils.<span class="apidocCodeKeywordSpan">invokeGuardedCallback</span>(type, listener, event);
 }
 event.currentTarget = null;
}

/**
* Standard/simple iteration through an event's collected dispatches.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallbackWithCatch" id="apidoc.element.react-dom.ReactErrorUtils.invokeGuardedCallbackWithCatch">
        function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>invokeGuardedCallbackWithCatch
        <span class="apidocSignatureSpan">(name, func, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.<span class="apidocCodeKeywordSpan">invokeGuardedCallbackWithCatch</span>(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactErrorUtils.rethrowCaughtError" id="apidoc.element.react-dom.ReactErrorUtils.rethrowCaughtError">
        function <span class="apidocSignatureSpan">react-dom.ReactErrorUtils.</span>rethrowCaughtError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rethrowCaughtError = function () {
  if (caughtError) {
    var error = caughtError;
    caughtError = null;
    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events
 were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95&amp;#
x27;) : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.<span class="apidocCodeKeywordSpan">rethrowCaughtError</span>();
},

/**
 * These are needed for tests only. Do not use!
 */
__purge: function () {
  listenerBank = {};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactEventEmitterMixin" id="apidoc.module.react-dom.ReactEventEmitterMixin">module react-dom.ReactEventEmitterMixin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactEventEmitterMixin.handleTopLevel" id="apidoc.element.react-dom.ReactEventEmitterMixin.handleTopLevel">
        function <span class="apidocSignatureSpan">react-dom.ReactEventEmitterMixin.</span>handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactEventListener" id="apidoc.module.react-dom.ReactEventListener">module react-dom.ReactEventListener</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener._handleTopLevel" id="apidoc.element.react-dom.ReactEventListener._handleTopLevel">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>_handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &amp;&amp; findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener.<span class="apidocCodeKeywordSpan">_handleTopLevel</span>(bookKeeping.topLevelType, targetInst, bookKeeping
.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.dispatchEvent" id="apidoc.element.react-dom.ReactEventListener.dispatchEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>dispatchEvent
        <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatchEvent = function (topLevelType, nativeEvent) {
  if (!ReactEventListener._enabled) {
    return;
  }

  var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    TopLevelCallbackBookKeeping.release(bookKeeping);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.<span class="apidocCodeKeywordSpan">dispatchEvent</span>(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.isEnabled" id="apidoc.element.react-dom.ReactEventListener.isEnabled">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>isEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnabled = function () {
  return ReactEventListener._enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &amp;&amp; ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan
">isEnabled</span>());
},

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.monitorScrollValue" id="apidoc.element.react-dom.ReactEventListener.monitorScrollValue">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>monitorScrollValue
        <span class="apidocSignatureSpan">(refresh)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monitorScrollValue = function (refresh) {
  var callback = scrollValueMonitor.bind(null, refresh);
  EventListener.listen(window, 'scroll', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY &amp;&amp; !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">monitorScrollValue</span>(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.setEnabled" id="apidoc.element.react-dom.ReactEventListener.setEnabled">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>setEnabled
        <span class="apidocSignatureSpan">(enabled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnabled = function (enabled) {
  ReactEventListener._enabled = !!enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sets whether or not any created callbacks should be enabled.
 *
 * @param {boolean} enabled True if callbacks should be enabled.
 */
setEnabled: function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">setEnabled</span>(enabled);
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.setHandleTopLevel" id="apidoc.element.react-dom.ReactEventListener.setHandleTopLevel">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>setHandleTopLevel
        <span class="apidocSignatureSpan">(handleTopLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHandleTopLevel = function (handleTopLevel) {
  ReactEventListener._handleTopLevel = handleTopLevel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactEventListener: null,

injection: {
  /**
   * @param {object} ReactEventListener
   */
  injectReactEventListener: function (ReactEventListener) {
    ReactEventListener.<span class="apidocCodeKeywordSpan">setHandleTopLevel</span>(ReactBrowserEventEmitter.handleTopLevel);
    ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
  }
},

/**
 * Sets whether or not any created callbacks should be enabled.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.trapBubbledEvent" id="apidoc.element.react-dom.ReactEventListener.trapBubbledEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>trapBubbledEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapBubbledEvent = function (topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

for (var i = 0; i &lt; dependencies.length; i++) {
  var dependency = dependencies[i];
  if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) {
    if (dependency === 'topWheel') {
      if (isEventSupported('wheel')) {
        ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapBubbledEvent</span>('topWheel&amp;#
x27;, 'wheel', mountAt);
      } else if (isEventSupported('mousewheel')) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
      } else {
        // Firefox needs to capture a different mouse scroll event.
        // @see http://www.quirksmode.org/dom/events/tests/scroll.html
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactEventListener.trapCapturedEvent" id="apidoc.element.react-dom.ReactEventListener.trapCapturedEvent">
        function <span class="apidocSignatureSpan">react-dom.ReactEventListener.</span>trapCapturedEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapCapturedEvent = function (topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Firefox needs to capture a different mouse scroll event.
  // @see http://www.quirksmode.org/dom/events/tests/scroll.html
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
}
        } else if (dependency === 'topScroll') {

if (isEventSupported('scroll', true)) {
  ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapCapturedEvent</span>('topScroll', &amp;#
x27;scroll', mountAt);
} else {
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter
.ReactEventListener.WINDOW_HANDLE);
}
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

if (isEventSupported('focus', true)) {
  ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactFiber" id="apidoc.module.react-dom.ReactFiber">module react-dom.ReactFiber</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.cloneFiber" id="apidoc.element.react-dom.ReactFiber.cloneFiber">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>cloneFiber
        <span class="apidocSignatureSpan">(fiber, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneFiber = function (fiber, priorityLevel) {
  // We clone to get a work in progress. That means that this fiber is the
  // current. To make it safe to reuse that fiber later on as work in progress
  // we need to reset its work in progress flag now. We don't have an
  // opportunity to do this earlier since we don't traverse the tree when
  // the work in progress tree becomes the current tree.
  // fiber.progressedPriority = NoWork;
  // fiber.progressedChild = null;

  // We use a double buffering pooling technique because we know that we'll only
  // ever need at most two versions of a tree. We pool the "other" unused node
  // that we're free to reuse. This is lazily created to avoid allocating extra
  // objects for things that are never updated. It also allow us to reclaim the
  // extra memory if needed.
  var alt = fiber.alternate;
  if (alt) {
    // Whenever we clone, we do so to get a new work in progress.
    // This ensures that we've reset these in the new tree.
    alt.nextEffect = null;
    alt.firstEffect = null;
    alt.lastEffect = null;
  } else {
    // This should not have an alternate already
    alt = createFiber(fiber.tag, fiber.key);
    alt.type = fiber.type;

    alt.progressedChild = fiber.progressedChild;
    alt.progressedPriority = fiber.progressedPriority;

    alt.alternate = fiber;
    fiber.alternate = alt;
  }

  alt.stateNode = fiber.stateNode;
  alt.child = fiber.child;
  alt.sibling = fiber.sibling; // This should always be overridden. TODO: null
  alt.ref = fiber.ref;
  // pendingProps is here for symmetry but is unnecessary in practice for now.
  // TODO: Pass in the new pendingProps as an argument maybe?
  alt.pendingProps = fiber.pendingProps;
  alt.updateQueue = fiber.updateQueue;
  alt.callbackList = fiber.callbackList;
  alt.pendingWorkPriority = priorityLevel;

  alt.memoizedProps = fiber.memoizedProps;
  alt.output = fiber.output;

  return alt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.createFiberFromCoroutine" id="apidoc.element.react-dom.ReactFiber.createFiberFromCoroutine">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromCoroutine
        <span class="apidocSignatureSpan">(coroutine, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromCoroutine = function (coroutine, priorityLevel) {
  var fiber = createFiber(CoroutineComponent, coroutine.key);
  fiber.type = coroutine.handler;
  fiber.pendingProps = coroutine;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.createFiberFromElement" id="apidoc.element.react-dom.ReactFiber.createFiberFromElement">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromElement
        <span class="apidocSignatureSpan">(element, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromElement = function (element, priorityLevel) {
  // $FlowFixMe: ReactElement.key is currently defined as ?string but should be defined as null | string in Flow.
  var fiber = createFiberFromElementType(element.type, element.key);
  fiber.pendingProps = element.props;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.createFiberFromElementType" id="apidoc.element.react-dom.ReactFiber.createFiberFromElementType">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromElementType
        <span class="apidocSignatureSpan">(type, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFiberFromElementType(type, key) {
  var fiber = void 0;
  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key) : createFiber(IndeterminateComponent, key);
    fiber.type = type;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key);
    fiber.type = type;
  } else if (typeof type === 'object' &amp;&amp; type !== null) {
    // Currently assumed to be a continuation and therefore is a fiber already.
    fiber = type;
  } else {
    throw new Error('Unknown component type: ' + typeof type);
  }
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.createFiberFromYield" id="apidoc.element.react-dom.ReactFiber.createFiberFromYield">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createFiberFromYield
        <span class="apidocSignatureSpan">(yieldNode, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromYield = function (yieldNode, priorityLevel) {
  var fiber = createFiber(YieldComponent, yieldNode.key);
  fiber.pendingProps = {};
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiber.createHostContainerFiber" id="apidoc.element.react-dom.ReactFiber.createHostContainerFiber">
        function <span class="apidocSignatureSpan">react-dom.ReactFiber.</span>createHostContainerFiber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createHostContainerFiber = function () {
  var fiber = createFiber(HostContainer, null);
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactFiberRoot" id="apidoc.module.react-dom.ReactFiberRoot">module react-dom.ReactFiberRoot</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberRoot.createFiberRoot" id="apidoc.element.react-dom.ReactFiberRoot.createFiberRoot">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberRoot.</span>createFiberRoot
        <span class="apidocSignatureSpan">(containerInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberRoot = function (containerInfo) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostContainerFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    isScheduled: false,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactFiberUpdateQueue" id="apidoc.module.react-dom.ReactFiberUpdateQueue">module react-dom.ReactFiberUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberUpdateQueue.addCallbackToQueue" id="apidoc.element.react-dom.ReactFiberUpdateQueue.addCallbackToQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>addCallbackToQueue
        <span class="apidocSignatureSpan">(queue, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCallbackToQueue = function (queue, callback) {
  if (queue.tail.callback) {
    // If the tail already as a callback, add an empty node to queue
    exports.addToQueue(queue, null);
  }
  queue.tail.callback = callback;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberUpdateQueue.addToQueue" id="apidoc.element.react-dom.ReactFiberUpdateQueue.addToQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>addToQueue
        <span class="apidocSignatureSpan">(queue, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToQueue = function (queue, partialState) {
  var node = {
    partialState: partialState,
    callback: null,
    callbackWasCalled: false,
    next: null
  };
  queue.tail.next = node;
  queue.tail = node;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queue.tail = node;
return queue;
};

exports.addCallbackToQueue = function (queue, callback) {
if (queue.tail.callback) {
  // If the tail already as a callback, add an empty node to queue
  exports.<span class="apidocCodeKeywordSpan">addToQueue</span>(queue, null);
}
queue.tail.callback = callback;
return queue;
};

exports.callCallbacks = function (queue, context) {
var node = queue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberUpdateQueue.callCallbacks" id="apidoc.element.react-dom.ReactFiberUpdateQueue.callCallbacks">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>callCallbacks
        <span class="apidocSignatureSpan">(queue, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callCallbacks = function (queue, context) {
  var node = queue;
  while (node) {
    if (node.callback &amp;&amp; !node.callbackWasCalled) {
      node.callbackWasCalled = true;
      node.callback.call(context);
    }
    node = node.next;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberUpdateQueue.createUpdateQueue" id="apidoc.element.react-dom.ReactFiberUpdateQueue.createUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>createUpdateQueue
        <span class="apidocSignatureSpan">(partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdateQueue = function (partialState) {
  var queue = {
    partialState: partialState,
    callback: null,
    callbackWasCalled: false,
    next: null,
    isReplace: false,
    isForced: false,
    tail: null
  };
  queue.tail = queue;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactFiberUpdateQueue.mergeUpdateQueue" id="apidoc.element.react-dom.ReactFiberUpdateQueue.mergeUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactFiberUpdateQueue.</span>mergeUpdateQueue
        <span class="apidocSignatureSpan">(queue, prevState, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeUpdateQueue = function (queue, prevState, props) {
  var node = queue;
  var state = queue.isReplace ? null : _assign({}, prevState);
  while (node) {
    var _partialState = void 0;
    if (typeof node.partialState === 'function') {
      var updateFn = node.partialState;
      _partialState = updateFn(state, props);
    } else {
      _partialState = node.partialState;
    }
    state = _assign(state || {}, _partialState);
    node = node.next;
  }
  return state;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactHostComponent" id="apidoc.module.react-dom.ReactHostComponent">module react-dom.ReactHostComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactHostComponent.createInstanceForText" id="apidoc.element.react-dom.ReactHostComponent.createInstanceForText">
        function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>createInstanceForText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createInstanceForText(text) {
  return new textComponentClass(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!instance.getHostNode) {
      instance.getHostNode = instance.getNativeNode;
    }
  } else {
    instance = new ReactCompositeComponentWrapper(element);
  }
} else if (typeof node === 'string' || typeof node === 'number') {
  instance = ReactHostComponent.<span class="apidocCodeKeywordSpan">createInstanceForText</span>(node);
} else {
  !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s'
;, typeof node) : _prodInvariant('131', typeof node) : void 0;
}

if (process.env.NODE_ENV !== 'production') {
  process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' &amp;&amp;
typeof instance.receiveComponent === 'function' &amp;&amp; typeof instance.getHostNode === 'function' &amp;
;&amp; typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactHostComponent.createInternalComponent" id="apidoc.element.react-dom.ReactHostComponent.createInternalComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>createInternalComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag
 %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
info += getDeclarationErrorAddendum(element._owner);
!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for
 built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info
) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
instance = ReactHostComponent.<span class="apidocCodeKeywordSpan">createInternalComponent</span>(element);
    } else if (isInternalComponentType(element.type)) {
// This is temporarily available for custom components that are not string
// representations. I.e. ART. Once those are updated to use the string
// representation, we can drop this code path.
instance = new element.type(element);

// We renamed this. Allow the old name for compat. :(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactHostComponent.isTextComponent" id="apidoc.element.react-dom.ReactHostComponent.isTextComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactHostComponent.</span>isTextComponent
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTextComponent(component) {
  return component instanceof textComponentClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactHostOperationHistoryHook" id="apidoc.module.react-dom.ReactHostOperationHistoryHook">module react-dom.ReactHostOperationHistoryHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.clearHistory" id="apidoc.element.react-dom.ReactHostOperationHistoryHook.clearHistory">
        function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>clearHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearHistory = function () {
  if (ReactHostOperationHistoryHook._preventClearing) {
    // Should only be used for tests.
    return;
  }

  history = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
ReactComponentTreeHook.purgeUnmountedComponents();
ReactHostOperationHistoryHook.<span class="apidocCodeKeywordSpan">clearHistory</span>();
}

function getTreeSnapshot(registeredIDs) {
return registeredIDs.reduce(function (tree, id) {
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var parentID = ReactComponentTreeHook.getParentID(id);
  tree[id] = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.getHistory" id="apidoc.element.react-dom.ReactHostOperationHistoryHook.getHistory">
        function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>getHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHistory = function () {
  return history;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return tree;
}, {});
}

function resetMeasurements() {
var previousStartTime = currentFlushStartTime;
var previousMeasurements = currentFlushMeasurements;
var previousOperations = ReactHostOperationHistoryHook.<span class="apidocCodeKeywordSpan">getHistory</span>();

if (currentFlushNesting === 0) {
  currentFlushStartTime = 0;
  currentFlushMeasurements = [];
  clearHistory();
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactHostOperationHistoryHook.onHostOperation" id="apidoc.element.react-dom.ReactHostOperationHistoryHook.onHostOperation">
        function <span class="apidocSignatureSpan">react-dom.ReactHostOperationHistoryHook.</span>onHostOperation
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onHostOperation = function (operation) {
  history.push(operation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onHostOperation</span>({
    instanceID: component._debugID,
    type: 'update styles',
    payload: styles
  });
}

var style = node.style;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactInputSelection" id="apidoc.module.react-dom.ReactInputSelection">module react-dom.ReactInputSelection</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactInputSelection.getSelection" id="apidoc.element.react-dom.ReactInputSelection.getSelection">
        function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>getSelection
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelection = function (input) {
  var selection;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else if (document.selection &amp;&amp; input.nodeName &amp;&amp; input.nodeName.toLowerCase() === 'input') {
    // IE8 input.
    var range = document.selection.createRange();
    // There can only be one selection per document in IE, so it must
    // be in our element.
    if (range.parentElement() === input) {
      selection = {
        start: -range.moveStart('character', -input.value.length),
        end: -range.moveEnd('character', -input.value.length)
      };
    }
  } else {
    // Content editable or old IE textarea.
    selection = ReactDOMSelection.getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
var selection = window.getSelection &amp;&amp; window.<span class="apidocCodeKeywordSpan">getSelection</span>();

if (!selection || selection.rangeCount === 0) {
  return null;
}

var anchorNode = selection.anchorNode;
var anchorOffset = selection.anchorOffset;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInputSelection.getSelectionInformation" id="apidoc.element.react-dom.ReactInputSelection.getSelectionInformation">
        function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>getSelectionInformation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelectionInformation = function () {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) :
null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInputSelection.hasSelectionCapabilities" id="apidoc.element.react-dom.ReactInputSelection.hasSelectionCapabilities">
        function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>hasSelectionCapabilities
        <span class="apidocSignatureSpan">(elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasSelectionCapabilities = function (elem) {
  var nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();
  return nodeName &amp;&amp; (nodeName === 'input' &amp;&amp; elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return nodeName &amp;&amp; (nodeName === 'input' &amp;&amp; elem.type === 'text' || nodeName === '
;textarea' || elem.contentEditable === 'true');
},

getSelectionInformation: function () {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: ReactInputSelection.<span class="apidocCodeKeywordSpan">hasSelectionCapabilities</span>(focusedElem) ? ReactInputSelection
.getSelection(focusedElem) : null
  };
},

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInputSelection.restoreSelection" id="apidoc.element.react-dom.ReactInputSelection.restoreSelection">
        function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>restoreSelection
        <span class="apidocSignatureSpan">(priorSelectionInformation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreSelection = function (priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem &amp;&amp; isInDocument(priorFocusedElem)) {
    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
      ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
    }
    focusNode(priorFocusedElem);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInputSelection.setSelection" id="apidoc.element.react-dom.ReactInputSelection.setSelection">
        function <span class="apidocSignatureSpan">react-dom.ReactInputSelection.</span>setSelection
        <span class="apidocSignatureSpan">(input, offsets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSelection = function (input, offsets) {
  var start = offsets.start;
  var end = offsets.end;
  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else if (document.selection &amp;&amp; input.nodeName &amp;&amp; input.nodeName.toLowerCase() === 'input') {
    var range = input.createTextRange();
    range.collapse(true);
    range.moveStart('character', start);
    range.moveEnd('character', end - start);
    range.select();
  } else {
    ReactDOMSelection.setOffsets(input, offsets);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
restoreSelection: function (priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem &amp;&amp; isInDocument(priorFocusedElem)) {
    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
      ReactInputSelection.<span class="apidocCodeKeywordSpan">setSelection</span>(priorFocusedElem, priorSelectionRange);
    }
    focusNode(priorFocusedElem);
  }
},

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactInstanceMap" id="apidoc.module.react-dom.ReactInstanceMap">module react-dom.ReactInstanceMap</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactInstanceMap.get" id="apidoc.element.react-dom.ReactInstanceMap.get">
        function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  return key._reactInternalInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ImpureClass: 0,
PureClass: 1,
StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
var Component = ReactInstanceMap.<span class="apidocCodeKeywordSpan">get</span>(this)._currentElement.type;
var element = Component(this.props, this.context, this.updater);
warnIfInvalidElement(Component, element);
return element;
};

function warnIfInvalidElement(Component, element) {
if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInstanceMap.has" id="apidoc.element.react-dom.ReactInstanceMap.has">
        function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (key) {
  return key._reactInternalInstance !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
 * @param {ReactElement} nextElement Component element to render.
 * @param {DOMElement} container DOM element to render into.
 * @param {?function} callback function triggered on completion
 * @return {ReactComponent} Component instance rendered in `container`.
 */
renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &amp;&amp; ReactInstanceMap.<span class="apidocCodeKeywordSpan">has</span>(parentComponent)) ? process
.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant
('38') : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
},

_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render():
Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' :
  // Check if it quacks like an element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInstanceMap.remove" id="apidoc.element.react-dom.ReactInstanceMap.remove">
        function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>remove
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (key) {
  key._reactInternalInstance = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._context = null;
  this._rootNodeID = 0;
  this._topLevelWrapper = null;

  // Delete the reference from the instance to this internal representation
  // which allow the internals to be properly cleaned up even if the user
  // leaks a reference to the public instance.
  ReactInstanceMap.<span class="apidocCodeKeywordSpan">remove</span>(inst);

  // Some existing components rely on inst.props even after they've been
  // destroyed (in event handlers).
  // TODO: inst.props = null;
  // TODO: inst.state = null;
  // TODO: inst.context = null;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInstanceMap.set" id="apidoc.element.react-dom.ReactInstanceMap.set">
        function <span class="apidocSignatureSpan">react-dom.ReactInstanceMap.</span>set
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value) {
  key._reactInternalInstance = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
inst.context = publicContext;
inst.refs = emptyObject;
inst.updater = updateQueue;

this._instance = inst;

// Store a reference from the instance back to the internal representation
ReactInstanceMap.<span class="apidocCodeKeywordSpan">set</span>(inst, this);

if (process.env.NODE_ENV !== 'production') {
  // Since plain JS classes are defined without any special initialization
  // logic, we can not catch common errors early. Therefore, we have to
  // catch them here, at initialization time, instead.
  process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved ||
inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes
 created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || '
;a component') : void 0;
  process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, &amp;#
x27;getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using
 React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component
') : void 0;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactInvalidSetStateWarningHook" id="apidoc.module.react-dom.ReactInvalidSetStateWarningHook">module react-dom.ReactInvalidSetStateWarningHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext" id="apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext">
        function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onBeginProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginProcessingChildContext = function () {
  processingChildContext = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _processChildContext: function (currentContext) {
var Component = this._currentElement.type;
var inst = this._instance;
var childContext;

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginProcessingChildContext</span>();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.onEndProcessingChildContext();
    }
  } else {
    childContext = inst.getChildContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onEndProcessingChildContext" id="apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onEndProcessingChildContext">
        function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onEndProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndProcessingChildContext = function () {
  processingChildContext = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginProcessingChildContext();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndProcessingChildContext</span>();
    }
  } else {
    childContext = inst.getChildContext();
  }
}

if (childContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onSetState" id="apidoc.element.react-dom.ReactInvalidSetStateWarningHook.onSetState">
        function <span class="apidocSignatureSpan">react-dom.ReactInvalidSetStateWarningHook.</span>onSetState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetState = function () {
  warnInvalidSetState();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
if (process.env.NODE_ENV !== 'production') {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetState</span>();
  process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or
 null state object; ' + 'instead, use forceUpdate().') : void 0;
}

var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

if (!internalInstance) {
  return;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactMarkupChecksum" id="apidoc.module.react-dom.ReactMarkupChecksum">module react-dom.ReactMarkupChecksum</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactMarkupChecksum.addChecksumToMarkup" id="apidoc.element.react-dom.ReactMarkupChecksum.addChecksumToMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactMarkupChecksum.</span>addChecksumToMarkup
        <span class="apidocSignatureSpan">(markup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addChecksumToMarkup = function (markup) {
  var checksum = adler32(markup);

  // Add checksum (handle both parent tags, comments and self-closing tags)
  if (COMMENT_START.test(markup)) {
    return markup;
  } else {
    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&amp;');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var componentInstance = instantiateReactComponent(element, true);
    var markup = ReactReconciler.mountComponent(componentInstance, transaction, null, ReactDOMContainerInfo(), emptyObject, 0 /*
parentDebugID */
    );
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onUnmountComponent(componentInstance._debugID);
    }
    if (!makeStaticMarkup) {
      markup = ReactMarkupChecksum.<span class="apidocCodeKeywordSpan">addChecksumToMarkup</span>(markup);
    }
    return markup;
  }, null);
} finally {
  pendingTransactions--;
  ReactServerRenderingTransaction.release(transaction);
  // Revert to the DOM batching strategy since these two renderers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMarkupChecksum.canReuseMarkup" id="apidoc.element.react-dom.ReactMarkupChecksum.canReuseMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactMarkupChecksum.</span>canReuseMarkup
        <span class="apidocSignatureSpan">(markup, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canReuseMarkup = function (markup, element) {
  var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
  existingChecksum = existingChecksum &amp;&amp; parseInt(existingChecksum, 10);
  var markupChecksum = adler32(markup);
  return markupChecksum === existingChecksum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode
(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.<span class="apidocCodeKeywordSpan">canReuseMarkup</span>(markup, rootElement)) {
ReactDOMComponentTree.precacheNode(instance, rootElement);
return;
      } else {
var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

var rootMarkup = rootElement.outerHTML;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactMount" id="apidoc.module.react-dom.ReactMount">module react-dom.ReactMount</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactMount.TopLevelWrapper" id="apidoc.element.react-dom.ReactMount.TopLevelWrapper">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>TopLevelWrapper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount._mountImageIntoNode" id="apidoc.element.react-dom.ReactMount._mountImageIntoNode">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_mountImageIntoNode
        <span class="apidocSignatureSpan">(markup, container, instance, shouldReuseMarkup, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mountImageIntoNode = function (markup, container, instance, shouldReuseMarkup, transaction) {
  !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container
 is not valid.') : _prodInvariant('41') : void 0;

  if (shouldReuseMarkup) {
    var rootElement = getReactRootElementInContainer(container);
    if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
      ReactDOMComponentTree.precacheNode(instance, rootElement);
      return;
    } else {
      var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

      var rootMarkup = rootElement.outerHTML;
      rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

      var normalizedMarkup = markup;
      if (process.env.NODE_ENV !== 'production') {
        // because rootMarkup is retrieved from the DOM, various normalizations
        // will have occurred which will not be present in `markup`. Here,
        // insert markup into a &lt;div&gt; or &lt;iframe&gt; depending on the container
        // type to perform the same normalizations before comparing.
        var normalizer;
        if (container.nodeType === ELEMENT_NODE_TYPE) {
          normalizer = document.createElement('div');
          normalizer.innerHTML = markup;
          normalizedMarkup = normalizer.innerHTML;
        } else {
          normalizer = document.createElement('iframe');
          document.body.appendChild(normalizer);
          normalizer.contentDocument.write(markup);
          normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
          document.body.removeChild(normalizer);
        }
      }

      var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
      var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring
(diffIndex - 20, diffIndex + 20);

      !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render
 a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component
 type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due
to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and
 ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum
 was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not
what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits
 of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
      }
    }
  }

  !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a
 component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

  if (transaction.useCreateElement) {
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
    DOMLazyTree.insertTreeBefore(container, markup, null);
  } else {
    setInnerHTML(container, markup);
    ReactDOMComponentTree.precacheNode(instance, container.firstChild);
  }

  if (process.env.NODE_ENV !== 'production') {
    var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
    if (hostNode._debugID !== 0) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 );

 if (markerName) {
   console.timeEnd(markerName);
 }

 wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
 ReactMount.<span class="apidocCodeKeywordSpan">_mountImageIntoNode</span>(markup, container, wrapperInstance, shouldReuseMarkup
, transaction);
}

/**
* Batched mount.
*
* @param {ReactComponent} componentInstance The instance to mount.
* @param {DOMElement} container DOM element to mount into.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount._renderNewRootComponent" id="apidoc.element.react-dom.ReactMount._renderNewRootComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_renderNewRootComponent
        <span class="apidocSignatureSpan">(nextElement, container, shouldReuseMarkup, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderNewRootComponent = function (nextElement, container, shouldReuseMarkup, context) {
  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case.
  process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods
should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary
, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current &amp;&amp; ReactCurrentOwner
.current.getName() || 'ReactCompositeComponent') : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container
 is not a DOM element.') : _prodInvariant('37') : void 0;

  ReactBrowserEventEmitter.ensureScrollValueMonitoring();
  var componentInstance = instantiateReactComponent(nextElement, false);

  // The initial render is synchronous but any updates that happen during
  // rendering, in componentWillMount or componentDidMount, will be batched
  // according to the current batching strategy.

  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

  var wrapperID = componentInstance._instance.rootID;
  instancesByReactRootID[wrapperID] = componentInstance;

  return componentInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        rootElementSibling = rootElementSibling.nextSibling;
      }
    }
  }

  var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild;
  var component = ReactMount.<span class="apidocCodeKeywordSpan">_renderNewRootComponent</span>(nextWrappedElement, container, shouldReuseMarkup
, nextContext)._renderedComponent.getPublicInstance();
  if (callback) {
    callback.call(component);
  }
  return component;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount._renderSubtreeIntoContainer" id="apidoc.element.react-dom.ReactMount._renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component
 element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' :
  // Check if it quacks like an element
  nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + '
copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' : nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

  process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', '
render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third
-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element
 created ' + 'for your app.') : void 0;

  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

  var nextContext;
  if (parentComponent) {
    var parentInst = ReactInstanceMap.get(parentComponent);
    nextContext = parentInst._processChildContext(parentInst._context);
  } else {
    nextContext = emptyObject;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);

  if (prevComponent) {
    var prevWrappedElement = prevComponent._currentElement;
    var prevElement = prevWrappedElement.props.child;
    if (shouldUpdateReactComponent(prevElement, nextElement)) {
      var publicInst = prevComponent._renderedComponent.getPublicInstance();
      var updatedCallback = callback &amp;&amp; function () {
        callback.call(publicInst);
      };
      ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
      return publicInst;
    } else {
      ReactMount.unmountComponentAtNode(container);
    }
  }

  var reactRootElement = getReactRootElementInContainer(container);
  var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement);
  var containerHasNonRootReactChild = hasNonRootReactChild(container);

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children
 with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing
children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

    if (!containerHasReactMarkup || reactRootElement.nextSibling) {
      var rootElementSibling = reactRootElement;
      while (rootElementSibling) {
        if (internalGetID(rootElementSibling)) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + '
are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0
;
          break;
        }
        rootElementSibling = rootElementSibling.nextSibling;
      }
    }
  }

  var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild;
  var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent
.getPublicInstance();
  if (callback) {
    callback.call(compon ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactElement} nextElement Component element to render.
 * @param {DOMElement} container DOM element to render into.
 * @param {?function} callback function triggered on completion
 * @return {ReactComponent} Component instance rendered in `container`.
 */
renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production'
; ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
  return ReactMount.<span class="apidocCodeKeywordSpan">_renderSubtreeIntoContainer</span>(parentComponent, nextElement, container
, callback);
},

_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render():
Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' :
  // Check if it quacks like an element
  nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent
 ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string'
; ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' : nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount._updateRootComponent" id="apidoc.element.react-dom.ReactMount._updateRootComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>_updateRootComponent
        <span class="apidocSignatureSpan">(prevComponent, nextElement, nextContext, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateRootComponent = function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
    }
  });

  return prevComponent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var prevWrappedElement = prevComponent._currentElement;
  var prevElement = prevWrappedElement.props.child;
  if (shouldUpdateReactComponent(prevElement, nextElement)) {
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &amp;&amp; function () {
      callback.call(publicInst);
    };
    ReactMount.<span class="apidocCodeKeywordSpan">_updateRootComponent</span>(prevComponent, nextWrappedElement, nextContext, container
, updatedCallback);
    return publicInst;
  } else {
    ReactMount.unmountComponentAtNode(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount.render" id="apidoc.element.react-dom.ReactMount.render">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>render
        <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (nextElement, container, callback) {
  return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello World&lt;/div&gt;;
  }
}

ReactDOM.<span class="apidocCodeKeywordSpan">render</span>(&lt;MyComponent /&gt;, node);
```

### On the server

```js
var React = require('react');
var ReactDOMServer = require('react-dom/server');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount.renderSubtreeIntoContainer" id="apidoc.element.react-dom.ReactMount.renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '
parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount.scrollMonitor" id="apidoc.element.react-dom.ReactMount.scrollMonitor">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>scrollMonitor
        <span class="apidocSignatureSpan">(container, renderCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrollMonitor = function (container, renderCallback) {
  renderCallback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
ReactMount.<span class="apidocCodeKeywordSpan">scrollMonitor</span>(container, function () {
  ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
  }
});

return prevComponent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactMount.unmountComponentAtNode" id="apidoc.element.react-dom.ReactMount.unmountComponentAtNode">
        function <span class="apidocSignatureSpan">react-dom.ReactMount.</span>unmountComponentAtNode
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponentAtNode = function (container) {
  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (Strictly speaking, unmounting won't cause a
  // render but we still don't expect to be in a render call here.)
  process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should
 be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary,
trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current &amp;&amp; ReactCurrentOwner
.current.getName() || 'ReactCompositeComponent') : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container
 is not a DOM element.') : _prodInvariant('40') : void 0;

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node
 you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);
  if (!prevComponent) {
    // Check if the node being unmounted was rendered by React, but isn't a
    // root node.
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    // Check if the container itself is a React root node.
    var isContainerReactRoot = container.nodeType === 1 &amp;&amp; container.hasAttribute(ROOT_ATTR_NAME);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re
 attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally
 passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender
 in order to remove this component.') : void 0;
    }

    return false;
  }
  delete instancesByReactRootID[prevComponent._instance.rootID];
  ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &amp;&amp; function () {
      callback.call(publicInst);
    };
    ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
    return publicInst;
  } else {
    ReactMount.<span class="apidocCodeKeywordSpan">unmountComponentAtNode</span>(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement);
var containerHasNonRootReactChild = hasNonRootReactChild(container);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactNodeTypes" id="apidoc.module.react-dom.ReactNodeTypes">module react-dom.ReactNodeTypes</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactNodeTypes.getType" id="apidoc.element.react-dom.ReactNodeTypes.getType">
        function <span class="apidocSignatureSpan">react-dom.ReactNodeTypes.</span>getType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getType = function (node) {
  if (node === null || node === false) {
    return ReactNodeTypes.EMPTY;
  } else if (React.isValidElement(node)) {
    if (typeof node.type === 'function') {
      return ReactNodeTypes.COMPOSITE;
    } else {
      return ReactNodeTypes.HOST;
    }
  }
  !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) :
void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If not a stateless component, we now render
if (renderedElement === undefined) {
  renderedElement = this._renderValidatedComponent();
}

var nodeType = ReactNodeTypes.<span class="apidocCodeKeywordSpan">getType</span>(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;

var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactOwner" id="apidoc.module.react-dom.ReactOwner">module react-dom.ReactOwner</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactOwner.addComponentAsRefTo" id="apidoc.element.react-dom.ReactOwner.addComponentAsRefTo">
        function <span class="apidocSignatureSpan">react-dom.ReactOwner.</span>addComponentAsRefTo
        <span class="apidocSignatureSpan">(component, ref, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addComponentAsRefTo = function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can
 have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
  owner.attachRef(ref, component);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReactRef = {};

function attachRef(ref, component, owner) {
if (typeof ref === 'function') {
  ref(component.getPublicInstance());
} else {
  // Legacy ref
  ReactOwner.<span class="apidocCodeKeywordSpan">addComponentAsRefTo</span>(component, ref, owner);
}
}

function detachRef(ref, component, owner) {
if (typeof ref === 'function') {
  ref(null);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactOwner.removeComponentAsRefFrom" id="apidoc.element.react-dom.ReactOwner.removeComponentAsRefFrom">
        function <span class="apidocSignatureSpan">react-dom.ReactOwner.</span>removeComponentAsRefFrom
        <span class="apidocSignatureSpan">(component, ref, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeComponentAsRefFrom = function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner
 can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
  var ownerPublicInstance = owner.getPublicInstance();
  // Check that `component`'s owner is still alive and that `component` is still the current ref
  // because we do not want to detach the ref if another component stole it.
  if (ownerPublicInstance &amp;&amp; ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
    owner.detachRef(ref);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function detachRef(ref, component, owner) {
if (typeof ref === 'function') {
  ref(null);
} else {
  // Legacy ref
  ReactOwner.<span class="apidocCodeKeywordSpan">removeComponentAsRefFrom</span>(component, ref, owner);
}
}

ReactRef.attachRefs = function (instance, element) {
if (element === null || typeof element !== 'object') {
  return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactPerf" id="apidoc.module.react-dom.ReactPerf">module react-dom.ReactPerf</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getExclusive" id="apidoc.element.react-dom.ReactPerf.getExclusive">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getExclusive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExclusive() {
  var flushHistory = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, timerType, applyUpdate) {
    var displayName = treeSnapshot[instanceID].displayName;

    var key = displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        counts: {},
        durations: {},
        totalDuration: 0
      };
    }
    if (!stats.durations[timerType]) {
      stats.durations[timerType] = 0;
    }
    if (!stats.counts[timerType]) {
      stats.counts[timerType] = 0;
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot;

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      updateAggregatedStats(treeSnapshot, instanceID, timerType, function (stats) {
        stats.totalDuration += duration;
        stats.durations[timerType] += duration;
        stats.counts[timerType]++;
      });
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.totalDuration - a.totalDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getInclusive" id="apidoc.element.react-dom.ReactPerf.getInclusive">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getInclusive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInclusive() {
  var flushHistory = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
    var _treeSnapshot$instanc = treeSnapshot[instanceID],
        displayName = _treeSnapshot$instanc.displayName,
        ownerID = _treeSnapshot$instanc.ownerID;

    var owner = treeSnapshot[ownerID];
    var key = (owner ? owner.displayName + ' &gt; ' : '') + displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        inclusiveRenderDuration: 0,
        renderCount: 0
      };
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  var isCompositeByID = {};
  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements;

    measurements.forEach(function (measurement) {
      var instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== 'render') {
        return;
      }
      isCompositeByID[instanceID] = true;
    });
  });

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot;

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== 'render') {
        return;
      }
      updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
        stats.renderCount++;
      });
      var nextParentID = instanceID;
      while (nextParentID) {
        // As we traverse parents, only count inclusive time towards composites.
        // We know something is a composite if its render() was called.
        if (isCompositeByID[nextParentID]) {
          updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
            stats.inclusiveRenderDuration += duration;
          });
        }
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getLastMeasurements" id="apidoc.element.react-dom.ReactPerf.getLastMeasurements">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getLastMeasurements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLastMeasurements() {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return [];
  }

  return ReactDebugTool.getFlushHistory();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getMeasurementsSummaryMap" id="apidoc.element.react-dom.ReactPerf.getMeasurementsSummaryMap">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getMeasurementsSummaryMap
        <span class="apidocSignatureSpan">(measurements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMeasurementsSummaryMap(measurements) {
  process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.getMeasurementsSummaryMap(...)`
is deprecated. Use ' + '`ReactPerf.getWasted(...)` instead.') : void 0;
  warnedAboutGetMeasurementsSummaryMap = true;
  return getWasted(measurements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.printDOM(...)` is deprecated. Use
 ' + '`ReactPerf.printOperations(...)` instead.') : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.<span class="apidocCodeKeywordSpan
">getMeasurementsSummaryMap</span>(...)` is deprecated. Use ' + '`ReactPerf.getWasted(...)` instead.') : void 0;
warnedAboutGetMeasurementsSummaryMap = true;
return getWasted(measurements);
}

function start() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getOperations" id="apidoc.element.react-dom.ReactPerf.getOperations">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getOperations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOperations() {
  var flushHistory = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return [];
  }

  var stats = [];
  flushHistory.forEach(function (flush, flushIndex) {
    var operations = flush.operations,
        treeSnapshot = flush.treeSnapshot;

    operations.forEach(function (operation) {
      var instanceID = operation.instanceID,
          type = operation.type,
          payload = operation.payload;
      var _treeSnapshot$instanc3 = treeSnapshot[instanceID],
          displayName = _treeSnapshot$instanc3.displayName,
          ownerID = _treeSnapshot$instanc3.ownerID;

      var owner = treeSnapshot[ownerID];
      var key = (owner ? owner.displayName + ' &gt; ' : '') + displayName;

      stats.push({
        flushIndex: flushIndex,
        instanceID: instanceID,
        key: key,
        type: type,
        ownerID: ownerID,
        payload: payload
      });
    });
  });
  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.getWasted" id="apidoc.element.react-dom.ReactPerf.getWasted">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>getWasted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWasted() {
  var flushHistory = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
    var _treeSnapshot$instanc2 = treeSnapshot[instanceID],
        displayName = _treeSnapshot$instanc2.displayName,
        ownerID = _treeSnapshot$instanc2.ownerID;

    var owner = treeSnapshot[ownerID];
    var key = (owner ? owner.displayName + ' &gt; ' : '') + displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        inclusiveRenderDuration: 0,
        renderCount: 0
      };
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot,
        operations = flush.operations;

    var isDefinitelyNotWastedByID = {};

    // Find host components associated with an operation in this batch.
    // Mark all components in their parent tree as definitely not wasted.
    operations.forEach(function (operation) {
      var instanceID = operation.instanceID;

      var nextParentID = instanceID;
      while (nextParentID) {
        isDefinitelyNotWastedByID[nextParentID] = true;
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });

    // Find composite components that rendered in this batch.
    // These are potential candidates for being wasted renders.
    var renderedCompositeIDs = {};
    measurements.forEach(function (measurement) {
      var instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== 'render') {
        return;
      }
      renderedCompositeIDs[instanceID] = true;
    });

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== 'render') {
        return;
      }

      // If there was a DOM update below this component, or it has just been
      // mounted, its render() is not considered wasted.
      var updateCount = treeSnapshot[instanceID].updateCount;

      if (isDefinitelyNotWastedByID[instanceID] || updateCount === 0) {
        return;
      }

      // We consider this render() wasted.
      updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
        stats.renderCount++;
      });

      var nextParentID = instanceID;
      while (nextParentID) {
        // Any parents rendered during this batch are considered wasted
        // unless we previously marked them as dirty.
        var isWasted = renderedCompositeIDs[nextParentID] &amp;&amp; !isDefinitelyNotWastedByID[nextParentID];
        if (isWasted) {
          updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
            stats.inclusiveRenderDuration += duration;
          });
        }
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.printDOM(...)` is deprecated. Use
 ' + '`ReactPerf.printOperations(...)` instead.') : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use ' + '`ReactPerf.<span class="apidocCodeKeywordSpan">getWasted</span>(...)` instead.') :
void 0;
warnedAboutGetMeasurementsSummaryMap = true;
return getWasted(measurements);
}

function start() {
if (!(process.env.NODE_ENV !== 'production')) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.isRunning" id="apidoc.element.react-dom.ReactPerf.isRunning">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>isRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRunning() {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return false;
  }

  return ReactDebugTool.isProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.printDOM" id="apidoc.element.react-dom.ReactPerf.printDOM">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printDOM
        <span class="apidocSignatureSpan">(measurements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printDOM(measurements) {
  process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.printDOM(...)` is deprecated. Use ' + '`ReactPerf
.printOperations(...)` instead.') : void 0;
  warnedAboutPrintDOM = true;
  return printOperations(measurements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
});
consoleTable(table);
}

var warnedAboutPrintDOM = false;
function printDOM(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.<span class="apidocCodeKeywordSpan
">printDOM</span>(...)` is deprecated. Use ' + '`ReactPerf.printOperations(...)` instead.') : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use ' + '`ReactPerf.getWasted(...)` instead.') : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.printExclusive" id="apidoc.element.react-dom.ReactPerf.printExclusive">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printExclusive
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printExclusive(flushHistory) {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  var stats = getExclusive(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        totalDuration = item.totalDuration;

    var renderCount = item.counts.render || 0;
    var renderDuration = item.durations.render || 0;
    return {
      'Component': key,
      'Total time (ms)': roundFloat(totalDuration),
      'Instance count': instanceCount,
      'Total render time (ms)': roundFloat(renderDuration),
      'Average render time (ms)': renderCount ? roundFloat(renderDuration / renderCount) : undefined,
      'Render count': renderCount,
      'Total lifecycle time (ms)': roundFloat(totalDuration - renderDuration)
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.printInclusive" id="apidoc.element.react-dom.ReactPerf.printInclusive">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printInclusive
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printInclusive(flushHistory) {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  var stats = getInclusive(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        inclusiveRenderDuration = item.inclusiveRenderDuration,
        renderCount = item.renderCount;

    return {
      'Owner &gt; Component': key,
      'Inclusive render time (ms)': roundFloat(inclusiveRenderDuration),
      'Instance count': instanceCount,
      'Render count': renderCount
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.printOperations" id="apidoc.element.react-dom.ReactPerf.printOperations">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printOperations
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printOperations(flushHistory) {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  var stats = getOperations(flushHistory);
  var table = stats.map(function (stat) {
    return {
      'Owner &gt; Node': stat.key,
      'Operation': stat.type,
      'Payload': typeof stat.payload === 'object' ? JSON.stringify(stat.payload) : stat.payload,
      'Flush index': stat.flushIndex,
      'Owner Component ID': stat.ownerID,
      'DOM Component ID': stat.instanceID
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
});
consoleTable(table);
}

var warnedAboutPrintDOM = false;
function printDOM(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.printDOM(...)` is deprecated. Use
 ' + '`ReactPerf.<span class="apidocCodeKeywordSpan">printOperations</span>(...)` instead.') : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use ' + '`ReactPerf.getWasted(...)` instead.') : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.printWasted" id="apidoc.element.react-dom.ReactPerf.printWasted">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>printWasted
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printWasted(flushHistory) {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  var stats = getWasted(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        inclusiveRenderDuration = item.inclusiveRenderDuration,
        renderCount = item.renderCount;

    return {
      'Owner &gt; Component': key,
      'Inclusive wasted time (ms)': roundFloat(inclusiveRenderDuration),
      'Instance count': instanceCount,
      'Render count': renderCount
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.start" id="apidoc.element.react-dom.ReactPerf.start">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start() {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  ReactDebugTool.beginProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactPerf.stop" id="apidoc.element.react-dom.ReactPerf.stop">
        function <span class="apidocSignatureSpan">react-dom.ReactPerf.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop() {
  if (!(process.env.NODE_ENV !== 'production')) {
    warnInProduction();
    return;
  }

  ReactDebugTool.endProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactReconcileTransaction" id="apidoc.module.react-dom.ReactReconcileTransaction">module react-dom.ReactReconcileTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.ReactReconcileTransaction" id="apidoc.element.react-dom.ReactReconcileTransaction.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(useCreateElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.getPooled" id="apidoc.element.react-dom.ReactReconcileTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.release" id="apidoc.element.react-dom.ReactReconcileTransaction.release">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactReconcileTransaction.prototype" id="apidoc.module.react-dom.ReactReconcileTransaction.prototype">module react-dom.ReactReconcileTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.checkpoint" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {
  // reactMountReady is the our only stateful wrapper
  return this.reactMountReady.checkpoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.closeAll" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction
 when none are open.') : _prodInvariant('28') : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn't throw, we don't want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.destructor" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  CallbackQueue.release(this.reactMountReady);
  this.reactMountReady = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getReactMountReady" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return this.reactMountReady;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, 'componentDidMount');
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * "PooledClass".
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.getUpdateQueue" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return ReactUpdateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.initializeAll" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it's still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it's still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.isInTransaction" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance to use as `this` context.
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.<span class="apidocCodeKeywordSpan">isInTransaction</span>()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.perform" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it's still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn't throw, we don't want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconcileTransaction.prototype.rollback" id="apidoc.element.react-dom.ReactReconcileTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-dom.ReactReconcileTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">(checkpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (checkpoint) {
  this.reactMountReady.rollback(checkpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactReconciler" id="apidoc.module.react-dom.ReactReconciler">module react-dom.ReactReconciler</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactReconciler.getHostNode" id="apidoc.element.react-dom.ReactReconciler.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>getHostNode
        <span class="apidocSignatureSpan">(internalInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function (internalInstance) {
  return internalInstance.getHostNode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconciler.mountComponent" id="apidoc.element.react-dom.ReactReconciler.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>mountComponent
        <span class="apidocSignatureSpan">(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots ) {
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID
);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &amp;&amp; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
    }
  }
  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconciler.performUpdateIfNecessary" id="apidoc.element.react-dom.ReactReconciler.performUpdateIfNecessary">
        function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>performUpdateIfNecessary
        <span class="apidocSignatureSpan">(internalInstance, transaction, updateBatchNumber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performUpdateIfNecessary = function (internalInstance, transaction, updateBatchNumber) {
  if (internalInstance._updateBatchNumber !== updateBatchNumber) {
    // The component's enqueued batch number should always be the current
    // batch or the following one.
    process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber
 === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber
, internalInstance._updateBatchNumber) : void 0;
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.performUpdateIfNecessary(transaction);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.<span class="apidocCodeKeywordSpan">performUpdateIfNecessary</span>(transaction);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconciler.receiveComponent" id="apidoc.element.react-dom.ReactReconciler.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>receiveComponent
        <span class="apidocSignatureSpan">(internalInstance, nextElement, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (internalInstance, nextElement, transaction, context) {
  var prevElement = internalInstance._currentElement;

  if (nextElement === prevElement &amp;&amp; context === internalInstance._context) {
    // Since elements are immutable after the owner is rendered,
    // we can do a cheap identity compare here to determine if this is a
    // superfluous reconcile. It's possible for state to be mutable but such
    // change should trigger an update of the owner which would recreate
    // the element. We explicitly check for the existence of an owner since
    // it's possible for an element created outside a composite to be
    // deeply mutated and reused.

    // TODO: Bailing out early is just a perf optimization right?
    // TODO: Removing the return statement should affect correctness?
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
    }
  }

  var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

  if (refsChanged) {
    ReactRef.detachRefs(internalInstance, prevElement);
  }

  internalInstance.receiveComponent(nextElement, transaction, context);

  if (refsChanged &amp;&amp; internalInstance._currentElement &amp;&amp; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }

  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReconciler.unmountComponent" id="apidoc.element.react-dom.ReactReconciler.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactReconciler.</span>unmountComponent
        <span class="apidocSignatureSpan">(internalInstance, safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (internalInstance, safely) {
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
    }
  }
  ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactRef" id="apidoc.module.react-dom.ReactRef">module react-dom.ReactRef</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactRef.attachRefs" id="apidoc.element.react-dom.ReactRef.attachRefs">
        function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>attachRefs
        <span class="apidocSignatureSpan">(instance, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var warning = require('fbjs/lib/warning');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
ReactRef.<span class="apidocCodeKeywordSpan">attachRefs</span>(this, this._currentElement);
}

var ReactReconciler = {

/**
 * Initializes the component, renders markup, and registers event listeners.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactRef.detachRefs" id="apidoc.element.react-dom.ReactRef.detachRefs">
        function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>detachRefs
        <span class="apidocSignatureSpan">(instance, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
unmountComponent: function (internalInstance, safely) {
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
    }
  }
  ReactRef.<span class="apidocCodeKeywordSpan">detachRefs</span>(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== 'production') {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
    }
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactRef.shouldUpdateRefs" id="apidoc.element.react-dom.ReactRef.shouldUpdateRefs">
        function <span class="apidocSignatureSpan">react-dom.ReactRef.</span>shouldUpdateRefs
        <span class="apidocSignatureSpan">(prevElement, nextElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null &amp;&amp; typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null &amp;&amp; typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' &amp;&amp; nextOwner !== prevOwner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (process.env.NODE_ENV !== 'production') {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
  }
}

var refsChanged = ReactRef.<span class="apidocCodeKeywordSpan">shouldUpdateRefs</span>(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
}

internalInstance.receiveComponent(nextElement, transaction, context);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactReifiedYield" id="apidoc.module.react-dom.ReactReifiedYield">module react-dom.ReactReifiedYield</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactReifiedYield.createReifiedYield" id="apidoc.element.react-dom.ReactReifiedYield.createReifiedYield">
        function <span class="apidocSignatureSpan">react-dom.ReactReifiedYield.</span>createReifiedYield
        <span class="apidocSignatureSpan">(yieldNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReifiedYield = function (yieldNode) {
  var fiber = createFiberFromElementType(yieldNode.continuation, yieldNode.key);
  return {
    continuation: fiber,
    props: yieldNode.props
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactReifiedYield.createUpdatedReifiedYield" id="apidoc.element.react-dom.ReactReifiedYield.createUpdatedReifiedYield">
        function <span class="apidocSignatureSpan">react-dom.ReactReifiedYield.</span>createUpdatedReifiedYield
        <span class="apidocSignatureSpan">(previousYield, yieldNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdatedReifiedYield = function (previousYield, yieldNode) {
  return {
    continuation: previousYield.continuation,
    props: yieldNode.props
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerBatchingStrategy" id="apidoc.module.react-dom.ReactServerBatchingStrategy">module react-dom.ReactServerBatchingStrategy</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactServerBatchingStrategy.batchedUpdates" id="apidoc.element.react-dom.ReactServerBatchingStrategy.batchedUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactServerBatchingStrategy.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batchedUpdates = function (callback) {
  // Don't do anything here. During the server rendering we don't want to
  // schedule any updates. We will simply ignore them.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerRendering" id="apidoc.module.react-dom.ReactServerRendering">module react-dom.ReactServerRendering</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRendering.renderToStaticMarkup" id="apidoc.element.react-dom.ReactServerRendering.renderToStaticMarkup">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRendering.</span>renderToStaticMarkup
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToStaticMarkup(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass
 a valid ReactElement.') : _prodInvariant('47') : void 0;
  return renderToStringImpl(element, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRendering.renderToString" id="apidoc.element.react-dom.ReactServerRendering.renderToString">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRendering.</span>renderToString
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToString(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid
 ReactElement.') : _prodInvariant('46') : void 0;
  return renderToStringImpl(element, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello World&lt;/div&gt;;
  }
}

ReactDOMServer.<span class="apidocCodeKeywordSpan">renderToString</span>(&lt;MyComponent /&gt;);
```

## API

### `react-dom`

- `findDOMNode`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerRenderingTransaction" id="apidoc.module.react-dom.ReactServerRenderingTransaction">module react-dom.ReactServerRenderingTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.ReactServerRenderingTransaction" id="apidoc.element.react-dom.ReactServerRenderingTransaction.ReactServerRenderingTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactServerRenderingTransaction
        <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.getPooled" id="apidoc.element.react-dom.ReactServerRenderingTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.release" id="apidoc.element.react-dom.ReactServerRenderingTransaction.release">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerRenderingTransaction.prototype" id="apidoc.module.react-dom.ReactServerRenderingTransaction.prototype">module react-dom.ReactServerRenderingTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.checkpoint" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.closeAll" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction
 when none are open.') : _prodInvariant('28') : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn't throw, we don't want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.destructor" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getReactMountReady" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return noopCallbackQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, 'componentDidMount');
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * "PooledClass".
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getUpdateQueue" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return this.updateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.initializeAll" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it's still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it's still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.isInTransaction" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance to use as `this` context.
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.<span class="apidocCodeKeywordSpan">isInTransaction</span>()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.perform" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it's still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn't throw, we don't want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.rollback" id="apidoc.element.react-dom.ReactServerRenderingTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-dom.ReactServerRenderingTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerUpdateQueue" id="apidoc.module.react-dom.ReactServerUpdateQueue">module react-dom.ReactServerUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.ReactServerUpdateQueue" id="apidoc.element.react-dom.ReactServerUpdateQueue.ReactServerUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactServerUpdateQueue
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerUpdateQueue(transaction) {
  _classCallCheck(this, ReactServerUpdateQueue);

  this.transaction = transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactServerUpdateQueue.prototype" id="apidoc.module.react-dom.ReactServerUpdateQueue.prototype">module react-dom.ReactServerUpdateQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueCallback" id="apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueCallback">
        function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueCallback
        <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallback</span>(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueForceUpdate" id="apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueForceUpdate">
        function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueForceUpdate
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueForceUpdate(publicInstance);
  } else {
    warnNoop(publicInstance, 'forceUpdate');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance that should rerender.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueForceUpdate</span>(publicInstance);
  } else {
    warnNoop(publicInstance, 'forceUpdate');
  }
};

/**
 * Replaces all of the state. Always use this or `setState` to mutate state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueReplaceState" id="apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueReplaceState">
        function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueReplaceState
        <span class="apidocSignatureSpan">(publicInstance, completeState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, 'replaceState');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object|function} completeState Next state.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueReplaceState</span>(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, 'replaceState');
  }
};

/**
 * Sets a subset of the state. This only exists because _pendingState is
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueSetState" id="apidoc.element.react-dom.ReactServerUpdateQueue.prototype.enqueueSetState">
        function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>enqueueSetState
        <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueSetState(publicInstance, partialState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
  } else {
    warnNoop(publicInstance, 'setState');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueSetState</span>(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactServerUpdateQueue.prototype.isMounted" id="apidoc.element.react-dom.ReactServerUpdateQueue.prototype.isMounted">
        function <span class="apidocSignatureSpan">react-dom.ReactServerUpdateQueue.prototype.</span>isMounted
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMounted(publicInstance) {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactShallowRenderer" id="apidoc.module.react-dom.ReactShallowRenderer">module react-dom.ReactShallowRenderer</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.ReactShallowRenderer" id="apidoc.element.react-dom.ReactShallowRenderer.ReactShallowRenderer">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactShallowRenderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);

  this._instance = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.createRenderer" id="apidoc.element.react-dom.ReactShallowRenderer.createRenderer">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.</span>createRenderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRenderer = function () {
  return new ReactShallowRenderer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

// In react 16+ shallowRenderer will not be accessible via ReactTestUtils.<span class="apidocCodeKeywordSpan">createRenderer</span>()
// Instead it will be available via react-test-renderer/shallow
// Maintain backwards compat for 15.5.0 release, but warn about using the deprecated method
var hasWarnedAboutCreateRenderer = false;
function createRendererWithWarning() {
process.env.NODE_ENV !== 'production' ? warning(hasWarnedAboutCreateRenderer, 'Shallow renderer has been moved to
 react-test-renderer/shallow. ' + 'Update references to remove this warning.') : void 0;
hasWarnedAboutCreateRenderer = true;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactShallowRenderer.prototype" id="apidoc.module.react-dom.ReactShallowRenderer.prototype">module react-dom.ReactShallowRenderer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.prototype._render" id="apidoc.element.react-dom.ReactShallowRenderer.prototype._render">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>_render
        <span class="apidocSignatureSpan">(element, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _render(element, transaction, context) {
  if (this._instance) {
    ReactReconciler.receiveComponent(this._instance, element, transaction, context);
  } else {
    var instance = new ShallowComponentWrapper(element);
    ReactReconciler.mountComponent(instance, transaction, null, null, context, 0);
    this._instance = instance;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
_replaceNodeWithMarkup: function () {},
_renderValidatedComponent: ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext
});

function _batchedRender(renderer, element, context) {
var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
renderer.<span class="apidocCodeKeywordSpan">_render</span>(element, transaction, context);
ReactUpdates.ReactReconcileTransaction.release(transaction);
}

var ReactShallowRenderer = function () {
function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.getMountedInstance" id="apidoc.element.react-dom.ReactShallowRenderer.prototype.getMountedInstance">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>getMountedInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMountedInstance() {
  return this._instance ? this._instance._instance : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.getRenderOutput" id="apidoc.element.react-dom.ReactShallowRenderer.prototype.getRenderOutput">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>getRenderOutput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRenderOutput() {
  return this._instance &amp;&amp; this._instance._renderedComponent &amp;&amp; this._instance._renderedComponent._renderedOutput || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  !(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer
 render(): Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting
 the rendered output, look at `el.props` directly instead.', element.type) : _prodInvariant('13', element.type) :
void 0;

  if (!context) {
    context = emptyObject;
  }
  ReactUpdates.batchedUpdates(_batchedRender, this, element, context);

  return this.<span class="apidocCodeKeywordSpan">getRenderOutput</span>();
};

ReactShallowRenderer.prototype.getRenderOutput = function getRenderOutput() {
  return this._instance &amp;&amp; this._instance._renderedComponent &amp;&amp; this._instance._renderedComponent._renderedOutput
 || null;
};

ReactShallowRenderer.prototype.unmount = function unmount() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.render" id="apidoc.element.react-dom.ReactShallowRenderer.prototype.render">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>render
        <span class="apidocSignatureSpan">(element, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function render(element, context) {
  // Ensure we've done the default injections. This might not be true in the
  // case of a simple test that only requires React and the TestUtils in
  // conjunction with an inline-requires transform.
  injectDefaults();

  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Invalid
 component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it
 by passing it to React.createElement.' : '') : _prodInvariant('12', typeof element === 'function' ? ' Instead of passing a component
 class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : void 0;
  !(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render():
Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting the rendered
 output, look at `el.props` directly instead.', element.type) : _prodInvariant('13', element.type) : void 0;

  if (!context) {
    context = emptyObject;
  }
  ReactUpdates.batchedUpdates(_batchedRender, this, element, context);

  return this.getRenderOutput();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello World&lt;/div&gt;;
  }
}

ReactDOM.<span class="apidocCodeKeywordSpan">render</span>(&lt;MyComponent /&gt;, node);
```

### On the server

```js
var React = require('react');
var ReactDOMServer = require('react-dom/server');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactShallowRenderer.prototype.unmount" id="apidoc.element.react-dom.ReactShallowRenderer.prototype.unmount">
        function <span class="apidocSignatureSpan">react-dom.ReactShallowRenderer.prototype.</span>unmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmount() {
  if (this._instance) {
    ReactReconciler.unmountComponent(this._instance, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactSimpleEmptyComponent" id="apidoc.module.react-dom.ReactSimpleEmptyComponent">module react-dom.ReactSimpleEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent" id="apidoc.element.react-dom.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactSimpleEmptyComponent
        <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactSimpleEmptyComponent = function (placeholderElement, instantiate) {
  this._currentElement = null;
  this._renderedComponent = instantiate(placeholderElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactSimpleEmptyComponent.prototype" id="apidoc.module.react-dom.ReactSimpleEmptyComponent.prototype">module react-dom.ReactSimpleEmptyComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.getHostNode" id="apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactReconciler.getHostNode(this._renderedComponent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.mountComponent" id="apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots ) {
  return ReactReconciler.mountComponent(this._renderedComponent, transaction, hostParent, hostContainerInfo, context, parentDebugID
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it's mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.receiveComponent" id="apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &amp;&amp; prevChildren[name];
var prevElement = prevChild &amp;&amp; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.unmountComponent" id="apidoc.element.react-dom.ReactSimpleEmptyComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactSimpleEmptyComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  ReactReconciler.unmountComponent(this._renderedComponent);
  this._renderedComponent = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it's mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactTestReconcileTransaction" id="apidoc.module.react-dom.ReactTestReconcileTransaction">module react-dom.ReactTestReconcileTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.ReactTestReconcileTransaction" id="apidoc.element.react-dom.ReactTestReconcileTransaction.ReactTestReconcileTransaction">
        function <span class="apidocSignatureSpan">react-dom.</span>ReactTestReconcileTransaction
        <span class="apidocSignatureSpan">(testOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestReconcileTransaction(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue.getPooled(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.getPooled" id="apidoc.element.react-dom.ReactTestReconcileTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.release" id="apidoc.element.react-dom.ReactTestReconcileTransaction.release">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactTestReconcileTransaction.prototype" id="apidoc.module.react-dom.ReactTestReconcileTransaction.prototype">module react-dom.ReactTestReconcileTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.checkpoint" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {
  // reactMountReady is the our only stateful wrapper
  return this.reactMountReady.checkpoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.closeAll" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction
 when none are open.') : _prodInvariant('28') : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn't throw, we don't want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.destructor" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  CallbackQueue.release(this.reactMountReady);
  this.reactMountReady = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getReactMountReady" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return this.reactMountReady;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== 'production') {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, 'componentDidMount');
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTestOptions" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTestOptions">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getTestOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTestOptions = function () {
  return this.testOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * "PooledClass".
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getUpdateQueue" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return ReactUpdateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.initializeAll" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it's still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it's still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.isInTransaction" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance to use as `this` context.
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.<span class="apidocCodeKeywordSpan">isInTransaction</span>()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.perform" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it's still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn't throw, we don't want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.rollback" id="apidoc.element.react-dom.ReactTestReconcileTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-dom.ReactTestReconcileTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">(checkpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (checkpoint) {
  this.reactMountReady.rollback(checkpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactTestUtils" id="apidoc.module.react-dom.ReactTestUtils">module react-dom.ReactTestUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.createRenderer" id="apidoc.element.react-dom.ReactTestUtils.createRenderer">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>createRenderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRendererWithWarning() {
  process.env.NODE_ENV !== 'production' ? warning(hasWarnedAboutCreateRenderer, 'Shallow renderer has been moved to react-test-renderer
/shallow. ' + 'Update references to remove this warning.') : void 0;
  hasWarnedAboutCreateRenderer = true;

  return new ReactShallowRenderer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

// In react 16+ shallowRenderer will not be accessible via ReactTestUtils.<span class="apidocCodeKeywordSpan">createRenderer</span>()
// Instead it will be available via react-test-renderer/shallow
// Maintain backwards compat for 15.5.0 release, but warn about using the deprecated method
var hasWarnedAboutCreateRenderer = false;
function createRendererWithWarning() {
process.env.NODE_ENV !== 'production' ? warning(hasWarnedAboutCreateRenderer, 'Shallow renderer has been moved to
 react-test-renderer/shallow. ' + 'Update references to remove this warning.') : void 0;
hasWarnedAboutCreateRenderer = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.findAllInRenderedTree" id="apidoc.element.react-dom.ReactTestUtils.findAllInRenderedTree">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findAllInRenderedTree
        <span class="apidocSignatureSpan">(inst, test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findAllInRenderedTree = function (inst, test) {
  if (!inst) {
    return [];
  }
  !ReactTestUtils.isCompositeComponent(inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findAllInRenderedTree(...):
instance must be a composite component') : _prodInvariant('10') : void 0;
  return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Finds all instance of components in the rendered tree that are DOM
 * components with the class name matching `className`.
 * @return {array} an array of all the matches.
 */
scryRenderedDOMComponentsWithClass: function (root, classNames) {
  return ReactTestUtils.<span class="apidocCodeKeywordSpan">findAllInRenderedTree</span>(root, function (inst) {
    if (ReactTestUtils.isDOMComponent(inst)) {
      var className = inst.className;
      if (typeof className !== 'string') {
        // SVG, probably.
        className = inst.getAttribute('class') || '';
      }
      var classList = className.split(/\s+/);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.findRenderedComponentWithType" id="apidoc.element.react-dom.ReactTestUtils.findRenderedComponentWithType">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedComponentWithType
        <span class="apidocSignatureSpan">(root, componentType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRenderedComponentWithType = function (root, componentType) {
  var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
  }
  return all[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithClass" id="apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithClass">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedDOMComponentWithClass
        <span class="apidocSignatureSpan">(root, className)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRenderedDOMComponentWithClass = function (root, className) {
  var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
  }
  return all[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithTag" id="apidoc.element.react-dom.ReactTestUtils.findRenderedDOMComponentWithTag">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>findRenderedDOMComponentWithTag
        <span class="apidocSignatureSpan">(root, tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRenderedDOMComponentWithTag = function (root, tagName) {
  var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
  }
  return all[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.getRenderedChildOfCompositeComponent" id="apidoc.element.react-dom.ReactTestUtils.getRenderedChildOfCompositeComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>getRenderedChildOfCompositeComponent
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRenderedChildOfCompositeComponent = function (inst) {
  if (!ReactTestUtils.isCompositeComponent(inst)) {
    return null;
  }
  var internalInstance = ReactInstanceMap.get(inst);
  return internalInstance._renderedComponent.getPublicInstance();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponent" id="apidoc.element.react-dom.ReactTestUtils.isCompositeComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponent
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompositeComponent = function (inst) {
  if (ReactTestUtils.isDOMComponent(inst)) {
    // Accessing inst.setState warns; just return false as that'll be what
    // this returns when we have DOM nodes as refs directly
    return false;
  }
  return inst != null &amp;&amp; typeof inst.render === 'function' &amp;&amp; typeof inst.setState === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // this returns when we have DOM nodes as refs directly
    return false;
  }
  return inst != null &amp;&amp; typeof inst.render === 'function' &amp;&amp; typeof inst.setState === 'function
';
},

isCompositeComponentWithType: function (inst, type) {
  if (!ReactTestUtils.<span class="apidocCodeKeywordSpan">isCompositeComponent</span>(inst)) {
    return false;
  }
  var internalInstance = ReactInstanceMap.get(inst);
  var constructor = internalInstance._currentElement.type;

  return constructor === type;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElement" id="apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElement">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentElement
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompositeComponentElement = function (inst) {
  if (!React.isValidElement(inst)) {
    return false;
  }
  // We check the prototype of the type that will get mounted, not the
  // instance itself. This is a future proof way of duck typing.
  var prototype = inst.type.prototype;
  return typeof prototype.render === 'function' &amp;&amp; typeof prototype.setState === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return typeof prototype.render === 'function' &amp;&amp; typeof prototype.setState === 'function';
},

isCompositeComponentElementWithType: function (inst, type) {
  var internalInstance = ReactInstanceMap.get(inst);
  var constructor = internalInstance._currentElement.type;

  return !!(ReactTestUtils.<span class="apidocCodeKeywordSpan">isCompositeComponentElement</span>(inst) &amp;&amp; constructor
 === type);
},

getRenderedChildOfCompositeComponent: function (inst) {
  if (!ReactTestUtils.isCompositeComponent(inst)) {
    return null;
  }
  var internalInstance = ReactInstanceMap.get(inst);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElementWithType" id="apidoc.element.react-dom.ReactTestUtils.isCompositeComponentElementWithType">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentElementWithType
        <span class="apidocSignatureSpan">(inst, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompositeComponentElementWithType = function (inst, type) {
  var internalInstance = ReactInstanceMap.get(inst);
  var constructor = internalInstance._currentElement.type;

  return !!(ReactTestUtils.isCompositeComponentElement(inst) &amp;&amp; constructor === type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isCompositeComponentWithType" id="apidoc.element.react-dom.ReactTestUtils.isCompositeComponentWithType">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isCompositeComponentWithType
        <span class="apidocSignatureSpan">(inst, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompositeComponentWithType = function (inst, type) {
  if (!ReactTestUtils.isCompositeComponent(inst)) {
    return false;
  }
  var internalInstance = ReactInstanceMap.get(inst);
  var constructor = internalInstance._currentElement.type;

  return constructor === type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Finds all instances of components with type equal to `componentType`.
 * @return {array} an array of all the matches.
 */
scryRenderedComponentsWithType: function (root, componentType) {
  return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
    return ReactTestUtils.<span class="apidocCodeKeywordSpan">isCompositeComponentWithType</span>(inst, componentType);
  });
},

/**
 * Same as `scryRenderedComponentsWithType` but expects there to be one result
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isDOMComponent" id="apidoc.element.react-dom.ReactTestUtils.isDOMComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isDOMComponent
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDOMComponent = function (inst) {
  return !!(inst &amp;&amp; inst.nodeType === 1 &amp;&amp; inst.tagName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function findAllInRenderedTreeInternal(inst, test) {
if (!inst || !inst.getPublicInstance) {
  return [];
}
var publicInst = inst.getPublicInstance();
var ret = test(publicInst) ? [publicInst] : [];
var currentElement = inst._currentElement;
if (ReactTestUtils.<span class="apidocCodeKeywordSpan">isDOMComponent</span>(publicInst)) {
  var renderedChildren = inst._renderedChildren;
  var key;
  for (key in renderedChildren) {
    if (!renderedChildren.hasOwnProperty(key)) {
      continue;
    }
    ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isDOMComponentElement" id="apidoc.element.react-dom.ReactTestUtils.isDOMComponentElement">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isDOMComponentElement
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDOMComponentElement = function (inst) {
  return !!(inst &amp;&amp; React.isValidElement(inst) &amp;&amp; !!inst.tagName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isElement" id="apidoc.element.react-dom.ReactTestUtils.isElement">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isElement = function (element) {
  return React.isValidElement(element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  expect(instance).not.toBeUndefined();

  !ReactTestUtils.isCompositeComponent(instance) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'reactComponentExpect
(...): instance must be a composite component') : _prodInvariant('15') : void 0;
  var internalInstance = ReactInstanceMap.get(instance);

  expect(typeof internalInstance).toBe('object');
  expect(typeof internalInstance.constructor).toBe('function');
  expect(ReactTestUtils.<span class="apidocCodeKeywordSpan">isElement</span>(internalInstance)).toBe(false);

  return new reactComponentExpectInternal(internalInstance);
}

function reactComponentExpectInternal(internalInstance) {
  this._instance = internalInstance;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.isElementOfType" id="apidoc.element.react-dom.ReactTestUtils.isElementOfType">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>isElementOfType
        <span class="apidocSignatureSpan">(inst, convenienceConstructor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isElementOfType = function (inst, convenienceConstructor) {
  return React.isValidElement(inst) &amp;&amp; inst.type === convenienceConstructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.mockComponent" id="apidoc.element.react-dom.ReactTestUtils.mockComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>mockComponent
        <span class="apidocSignatureSpan">(module, mockTagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mockComponent = function (module, mockTagName) {
  mockTagName = mockTagName || module.mockTagName || 'div';

  module.prototype.render.mockImplementation(function () {
    return React.createElement(mockTagName, null, this.props.children);
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.nativeTouchData" id="apidoc.element.react-dom.ReactTestUtils.nativeTouchData">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>nativeTouchData
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeTouchData = function (x, y) {
  return {
    touches: [{ pageX: x, pageY: y }]
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.renderIntoDocument" id="apidoc.element.react-dom.ReactTestUtils.renderIntoDocument">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>renderIntoDocument
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderIntoDocument = function (element) {
  var div = document.createElement('div');
  // None of our tests actually require attaching the container to the
  // DOM, and doing so creates a mess that we rely on test isolation to
  // clean up, so we're going to stop honoring the name of this method
  // (and probably rename it eventually) if no problems arise.
  // document.documentElement.appendChild(div);
  return ReactDOM.render(element, div);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedComponentsWithType" id="apidoc.element.react-dom.ReactTestUtils.scryRenderedComponentsWithType">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedComponentsWithType
        <span class="apidocSignatureSpan">(root, componentType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scryRenderedComponentsWithType = function (root, componentType) {
  return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
    return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Same as `scryRenderedComponentsWithType` but expects there to be one result
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactComponent} The one match.
 */
findRenderedComponentWithType: function (root, componentType) {
  var all = ReactTestUtils.<span class="apidocCodeKeywordSpan">scryRenderedComponentsWithType</span>(root, componentType);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:&amp;#
x27; + componentType);
  }
  return all[0];
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithClass" id="apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithClass">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedDOMComponentsWithClass
        <span class="apidocSignatureSpan">(root, classNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scryRenderedDOMComponentsWithClass = function (root, classNames) {
  return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
    if (ReactTestUtils.isDOMComponent(inst)) {
      var className = inst.className;
      if (typeof className !== 'string') {
        // SVG, probably.
        className = inst.getAttribute('class') || '';
      }
      var classList = className.split(/\s+/);

      if (!Array.isArray(classNames)) {
        !(classNames !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'TestUtils.scryRenderedDOMComponentsWithClass
 expects a className as a second argument.') : _prodInvariant('11') : void 0;
        classNames = classNames.split(/\s+/);
      }
      return classNames.every(function (name) {
        return classList.indexOf(name) !== -1;
      });
    }
    return false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactDOMComponent} The one match.
 */
findRenderedDOMComponentWithClass: function (root, className) {
  var all = ReactTestUtils.<span class="apidocCodeKeywordSpan">scryRenderedDOMComponentsWithClass</span>(root, className);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' +
className);
  }
  return all[0];
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithTag" id="apidoc.element.react-dom.ReactTestUtils.scryRenderedDOMComponentsWithTag">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>scryRenderedDOMComponentsWithTag
        <span class="apidocSignatureSpan">(root, tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scryRenderedDOMComponentsWithTag = function (root, tagName) {
  return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
    return ReactTestUtils.isDOMComponent(inst) &amp;&amp; inst.tagName.toUpperCase() === tagName.toUpperCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactDOMComponent} The one match.
 */
findRenderedDOMComponentWithTag: function (root, tagName) {
  var all = ReactTestUtils.<span class="apidocCodeKeywordSpan">scryRenderedDOMComponentsWithTag</span>(root, tagName);
  if (all.length !== 1) {
    throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName
);
  }
  return all[0];
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnDOMComponent" id="apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnDOMComponent">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>simulateNativeEventOnDOMComponent
        <span class="apidocSignatureSpan">(topLevelType, comp, fakeNativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simulateNativeEventOnDOMComponent = function (topLevelType, comp, fakeNativeEvent) {
  ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

function makeNativeSimulator(eventType) {
  return function (domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    _assign(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.<span class="apidocCodeKeywordSpan">simulateNativeEventOnDOMComponent</span>(eventType, domComponentOrNode,
fakeNativeEvent);
    } else if (domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
    }
  };
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnNode" id="apidoc.element.react-dom.ReactTestUtils.simulateNativeEventOnNode">
        function <span class="apidocSignatureSpan">react-dom.ReactTestUtils.</span>simulateNativeEventOnNode
        <span class="apidocSignatureSpan">(topLevelType, node, fakeNativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simulateNativeEventOnNode = function (topLevelType, node, fakeNativeEvent) {
  fakeNativeEvent.target = node;
  ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Simulates a top level event being dispatched from a raw event that occurred
 * on the `ReactDOMComponent` `comp`.
 * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`.
 * @param {!ReactDOMComponent} comp
 * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
 */
simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
  ReactTestUtils.<span class="apidocCodeKeywordSpan">simulateNativeEventOnNode</span>(topLevelType, findDOMNode(comp), fakeNativeEvent
);
},

nativeTouchData: function (x, y) {
  return {
    touches: [{ pageX: x, pageY: y }]
  };
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactUpdateQueue" id="apidoc.module.react-dom.ReactUpdateQueue">module react-dom.ReactUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueCallback" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueCallback">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueCallback
        <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueCallback = function (publicInstance, callback, callerName) {
  ReactUpdateQueue.validateCallback(callback, callerName);
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

  // Previously we would throw an error if we didn't have an internal
  // instance. Since we want to make it a no-op instead, we mirror the same
  // behavior we have in other enqueue* methods.
  // We also need to ignore callbacks in componentWillMount. See
  // enqueueUpdates.
  if (!internalInstance) {
    return null;
  }

  if (internalInstance._pendingCallbacks) {
    internalInstance._pendingCallbacks.push(callback);
  } else {
    internalInstance._pendingCallbacks = [callback];
  }
  // TODO: The callback here is ignored when setState is called from
  // componentWillMount. Either fix it or disallow doing so completely in
  // favor of getInitialState. Alternatively, we can disallow
  // componentWillMount during server-side rendering.
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallback</span>(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueCallbackInternal" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueCallbackInternal">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueCallbackInternal
        <span class="apidocSignatureSpan">(internalInstance, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueCallbackInternal = function (internalInstance, callback) {
  if (internalInstance._pendingCallbacks) {
    internalInstance._pendingCallbacks.push(callback);
  } else {
    internalInstance._pendingCallbacks = [callback];
  }
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DOMElement} container container to render into
 * @param {?function} callback function triggered on completion
 */
_updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallbackInternal</span>(prevComponent, callback);
    }
  });

  return prevComponent;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueElementInternal" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueElementInternal">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueElementInternal
        <span class="apidocSignatureSpan">(internalInstance, nextElement, nextContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueElementInternal = function (internalInstance, nextElement, nextContext) {
  internalInstance._pendingElement = nextElement;
  // TODO: introduce _pendingContext instead of setting it directly.
  internalInstance._context = nextContext;
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactComponent} prevComponent component instance already in the DOM
 * @param {ReactElement} nextElement component instance to render
 * @param {DOMElement} container container to render into
 * @param {?function} callback function triggered on completion
 */
_updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueElementInternal</span>(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
    }
  });

  return prevComponent;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueForceUpdate" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueForceUpdate">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueForceUpdate
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueForceUpdate = function (publicInstance) {
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

  if (!internalInstance) {
    return;
  }

  internalInstance._pendingForceUpdate = true;

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance that should rerender.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueForceUpdate</span>(publicInstance);
  } else {
    warnNoop(publicInstance, 'forceUpdate');
  }
};

/**
 * Replaces all of the state. Always use this or `setState` to mutate state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueReplaceState" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueReplaceState">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueReplaceState
        <span class="apidocSignatureSpan">(publicInstance, completeState, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueReplaceState = function (publicInstance, completeState, callback) {
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

  if (!internalInstance) {
    return;
  }

  internalInstance._pendingStateQueue = [completeState];
  internalInstance._pendingReplaceState = true;

  // Future-proof 15.5
  if (callback !== undefined &amp;&amp; callback !== null) {
    ReactUpdateQueue.validateCallback(callback, 'replaceState');
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
  }

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object|function} completeState Next state.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueReplaceState</span>(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, 'replaceState');
  }
};

/**
 * Sets a subset of the state. This only exists because _pendingState is
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.enqueueSetState" id="apidoc.element.react-dom.ReactUpdateQueue.enqueueSetState">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>enqueueSetState
        <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueSetState = function (publicInstance, partialState) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetState();
    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state
object; ' + 'instead, use forceUpdate().') : void 0;
  }

  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

  if (!internalInstance) {
    return;
  }

  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
  queue.push(partialState);

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueSetState</span>(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.isMounted" id="apidoc.element.react-dom.ReactUpdateQueue.isMounted">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>isMounted
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMounted = function (publicInstance) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render
() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale
 data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner
.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (internalInstance) {
    // During componentWillMount and render this will still be null but after
    // that will always render to something. At least for now. So we can use
    // this hack.
    return !!internalInstance._renderedComponent;
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdateQueue.validateCallback" id="apidoc.element.react-dom.ReactUpdateQueue.validateCallback">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdateQueue.</span>validateCallback
        <span class="apidocSignatureSpan">(callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateCallback = function (callback, callerName) {
  !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the
 last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant
('122', callerName, formatUnexpectedArgument(callback)) : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
!(parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ?
invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
ReactUpdateQueue.<span class="apidocCodeKeywordSpan">validateCallback</span>(callback, 'ReactDOM.render');
!React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render():
Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' :
// Check if it quacks like an element
nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent
 ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string'
; ? ' Instead of passing a string like\'div\', pass ' + 'React.createElement(\'div\') or &lt;div /&gt;.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or &lt;Foo /&gt;.' : nextElement != null &amp;&amp; nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== &amp;#
x27;BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children
 are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation
 issues. Try rendering into a container element created ' + 'for your app.') : void 0;

var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ReactUpdates" id="apidoc.module.react-dom.ReactUpdates">module react-dom.ReactUpdates</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdates.ReactReconcileTransaction" id="apidoc.element.react-dom.ReactUpdates.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(useCreateElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdates.asap" id="apidoc.element.react-dom.ReactUpdates.asap">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>asap
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue
 an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.<span class="apidocCodeKeywordSpan">asap</span>(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' &amp;&amp; name != null) {
var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
var queryRoot = rootNode;

while (queryRoot.parentNode) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdates.batchedUpdates" id="apidoc.element.react-dom.ReactUpdates.batchedUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdates.enqueueUpdate" id="apidoc.element.react-dom.ReactUpdates.enqueueUpdate">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>enqueueUpdate
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
ReactUpdates.<span class="apidocCodeKeywordSpan">enqueueUpdate</span>(internalInstance);
}

function formatUnexpectedArgument(arg) {
var type = typeof arg;
if (type !== 'object') {
  return type;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ReactUpdates.flushBatchedUpdates" id="apidoc.element.react-dom.ReactUpdates.flushBatchedUpdates">
        function <span class="apidocSignatureSpan">react-dom.ReactUpdates.</span>flushBatchedUpdates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ResponderEventPlugin" id="apidoc.module.react-dom.ResponderEventPlugin">module react-dom.ResponderEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ResponderEventPlugin._getResponderID" id="apidoc.element.react-dom.ResponderEventPlugin._getResponderID">
        function <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>_getResponderID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getResponderID = function () {
  return responderInst ? responderInst._rootNodeID : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ResponderEventPlugin.extractEvents" id="apidoc.element.react-dom.ResponderEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.ResponderEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (isStartish(topLevelType)) {
    trackedTouchCount += 1;
  } else if (isEndish(topLevelType)) {
    if (trackedTouchCount &gt;= 0) {
      trackedTouchCount -= 1;
    } else {
      console.error('Ended a touch event which was not counted in `trackedTouchCount`.');
      return null;
    }
  }

  ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

  var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst
, nativeEvent, nativeEventTarget) : null;
  // Responder may or may not have transferred on a new touch start/move.
  // Regardless, whoever is the responder after any potential transfer, we
  // direct all touch start/move/ends to them in the form of
  // `onResponderMove/Start/End`. These will be called for *every* additional
  // finger that move/start/end, dispatched directly to whoever is the
  // current responder at that moment, until the responder is "released".
  //
  // These multiple individual change touch events are are always bookended
  // by `onResponderGrant`, and one of
  // (`onResponderRelease/onResponderTerminate`).
  var isResponderTouchStart = responderInst &amp;&amp; isStartish(topLevelType);
  var isResponderTouchMove = responderInst &amp;&amp; isMoveish(topLevelType);
  var isResponderTouchEnd = responderInst &amp;&amp; isEndish(topLevelType);
  var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd
 ? eventTypes.responderEnd : null;

  if (incrementalTouch) {
    var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
    gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
    EventPropagators.accumulateDirectDispatches(gesture);
    extracted = accumulate(extracted, gesture);
  }

  var isResponderTerminate = responderInst &amp;&amp; topLevelType === 'topTouchCancel';
  var isResponderRelease = responderInst &amp;&amp; !isResponderTerminate &amp;&amp; isEndish(topLevelType) &amp;&amp; noResponderTouches(nativeEvent);
  var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null
;
  if (finalTouch) {
    var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
    finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
    EventPropagators.accumulateDirectDispatches(finalEvent);
    extracted = accumulate(extracted, finalEvent);
    changeResponder(null);
  }

  var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;
  if (ResponderEventPlugin.GlobalInteractionHandler &amp;&amp; numberActiveTouches !== previousActiveTouches) {
    ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);
  }
  previousActiveTouches = numberActiveTouches;

  return extracted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ResponderSyntheticEvent" id="apidoc.module.react-dom.ResponderSyntheticEvent">module react-dom.ResponderSyntheticEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent.ResponderSyntheticEvent" id="apidoc.element.react-dom.ResponderSyntheticEvent.ResponderSyntheticEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>ResponderSyntheticEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent.augmentClass" id="apidoc.element.react-dom.ResponderSyntheticEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent.getPooled" id="apidoc.element.react-dom.ResponderSyntheticEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent.release" id="apidoc.element.react-dom.ResponderSyntheticEvent.release">
        function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ResponderSyntheticEvent.prototype" id="apidoc.module.react-dom.ResponderSyntheticEvent.prototype">module react-dom.ResponderSyntheticEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ResponderSyntheticEvent.prototype.constructor" id="apidoc.element.react-dom.ResponderSyntheticEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.ResponderSyntheticEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ResponderTouchHistoryStore" id="apidoc.module.react-dom.ResponderTouchHistoryStore">module react-dom.ResponderTouchHistoryStore</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ResponderTouchHistoryStore.recordTouchTrack" id="apidoc.element.react-dom.ResponderTouchHistoryStore.recordTouchTrack">
        function <span class="apidocSignatureSpan">react-dom.ResponderTouchHistoryStore.</span>recordTouchTrack
        <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recordTouchTrack = function (topLevelType, nativeEvent) {
  if (isMoveish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchMove);
  } else if (isStartish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchStart);
    touchHistory.numberActiveTouches = nativeEvent.touches.length;
    if (touchHistory.numberActiveTouches === 1) {
      touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
    }
  } else if (isEndish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchEnd);
    touchHistory.numberActiveTouches = nativeEvent.touches.length;
    if (touchHistory.numberActiveTouches === 1) {
      for (var i = 0; i &lt; touchBank.length; i++) {
        var touchTrackToCheck = touchBank[i];
        if (touchTrackToCheck != null &amp;&amp; touchTrackToCheck.touchActive) {
          touchHistory.indexOfSingleActiveTouch = i;
          break;
        }
      }
      if (process.env.NODE_ENV !== 'production') {
        var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
        process.env.NODE_ENV !== 'production' ? warning(activeRecord != null &amp;&amp; activeRecord.touchActive, 'Cannot find single active
 touch.') : void 0;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    trackedTouchCount -= 1;
  } else {
    console.error('Ended a touch event which was not counted in `trackedTouchCount`.');
    return null;
  }
}

ResponderTouchHistoryStore.<span class="apidocCodeKeywordSpan">recordTouchTrack</span>(topLevelType, nativeEvent);

var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst
, nativeEvent, nativeEventTarget) : null;
// Responder may or may not have transferred on a new touch start/move.
// Regardless, whoever is the responder after any potential transfer, we
// direct all touch start/move/ends to them in the form of
// `onResponderMove/Start/End`. These will be called for *every* additional
// finger that move/start/end, dispatched directly to whoever is the
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SelectEventPlugin" id="apidoc.module.react-dom.SelectEventPlugin">module react-dom.SelectEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SelectEventPlugin.didPutListener" id="apidoc.element.react-dom.SelectEventPlugin.didPutListener">
        function <span class="apidocSignatureSpan">react-dom.SelectEventPlugin.</span>didPutListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">didPutListener = function (inst, registrationName, listener) {
  if (registrationName === 'onSelect') {
    hasListener = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &amp;&amp; PluginModule.didPutListener) {
    PluginModule.<span class="apidocCodeKeywordSpan">didPutListener</span>(inst, registrationName, listener);
  }
},

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SelectEventPlugin.extractEvents" id="apidoc.element.react-dom.SelectEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.SelectEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (!hasListener) {
    return null;
  }

  var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

  switch (topLevelType) {
    // Track the input node that has focus.
    case 'topFocus':
      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
        activeElement = targetNode;
        activeElementInst = targetInst;
        lastSelection = null;
      }
      break;
    case 'topBlur':
      activeElement = null;
      activeElementInst = null;
      lastSelection = null;
      break;

    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.
    case 'topMouseDown':
      mouseDown = true;
      break;
    case 'topContextMenu':
    case 'topMouseUp':
      mouseDown = false;
      return constructSelectEvent(nativeEvent, nativeEventTarget);

    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.
    case 'topSelectionChange':
      if (skipSelectionChangeEvent) {
        break;
      }
    // falls through
    case 'topKeyDown':
    case 'topKeyUp':
      return constructSelectEvent(nativeEvent, nativeEventTarget);
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SimpleEventPlugin" id="apidoc.module.react-dom.SimpleEventPlugin">module react-dom.SimpleEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SimpleEventPlugin.didPutListener" id="apidoc.element.react-dom.SimpleEventPlugin.didPutListener">
        function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>didPutListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">didPutListener = function (inst, registrationName, listener) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  if (registrationName === 'onClick' &amp;&amp; !isInteractive(inst._tag)) {
    var key = getDictionaryKey(inst);
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    if (!onClickListeners[key]) {
      onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &amp;&amp; PluginModule.didPutListener) {
    PluginModule.<span class="apidocCodeKeywordSpan">didPutListener</span>(inst, registrationName, listener);
  }
},

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SimpleEventPlugin.extractEvents" id="apidoc.element.react-dom.SimpleEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
  if (!dispatchConfig) {
    return null;
  }
  var EventConstructor;
  switch (topLevelType) {
    case 'topAbort':
    case 'topCanPlay':
    case 'topCanPlayThrough':
    case 'topDurationChange':
    case 'topEmptied':
    case 'topEncrypted':
    case 'topEnded':
    case 'topError':
    case 'topInput':
    case 'topInvalid':
    case 'topLoad':
    case 'topLoadedData':
    case 'topLoadedMetadata':
    case 'topLoadStart':
    case 'topPause':
    case 'topPlay':
    case 'topPlaying':
    case 'topProgress':
    case 'topRateChange':
    case 'topReset':
    case 'topSeeked':
    case 'topSeeking':
    case 'topStalled':
    case 'topSubmit':
    case 'topSuspend':
    case 'topTimeUpdate':
    case 'topVolumeChange':
    case 'topWaiting':
      // HTML Events
      // @see http://www.w3.org/TR/html5/index.html#events-0
      EventConstructor = SyntheticEvent;
      break;
    case 'topKeyPress':
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn't).
      if (getEventCharCode(nativeEvent) === 0) {
        return null;
      }
<span class="apidocCodeCommentSpan">    /* falls through */
</span>    case 'topKeyDown':
    case 'topKeyUp':
      EventConstructor = SyntheticKeyboardEvent;
      break;
    case 'topBlur':
    case 'topFocus':
      EventConstructor = SyntheticFocusEvent;
      break;
    case 'topClick':
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return null;
      }
    /* falls through */
    case 'topDoubleClick':
    case 'topMouseDown':
    case 'topMouseMove':
    case 'topMouseUp':
    // TODO: Disabled elements should not respond to mouse events
    /* falls through */
    case 'topMouseOut':
    case 'topMouseOver':
    case 'topContextMenu':
      EventConstructor = SyntheticMouseEvent;
      break;
    case 'topDrag':
    case 'topDragEnd':
    case 'topDragEnter':
    case 'topDragExit':
    case 'topDragLeave':
    case 'topDragOver':
    case 'topDragStart':
    case 'topDrop':
      EventConstructor = SyntheticDragEvent;
      break;
    case 'topTouchCancel':
    case 'topTouchEnd':
    case 'topTouchMove':
    case 'topTouchStart':
      EventConstructor = SyntheticTouchEvent;
      break;
    case 'topAnimationEnd':
    case 'topAnimationIteration':
    case 'topAnimationStart':
      EventConstructor = SyntheticAnimationEvent;
      break;
    case 'topTransitionEnd':
      EventConstructor = SyntheticTransitionEvent;
      break;
    case 'topScroll':
      EventConstructor = SyntheticUIEvent;
      break;
    case 'topWheel':
      EventConstructor = SyntheticWheelEvent;
      break;
    case 'topCopy':
    case 'topCut':
    case 'topPaste':
      EventConstructor = SyntheticClipboardEvent;
      break;
  }
  !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.',
topLevelType) : _prodInvariant('86', topLevelType) : void 0;
  var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SimpleEventPlugin.willDeleteListener" id="apidoc.element.react-dom.SimpleEventPlugin.willDeleteListener">
        function <span class="apidocSignatureSpan">react-dom.SimpleEventPlugin.</span>willDeleteListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">willDeleteListener = function (inst, registrationName) {
  if (registrationName === 'onClick' &amp;&amp; !isInteractive(inst._tag)) {
    var key = getDictionaryKey(inst);
    onClickListeners[key].remove();
    delete onClickListeners[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
if (PluginModule &amp;&amp; PluginModule.willDeleteListener) {
  PluginModule.<span class="apidocCodeKeywordSpan">willDeleteListener</span>(inst, registrationName);
}

var bankForRegistrationName = listenerBank[registrationName];
// TODO: This should never be null -- when is it?
if (bankForRegistrationName) {
  var key = getDictionaryKey(inst);
  delete bankForRegistrationName[key];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticAnimationEvent" id="apidoc.module.react-dom.SyntheticAnimationEvent">module react-dom.SyntheticAnimationEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent.SyntheticAnimationEvent" id="apidoc.element.react-dom.SyntheticAnimationEvent.SyntheticAnimationEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticAnimationEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent.augmentClass" id="apidoc.element.react-dom.SyntheticAnimationEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent.getPooled" id="apidoc.element.react-dom.SyntheticAnimationEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent.release" id="apidoc.element.react-dom.SyntheticAnimationEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticAnimationEvent.prototype" id="apidoc.module.react-dom.SyntheticAnimationEvent.prototype">module react-dom.SyntheticAnimationEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticAnimationEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticAnimationEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticAnimationEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticClipboardEvent" id="apidoc.module.react-dom.SyntheticClipboardEvent">module react-dom.SyntheticClipboardEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent.SyntheticClipboardEvent" id="apidoc.element.react-dom.SyntheticClipboardEvent.SyntheticClipboardEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticClipboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent.augmentClass" id="apidoc.element.react-dom.SyntheticClipboardEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent.getPooled" id="apidoc.element.react-dom.SyntheticClipboardEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent.release" id="apidoc.element.react-dom.SyntheticClipboardEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticClipboardEvent.prototype" id="apidoc.module.react-dom.SyntheticClipboardEvent.prototype">module react-dom.SyntheticClipboardEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticClipboardEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticClipboardEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticClipboardEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticCompositionEvent" id="apidoc.module.react-dom.SyntheticCompositionEvent">module react-dom.SyntheticCompositionEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent.SyntheticCompositionEvent" id="apidoc.element.react-dom.SyntheticCompositionEvent.SyntheticCompositionEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticCompositionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent.augmentClass" id="apidoc.element.react-dom.SyntheticCompositionEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent.getPooled" id="apidoc.element.react-dom.SyntheticCompositionEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent.release" id="apidoc.element.react-dom.SyntheticCompositionEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticCompositionEvent.prototype" id="apidoc.module.react-dom.SyntheticCompositionEvent.prototype">module react-dom.SyntheticCompositionEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticCompositionEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticCompositionEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticCompositionEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticDragEvent" id="apidoc.module.react-dom.SyntheticDragEvent">module react-dom.SyntheticDragEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent.SyntheticDragEvent" id="apidoc.element.react-dom.SyntheticDragEvent.SyntheticDragEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticDragEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent.augmentClass" id="apidoc.element.react-dom.SyntheticDragEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent.getPooled" id="apidoc.element.react-dom.SyntheticDragEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent.release" id="apidoc.element.react-dom.SyntheticDragEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticDragEvent.prototype" id="apidoc.module.react-dom.SyntheticDragEvent.prototype">module react-dom.SyntheticDragEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticDragEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticDragEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticDragEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticEvent" id="apidoc.module.react-dom.SyntheticEvent">module react-dom.SyntheticEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.SyntheticEvent" id="apidoc.element.react-dom.SyntheticEvent.SyntheticEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticEvent
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.augmentClass" id="apidoc.element.react-dom.SyntheticEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.getPooled" id="apidoc.element.react-dom.SyntheticEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.release" id="apidoc.element.react-dom.SyntheticEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticEvent.prototype" id="apidoc.module.react-dom.SyntheticEvent.prototype">module react-dom.SyntheticEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.prototype.destructor" id="apidoc.element.react-dom.SyntheticEvent.prototype.destructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (process.env.NODE_ENV !== 'production') {
      Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
    } else {
      this[propName] = null;
    }
  }
  for (var i = 0; i &lt; shouldBeReleasedProperties.length; i++) {
    this[shouldBeReleasedProperties[i]] = null;
  }
  if (process.env.NODE_ENV !== 'production') {
    Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
    Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
    Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance
 into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.prototype.isPersistent" id="apidoc.element.react-dom.SyntheticEvent.prototype.isPersistent">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>isPersistent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPersistent = function () {
  return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.<span class="apidocCodeKeywordSpan">isPersistent</span>()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.prototype.persist" id="apidoc.element.react-dom.SyntheticEvent.prototype.persist">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>persist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persist = function () {
  this.isPersistent = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fakeNativeEvent.type = eventType.toLowerCase();

// We don't use SyntheticEvent.getPooled in order to not have to worry about
// properly destroying any properties assigned from `eventData` upon release
var event = new SyntheticEvent(dispatchConfig, ReactDOMComponentTree.getInstanceFromNode(node), fakeNativeEvent, node);
// Since we aren't using pooling, always persist the event. This will make
// sure it's marked and won't warn when setting additional properties.
event.<span class="apidocCodeKeywordSpan">persist</span>();
_assign(event, eventData);

if (dispatchConfig.phasedRegistrationNames) {
  EventPropagators.accumulateTwoPhaseDispatches(event);
} else {
  EventPropagators.accumulateDirectDispatches(event);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.prototype.preventDefault" id="apidoc.element.react-dom.SyntheticEvent.prototype.preventDefault">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>preventDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preventDefault = function () {
  this.defaultPrevented = true;
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.preventDefault) {
    event.preventDefault();
  } else if (typeof event.returnValue !== 'unknown') {
    // eslint-disable-line valid-typeof
    event.returnValue = false;
  }
  this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.defaultPrevented = true;
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.preventDefault) {
    event.<span class="apidocCodeKeywordSpan">preventDefault</span>();
  } else if (typeof event.returnValue !== 'unknown') {
    // eslint-disable-line valid-typeof
    event.returnValue = false;
  }
  this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticEvent.prototype.stopPropagation" id="apidoc.element.react-dom.SyntheticEvent.prototype.stopPropagation">
        function <span class="apidocSignatureSpan">react-dom.SyntheticEvent.prototype.</span>stopPropagation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopPropagation = function () {
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.stopPropagation) {
    event.stopPropagation();
  } else if (typeof event.cancelBubble !== 'unknown') {
    // eslint-disable-line valid-typeof
    // The ChangeEventPlugin registers a "propertychange" event for
    // IE. This event does not support bubbling or cancelling, and
    // any references to cancelBubble throw "Member not found".  A
    // typeof check of "unknown" circumvents this issue (and is also
    // IE specific).
    event.cancelBubble = true;
  }

  this.isPropagationStopped = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  stopPropagation: function () {
var event = this.nativeEvent;
if (!event) {
  return;
}

if (event.stopPropagation) {
  event.<span class="apidocCodeKeywordSpan">stopPropagation</span>();
} else if (typeof event.cancelBubble !== 'unknown') {
  // eslint-disable-line valid-typeof
  // The ChangeEventPlugin registers a "propertychange" event for
  // IE. This event does not support bubbling or cancelling, and
  // any references to cancelBubble throw "Member not found".  A
  // typeof check of "unknown" circumvents this issue (and is also
  // IE specific).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticFocusEvent" id="apidoc.module.react-dom.SyntheticFocusEvent">module react-dom.SyntheticFocusEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent.SyntheticFocusEvent" id="apidoc.element.react-dom.SyntheticFocusEvent.SyntheticFocusEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticFocusEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent.augmentClass" id="apidoc.element.react-dom.SyntheticFocusEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent.getPooled" id="apidoc.element.react-dom.SyntheticFocusEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent.release" id="apidoc.element.react-dom.SyntheticFocusEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticFocusEvent.prototype" id="apidoc.module.react-dom.SyntheticFocusEvent.prototype">module react-dom.SyntheticFocusEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticFocusEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticFocusEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticFocusEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticInputEvent" id="apidoc.module.react-dom.SyntheticInputEvent">module react-dom.SyntheticInputEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent.SyntheticInputEvent" id="apidoc.element.react-dom.SyntheticInputEvent.SyntheticInputEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticInputEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent.augmentClass" id="apidoc.element.react-dom.SyntheticInputEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent.getPooled" id="apidoc.element.react-dom.SyntheticInputEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent.release" id="apidoc.element.react-dom.SyntheticInputEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticInputEvent.prototype" id="apidoc.module.react-dom.SyntheticInputEvent.prototype">module react-dom.SyntheticInputEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticInputEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticInputEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticInputEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticKeyboardEvent" id="apidoc.module.react-dom.SyntheticKeyboardEvent">module react-dom.SyntheticKeyboardEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent.SyntheticKeyboardEvent" id="apidoc.element.react-dom.SyntheticKeyboardEvent.SyntheticKeyboardEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticKeyboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent.augmentClass" id="apidoc.element.react-dom.SyntheticKeyboardEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent.getPooled" id="apidoc.element.react-dom.SyntheticKeyboardEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent.release" id="apidoc.element.react-dom.SyntheticKeyboardEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticKeyboardEvent.prototype" id="apidoc.module.react-dom.SyntheticKeyboardEvent.prototype">module react-dom.SyntheticKeyboardEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticKeyboardEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticKeyboardEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticKeyboardEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticMouseEvent" id="apidoc.module.react-dom.SyntheticMouseEvent">module react-dom.SyntheticMouseEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent.SyntheticMouseEvent" id="apidoc.element.react-dom.SyntheticMouseEvent.SyntheticMouseEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticMouseEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent.augmentClass" id="apidoc.element.react-dom.SyntheticMouseEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent.getPooled" id="apidoc.element.react-dom.SyntheticMouseEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent.release" id="apidoc.element.react-dom.SyntheticMouseEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticMouseEvent.prototype" id="apidoc.module.react-dom.SyntheticMouseEvent.prototype">module react-dom.SyntheticMouseEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticMouseEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticMouseEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticMouseEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticTouchEvent" id="apidoc.module.react-dom.SyntheticTouchEvent">module react-dom.SyntheticTouchEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent.SyntheticTouchEvent" id="apidoc.element.react-dom.SyntheticTouchEvent.SyntheticTouchEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTouchEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent.augmentClass" id="apidoc.element.react-dom.SyntheticTouchEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent.getPooled" id="apidoc.element.react-dom.SyntheticTouchEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent.release" id="apidoc.element.react-dom.SyntheticTouchEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticTouchEvent.prototype" id="apidoc.module.react-dom.SyntheticTouchEvent.prototype">module react-dom.SyntheticTouchEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTouchEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticTouchEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTouchEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticTransitionEvent" id="apidoc.module.react-dom.SyntheticTransitionEvent">module react-dom.SyntheticTransitionEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent.SyntheticTransitionEvent" id="apidoc.element.react-dom.SyntheticTransitionEvent.SyntheticTransitionEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticTransitionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent.augmentClass" id="apidoc.element.react-dom.SyntheticTransitionEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent.getPooled" id="apidoc.element.react-dom.SyntheticTransitionEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent.release" id="apidoc.element.react-dom.SyntheticTransitionEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticTransitionEvent.prototype" id="apidoc.module.react-dom.SyntheticTransitionEvent.prototype">module react-dom.SyntheticTransitionEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticTransitionEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticTransitionEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticTransitionEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticUIEvent" id="apidoc.module.react-dom.SyntheticUIEvent">module react-dom.SyntheticUIEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent.SyntheticUIEvent" id="apidoc.element.react-dom.SyntheticUIEvent.SyntheticUIEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticUIEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent.augmentClass" id="apidoc.element.react-dom.SyntheticUIEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent.getPooled" id="apidoc.element.react-dom.SyntheticUIEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent.release" id="apidoc.element.react-dom.SyntheticUIEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticUIEvent.prototype" id="apidoc.module.react-dom.SyntheticUIEvent.prototype">module react-dom.SyntheticUIEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticUIEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticUIEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticUIEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticWheelEvent" id="apidoc.module.react-dom.SyntheticWheelEvent">module react-dom.SyntheticWheelEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent.SyntheticWheelEvent" id="apidoc.element.react-dom.SyntheticWheelEvent.SyntheticWheelEvent">
        function <span class="apidocSignatureSpan">react-dom.</span>SyntheticWheelEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent.augmentClass" id="apidoc.element.react-dom.SyntheticWheelEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent.getPooled" id="apidoc.element.react-dom.SyntheticWheelEvent.getPooled">
        function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return null;
}

if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &amp;&amp; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.<span class="apidocCodeKeywordSpan">getPooled</span>(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.getData();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent.release" id="apidoc.element.react-dom.SyntheticWheelEvent.release">
        function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a
pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length &lt; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if (currentComposition) {
  if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType
, nativeEvent)) {
    var chars = currentComposition.getData();
    FallbackCompositionState.<span class="apidocCodeKeywordSpan">release</span>(currentComposition);
    currentComposition = null;
    return chars;
  }
  return null;
}

switch (topLevelType) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.SyntheticWheelEvent.prototype" id="apidoc.module.react-dom.SyntheticWheelEvent.prototype">module react-dom.SyntheticWheelEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.SyntheticWheelEvent.prototype.constructor" id="apidoc.element.react-dom.SyntheticWheelEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-dom.SyntheticWheelEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.TapEventPlugin" id="apidoc.module.react-dom.TapEventPlugin">module react-dom.TapEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.TapEventPlugin.extractEvents" id="apidoc.element.react-dom.TapEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-dom.TapEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (!isStartish(topLevelType) &amp;&amp; !isEndish(topLevelType)) {
    return null;
  }
  // on ios, there is a delay after touch event and synthetic
  // mouse events, so that user can perform double tap
  // solution: ignore mouse events following touchevent within small timeframe
  if (touchEvents.indexOf(topLevelType) !== -1) {
    usedTouch = true;
    usedTouchTime = Date.now();
  } else {
    if (usedTouch &amp;&amp; Date.now() - usedTouchTime &lt; TOUCH_DELAY) {
      return null;
    }
  }
  var event = null;
  var distance = getDistance(startCoords, nativeEvent);
  if (isEndish(topLevelType) &amp;&amp; distance &lt; tapMoveThreshold) {
    event = SyntheticUIEvent.getPooled(eventTypes.touchTap, targetInst, nativeEvent, nativeEventTarget);
  }
  if (isStartish(topLevelType)) {
    startCoords.x = getAxisCoordOfEvent(Axis.x, nativeEvent);
    startCoords.y = getAxisCoordOfEvent(Axis.y, nativeEvent);
  } else if (isEndish(topLevelType)) {
    startCoords.x = 0;
    startCoords.y = 0;
  }
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &lt; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.TouchHistoryMath" id="apidoc.module.react-dom.TouchHistoryMath">module react-dom.TouchHistoryMath</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.centroidDimension" id="apidoc.element.react-dom.TouchHistoryMath.centroidDimension">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>centroidDimension
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter, isXAxis, ofCurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">centroidDimension = function (touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
  var touchBank = touchHistory.touchBank;
  var total = 0;
  var count = 0;

  var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null
;

  if (oneTouchData !== null) {
    if (oneTouchData.touchActive &amp;&amp; oneTouchData.currentTimeStamp &gt; touchesChangedAfter) {
      total += ofCurrent &amp;&amp; isXAxis ? oneTouchData.currentPageX : ofCurrent &amp;&amp; !isXAxis ? oneTouchData.currentPageY : !ofCurrent
 &amp;&amp; isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
      count = 1;
    }
  } else {
    for (var i = 0; i &lt; touchBank.length; i++) {
      var touchTrack = touchBank[i];
      if (touchTrack !== null &amp;&amp; touchTrack !== undefined &amp;&amp; touchTrack.touchActive &amp;&amp; touchTrack.currentTimeStamp &gt;= touchesChangedAfter
) {
        var toAdd; // Yuck, program temporarily in invalid state.
        if (ofCurrent &amp;&amp; isXAxis) {
          toAdd = touchTrack.currentPageX;
        } else if (ofCurrent &amp;&amp; !isXAxis) {
          toAdd = touchTrack.currentPageY;
        } else if (!ofCurrent &amp;&amp; isXAxis) {
          toAdd = touchTrack.previousPageX;
        } else {
          toAdd = touchTrack.previousPageY;
        }
        total += toAdd;
        count++;
      }
    }
  }
  return count &gt; 0 ? total / count : TouchHistoryMath.noCentroid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
  }
  return count &gt; 0 ? total / count : TouchHistoryMath.noCentroid;
},

currentCentroidXOfTouchesChangedAfter: function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.<span class="apidocCodeKeywordSpan">centroidDimension</span>(touchHistory, touchesChangedAfter, true, //
isXAxis
  true // ofCurrent
  );
},

currentCentroidYOfTouchesChangedAfter: function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  true // ofCurrent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidX" id="apidoc.element.react-dom.TouchHistoryMath.currentCentroidX">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidX
        <span class="apidocSignatureSpan">(touchHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidX = function (touchHistory) {
  return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
  true, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter" id="apidoc.element.react-dom.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidXOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidXOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidY" id="apidoc.element.react-dom.TouchHistoryMath.currentCentroidY">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidY
        <span class="apidocSignatureSpan">(touchHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidY = function (touchHistory) {
  return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
  false, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter" id="apidoc.element.react-dom.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>currentCentroidYOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidYOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter" id="apidoc.element.react-dom.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>previousCentroidXOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previousCentroidXOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
  false // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter" id="apidoc.element.react-dom.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-dom.TouchHistoryMath.</span>previousCentroidYOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previousCentroidYOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  false // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.Transaction" id="apidoc.module.react-dom.Transaction">module react-dom.Transaction</a></h1>




    <h2>
        <a href="#apidoc.element.react-dom.Transaction.closeAll" id="apidoc.element.react-dom.Transaction.closeAll">
        function <span class="apidocSignatureSpan">react-dom.Transaction.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction
 when none are open.') : _prodInvariant('28') : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn't throw, we don't want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.Transaction.initializeAll" id="apidoc.element.react-dom.Transaction.initializeAll">
        function <span class="apidocSignatureSpan">react-dom.Transaction.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &lt; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it's still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it's still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.Transaction.isInTransaction" id="apidoc.element.react-dom.Transaction.isInTransaction">
        function <span class="apidocSignatureSpan">react-dom.Transaction.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance to use as `this` context.
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.<span class="apidocCodeKeywordSpan">isInTransaction</span>()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.Transaction.perform" id="apidoc.element.react-dom.Transaction.perform">
        function <span class="apidocSignatureSpan">react-dom.Transaction.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it's still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn't throw, we don't want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.Transaction.reinitializeTransaction" id="apidoc.element.react-dom.Transaction.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-dom.Transaction.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.ViewportMetrics" id="apidoc.module.react-dom.ViewportMetrics">module react-dom.ViewportMetrics</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.ViewportMetrics.refreshScrollValues" id="apidoc.element.react-dom.ViewportMetrics.refreshScrollValues">
        function <span class="apidocSignatureSpan">react-dom.ViewportMetrics.</span>refreshScrollValues
        <span class="apidocSignatureSpan">(scrollPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshScrollValues = function (scrollPosition) {
  ViewportMetrics.currentScrollLeft = scrollPosition.x;
  ViewportMetrics.currentScrollTop = scrollPosition.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-dom.validateDOMNesting" id="apidoc.module.react-dom.validateDOMNesting">module react-dom.validateDOMNesting</a></h1>


    <h2>
        <a href="#apidoc.element.react-dom.validateDOMNesting.validateDOMNesting" id="apidoc.element.react-dom.validateDOMNesting.validateDOMNesting">
        function <span class="apidocSignatureSpan">react-dom.</span>validateDOMNesting
        <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &amp;&amp; parentInfo.tag;

  if (childText != null) {
    process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should
 be null') : void 0;
    childTag = '#text';
  }

  var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
  var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
  var problematic = invalidParent || invalidAncestor;

  if (problematic) {
    var ancestorTag = problematic.tag;
    var ancestorInstance = problematic.instance;

    var childOwner = childInstance &amp;&amp; childInstance._currentElement._owner;
    var ancestorOwner = ancestorInstance &amp;&amp; ancestorInstance._currentElement._owner;

    var childOwners = findOwnerStack(childOwner);
    var ancestorOwners = findOwnerStack(ancestorOwner);

    var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
    var i;

    var deepestCommon = -1;
    for (i = 0; i &lt; minStackLen; i++) {
      if (childOwners[i] === ancestorOwners[i]) {
        deepestCommon = i;
      } else {
        break;
      }
    }

    var UNKNOWN = '(unknown)';
    var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ownerInfo = [].concat(
    // If the parent and child instances have a common owner ancestor, start
    // with that -- otherwise we just start with the parent's owners.
    deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
    // If we're warning about an invalid (non-parent) ancestry, add '...'
    invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' &gt; ');

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '&lt;' + childTag + '&gt;';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' &amp;&amp; childTag === 'tr') {
        info += ' Add a &lt;tbody&gt; to your code to match the DOM tree generated by ' + 'the browser.';
      }
      process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of &lt;%s&gt;.%s ' + '
See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '&lt;%
s&gt;. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.validateDOMNesting.isTagValidInContext" id="apidoc.element.react-dom.validateDOMNesting.isTagValidInContext">
        function <span class="apidocSignatureSpan">react-dom.validateDOMNesting.</span>isTagValidInContext
        <span class="apidocSignatureSpan">(tag, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTagValidInContext = function (tag, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &amp;&amp; parentInfo.tag;
  return isTagValidWithParent(tag, parentTag) &amp;&amp; !findInvalidAncestorForTag(tag, ancestorInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-dom.validateDOMNesting.updatedAncestorInfo" id="apidoc.element.react-dom.validateDOMNesting.updatedAncestorInfo">
        function <span class="apidocSignatureSpan">react-dom.validateDOMNesting.</span>updatedAncestorInfo
        <span class="apidocSignatureSpan">(oldInfo, tag, instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatedAncestorInfo = function (oldInfo, tag, instance) {
  var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
  var info = { tag: tag, instance: instance };

  if (inScopeTags.indexOf(tag) !== -1) {
    ancestorInfo.aTagInScope = null;
    ancestorInfo.buttonTagInScope = null;
    ancestorInfo.nobrTagInScope = null;
  }
  if (buttonScopeTags.indexOf(tag) !== -1) {
    ancestorInfo.pTagInButtonScope = null;
  }

  // See rules for 'li', 'dd', 'dt' start tags in
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
  if (specialTags.indexOf(tag) !== -1 &amp;&amp; tag !== 'address' &amp;&amp; tag !== 'div' &amp;&amp; tag !== 'p') {
    ancestorInfo.listItemTagAutoclosing = null;
    ancestorInfo.dlItemTagAutoclosing = null;
  }

  ancestorInfo.current = info;

  if (tag === 'form') {
    ancestorInfo.formTag = info;
  }
  if (tag === 'a') {
    ancestorInfo.aTagInScope = info;
  }
  if (tag === 'button') {
    ancestorInfo.buttonTagInScope = info;
  }
  if (tag === 'nobr') {
    ancestorInfo.nobrTagInScope = info;
  }
  if (tag === 'p') {
    ancestorInfo.pTagInButtonScope = info;
  }
  if (tag === 'li') {
    ancestorInfo.listItemTagAutoclosing = info;
  }
  if (tag === 'dd' || tag === 'dt') {
    ancestorInfo.dlItemTagAutoclosing = info;
  }

  return ancestorInfo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    parentInfo = hostContainerInfo._ancestorInfo;
  }
  if (parentInfo) {
    // parentInfo should always be present except for the top-level
    // component when server rendering
    validateDOMNesting(this._tag, null, this, parentInfo);
  }
  this._ancestorInfo = validateDOMNesting.<span class="apidocCodeKeywordSpan">updatedAncestorInfo</span>(parentInfo, this._tag,
this);
}

var mountImage;
if (transaction.useCreateElement) {
  var ownerDocument = hostContainerInfo._ownerDocument;
  var el;
  if (namespaceURI === DOMNamespaces.html) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>